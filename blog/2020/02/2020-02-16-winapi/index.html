<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.13.7"/><style data-href="/styles.9e907bc32054b7771552.css" data-identity="gatsby-global-css">code[class*=language-],pre[class*=language-]{word-wrap:normal;background:none;color:#ccc;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em;white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property,.token.symbol{color:#f8c555}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:#cc99cd}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}</style><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><style data-styled="" data-styled-version="6.1.12">.kBJwwi{display:flex;flex:1;position:relative;margin:0 auto;align-items:start;width:1024px;max-width:1024px;}/*!sc*/
@media (max-width:1024px){.kBJwwi{margin:0;width:auto;}}/*!sc*/
data-styled.g1[id="PostContent__PostWrapper-sc-9jovib-0"]{content:"kBJwwi,"}/*!sc*/
.bRClYm{border-bottom:1px solid #e6e6e6;}/*!sc*/
.bRClYm>div{display:flex;flex:1;align-items:center;justify-content:space-between;margin:0 auto;max-width:1024px;padding:0 20px;}/*!sc*/
@media (max-width:1024px){.bRClYm>div{margin:0;min-width:auto;}}/*!sc*/
.bRClYm h1{font-size:24px;margin:12px 0 8px;}/*!sc*/
data-styled.g2[id="PostContent__PostHeadWrapper-sc-9jovib-1"]{content:"bRClYm,"}/*!sc*/
.kSKGsK{width:80%;}/*!sc*/
@media (max-width:1024px){.kSKGsK{width:100%;}}/*!sc*/
data-styled.g3[id="PostContent__PostContentWrapper-sc-9jovib-2"]{content:"kSKGsK,"}/*!sc*/
.fCRfSO{padding:0 20px;margin-bottom:48px;}/*!sc*/
.fCRfSO>h1{margin-bottom:8px;font-size:40px;}/*!sc*/
data-styled.g4[id="PostContent__PostTitle-sc-9jovib-3"]{content:"fCRfSO,"}/*!sc*/
.bOdkMk{display:inline-block;margin:12px 0 0 10px;position:sticky;top:20px;left:10px;transition:all 0.125s esse-in 0s;color:rgba(0,0,0,0.4);padding:0 0.75rem;border-left:2px solid gray;overflow-y:auto;overflow-x:hidden;}/*!sc*/
.bOdkMk ul{list-style:none;}/*!sc*/
.bOdkMk ul li{margin-top:5px;}/*!sc*/
.bOdkMk ul li a{display:inline-block;}/*!sc*/
.bOdkMk ul li a.reach{color:#000000;}/*!sc*/
.bOdkMk ul ul{margin-left:12px;}/*!sc*/
@media (max-width:1024px){.bOdkMk{display:none;}}/*!sc*/
data-styled.g5[id="PostContent__TocRenderer-sc-9jovib-4"]{content:"bOdkMk,"}/*!sc*/
.ga-DJQu{display:flex;flex-direction:column;word-break:keep-all;margin-bottom:250px;padding:0 20px;width:100%;line-height:1.8;font-size:16px;font-weight:400;}/*!sc*/
@media (max-width:1024px){.ga-DJQu{margin-bottom:48px;}}/*!sc*/
.ga-DJQu p{padding:3px 0;}/*!sc*/
.ga-DJQu h1,.ga-DJQu h2,.ga-DJQu h3{font-weight:800;}/*!sc*/
.ga-DJQu *+h1{margin-top:60px;}/*!sc*/
.ga-DJQu *+h2{margin-top:40px;}/*!sc*/
.ga-DJQu *+h3{margin-top:30px;}/*!sc*/
.ga-DJQu hr+h1,.ga-DJQu hr+h2,.ga-DJQu hr+h3{margin-top:0;}/*!sc*/
.ga-DJQu h1{font-size:30px;}/*!sc*/
.ga-DJQu h2{font-size:25px;}/*!sc*/
.ga-DJQu h3{font-size:20px;}/*!sc*/
.ga-DJQu blockquote{margin:30px 0;padding:5px 15px;border-left:2px solid #000000;font-weight:800;}/*!sc*/
.ga-DJQu ol,.ga-DJQu ul{margin-left:20px;padding:10px 0;}/*!sc*/
.ga-DJQu hr{border:1px solid #000000;margin:100px 0;}/*!sc*/
.ga-DJQu a{color:#4263eb;text-decoration:underline;}/*!sc*/
.ga-DJQu pre[class*='language-']{margin:30px 0;padding:15px;font-size:15px;}/*!sc*/
.ga-DJQu pre[class*='language-'] ::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.5);border-radius:3px;}/*!sc*/
.ga-DJQu code[class*='language-'],.ga-DJQu pre[class*='language-']{tab-size:2;}/*!sc*/
.ga-DJQu img{width:100%;}/*!sc*/
.ga-DJQu summary{cursor:pointer;font-size:24px;}/*!sc*/
data-styled.g6[id="PostContent__MarkdownRenderer-sc-9jovib-5"]{content:"ga-DJQu,"}/*!sc*/
.caxlE{margin:40px 0;display:flex;flex-wrap:wrap;justify-content:space-between;list-style:none;padding:0 20px;}/*!sc*/
.caxlE h5{font-size:24px;margin-bottom:8px;}/*!sc*/
.caxlE a{border-radius:6px;font-size:20px;color:#cc007a;font-weight:700;}/*!sc*/
data-styled.g7[id="PostContent__PostNavigator-sc-9jovib-6"]{content:"caxlE,"}/*!sc*/
.hAHpYk{display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,0.7);color:#161b21;width:40px;height:40px;min-width:40px;font-size:20px;border:none;border-radius:50%;}/*!sc*/
.hAHpYk>img{width:35px;height:35px;}/*!sc*/
data-styled.g8[id="PostContent__SocialLink-sc-9jovib-7"]{content:"hAHpYk,"}/*!sc*/
.hyIhte{display:grid;place-items:center;margin-top:auto;margin-left:0;padding:50px 0;font-size:15px;text-align:center;line-height:1.5;}/*!sc*/
@media (max-width:1024px){.hyIhte{margin-left:0;}}/*!sc*/
data-styled.g16[id="Footer__FooterWrapper-sc-rphy7j-0"]{content:"hyIhte,"}/*!sc*/
html{line-height:1.15;-webkit-text-size-adjust:100%;}/*!sc*/
body{margin:0;}/*!sc*/
main{display:block;}/*!sc*/
h1{font-size:2em;margin:0.67em 0;}/*!sc*/
hr{box-sizing:content-box;height:0;overflow:visible;}/*!sc*/
pre{font-family:monospace,monospace;font-size:1em;}/*!sc*/
a{background-color:transparent;}/*!sc*/
abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted;}/*!sc*/
b,strong{font-weight:bolder;}/*!sc*/
code,kbd,samp{font-family:monospace,monospace;font-size:1em;}/*!sc*/
small{font-size:80%;}/*!sc*/
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;}/*!sc*/
sub{bottom:-0.25em;}/*!sc*/
sup{top:-0.5em;}/*!sc*/
img{border-style:none;}/*!sc*/
button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0;}/*!sc*/
button,input{overflow:visible;}/*!sc*/
button,select{text-transform:none;}/*!sc*/
button,[type="button"],[type="reset"],[type="submit"]{-webkit-appearance:button;}/*!sc*/
button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0;}/*!sc*/
button:-moz-focusring,[type="button"]:-moz-focusring,[type="reset"]:-moz-focusring,[type="submit"]:-moz-focusring{outline:1px dotted ButtonText;}/*!sc*/
fieldset{padding:0.35em 0.75em 0.625em;}/*!sc*/
legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal;}/*!sc*/
progress{vertical-align:baseline;}/*!sc*/
textarea{overflow:auto;}/*!sc*/
[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0;}/*!sc*/
[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{height:auto;}/*!sc*/
[type="search"]{-webkit-appearance:textfield;outline-offset:-2px;}/*!sc*/
[type="search"]::-webkit-search-decoration{-webkit-appearance:none;}/*!sc*/
::-webkit-file-upload-button{-webkit-appearance:button;font:inherit;}/*!sc*/
details{display:block;}/*!sc*/
summary{display:list-item;}/*!sc*/
template{display:none;}/*!sc*/
[hidden]{display:none;}/*!sc*/
*{padding:0;margin:0;box-sizing:border-box;}/*!sc*/
html,body,#___gatsby{height:100%;word-break:keep-all;overflow-wrap:break-word;}/*!sc*/
#gatsby-focus-wrapper{height:100%;}/*!sc*/
a,a:hover{color:inherit;text-decoration:none;cursor:pointer;}/*!sc*/
.utterances{max-width:1024px;margin:0 auto;}/*!sc*/
data-styled.g18[id="sc-global-dhQtTb1"]{content:"sc-global-dhQtTb1,"}/*!sc*/
.bKZOak{display:flex;flex-direction:column;height:100%;}/*!sc*/
data-styled.g19[id="Template__Container-sc-1a9t0ug-0"]{content:"bKZOak,"}/*!sc*/
</style><style type="text/css">
    .custom-class.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .custom-class.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .custom-class svg,
    h2 .custom-class svg,
    h3 .custom-class svg,
    h4 .custom-class svg,
    h5 .custom-class svg,
    h6 .custom-class svg {
      visibility: hidden;
    }
    h1:hover .custom-class svg,
    h2:hover .custom-class svg,
    h3:hover .custom-class svg,
    h4:hover .custom-class svg,
    h5:hover .custom-class svg,
    h6:hover .custom-class svg,
    h1 .custom-class:focus svg,
    h2 .custom-class:focus svg,
    h3 .custom-class:focus svg,
    h4 .custom-class:focus svg,
    h5 .custom-class:focus svg,
    h6 .custom-class:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="canonical" href="https://seungahhong.github.io/blog/2020/02/2020-02-16-winapi/" data-baseprotocol="https:" data-basehost="seungahhong.github.io"/><link rel="sitemap" type="application/xml" href="/sitemap-index.xml"/><link rel="preconnect" href="https://www.google-analytics.com"/><link rel="dns-prefetch" href="https://www.google-analytics.com"/><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'G-TYGQRJE1B8', 'auto', {});
      
      
      
      
      
      }</script><link rel="preconnect" href="https://www.googletagmanager.com"/><link rel="dns-prefetch" href="https://www.googletagmanager.com"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-G8Z1HZWWYL"></script><script>
      
      
      if(true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-G8Z1HZWWYL', {"send_page_view":false});
      }
      </script></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="Template__Container-sc-1a9t0ug-0 bKZOak"><header class="PostContent__PostHeadWrapper-sc-9jovib-1 bRClYm"><div><a href="/"><h1>홍승아블로그</h1></a><a href="https://github.com/seungahhong" rel="noopener noreferrer" title="notion" target="_blank" size="35" class="PostContent__SocialLink-sc-9jovib-7 hAHpYk"><img src="/static/4a6687a74051de2b3536e95d0b6c992a/github.svg" alt="Github Link Image"/></a></div></header><div class="PostContent__PostWrapper-sc-9jovib-0 kBJwwi"><div class="PostContent__PostContentWrapper-sc-9jovib-2 kSKGsK"><div class="PostContent__PostTitle-sc-9jovib-3 fCRfSO"><h1>Windows API</h1><time>2020.02.16</time></div><article class="PostContent__MarkdownRenderer-sc-9jovib-5 ga-DJQu"><h1 id="windows-programming" style="position:relative;"><a href="#windows-programming" aria-label="windows programming permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>windows programming</h1>
<ul>
<li>
<p>윈도우즈의 장점</p>
<ol>
<li>그래픽 기반의 운영체제</li>
</ol>
<ul>
<li>화면 처리를 문자 단위가 아닌 디지털 표현의 최소 단위인 픽셀로 처리해서 화면 처리 가능</li>
</ul>
<ol start="2">
<li>멀티 태스킹이 가능하다.</li>
</ol>
<ul>
<li>한번에 여러가지 일을 수행함.</li>
</ul>
<ol start="3">
<li>장치에 영향을 받지 않는다.</li>
</ol>
<ul>
<li>디바이스 드라이버에 의해 주변 장치들을 제어하고 관리한다. 장치가 바뀌면 디바이스 드라이버만 교체해주면 되고 소프트웨어는
이에 영향을 받지 않는다.</li>
</ul>
<ol start="4">
<li>일관성</li>
</ol>
<ul>
<li>인터페이스 구성이 표준화됨에 따라서 한 번 배우기만 하면 어떤 프로그램이든지 유사한 방법으로 사용 가능함.</li>
</ul>
</li>
<li>
<p>윈도우즈 프로그램을 링크하여 실행 파일을 생성할 때는 개발 환경에서 제공하는 특별한 ‘임포트 라이브러리’와 링크해야 한다. 임포트</p>
<p>라이브러리에는 DLL 이름과 더불어 프로그램이 사용하는 모든 윈도우즈 함수 호출을 위한 참조 정보가 들어 있다.</p>
</li>
</ul>
<ul>
<li>
<p>임포트 라이브러리 확인 : Project - Setting - Link Tab에서 확인가능</p>
</li>
<li>
<p>링커는 이 정보를 토대로 실행 파일(.EXE) 안에 테이블을 생성하고, 윈도우즈는 프로그램을 로드할 때 이 테이블 정보를 수정하여 실제</p>
<p>윈도우즈 함수를 호출 할 수 있다.</p>
</li>
</ul>
<p>#include &#x3C;windows.h></p>
<p>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
PSTR szCmdLine, int iCmdShow)
{
MessageBox(NULL, TEXT(“Hello Windows!”), TEXT(“HelloMsg”), 0);</p>
<p>return 0;
}</p>
<ul>
<li>헤더파일(#include &#x3C;windows.h>)</li>
</ul>
<ol>
<li>
<p>WINDEF.H : 기본 타입 정의</p>
</li>
<li>
<p>WINNT.H : 유니코드 지원을 위한 타입 정의</p>
</li>
<li>
<p>WINBASE.H : Kernel 함수</p>
</li>
<li>
<p>WINUSER.H : 사용자 인터페이스 함수</p>
</li>
<li>
<p>WINGDI.H : 그래픽 장치 인터페이스 함수</p>
</li>
</ol>
<ul>
<li>프로그램 진입점</li>
</ul>
<p>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
PSTR szCmdLine, int iCmdShow)</p>
<ol>
<li>#define WINAPI __stdcall</li>
</ol>
<ul>
<li>컴파일, 링크, 실행</li>
</ul>
<ol>
<li>
<p>컴파일 단계에서 컴파일러는 C소스 코드 파일로부터 .OBJ 파일을 생성한다.</p>
</li>
<li>
<p>링크 단계에 링커는 .OBJ 파일과 .LIB 파일을 겹합하여 .EXE 파일을 만든다.</p>
</li>
</ol>
<p>-KERNEL32.LIB, USER32.LIB, GDI32.LIB 파일은 윈도우즈 서브시스템을 사용하기 위한 ‘임포트 라이브러리’임.</p>
<ol start="3">
<li>비주얼 C++에서는 Debug, Release 환경 설정을 이용해서 프로그램을 컴파일 및 링크할 수 있다.</li>
</ol>
<h1 id="유니코드" style="position:relative;"><a href="#%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C" aria-label="유니코드 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>유니코드</h1>
<ul>
<li>유니코드와 DBCS 차이점</li>
</ul>
<ul>
<li>
<p>유니코드는 와이드 문자(16비트)를 항상 사용한다(8비트 문자는 아무 의미가 없다.)</p>
</li>
<li>
<p>DBCS(Double Byte Character set)는 여전히 8비트 값을 나타낸다.</p>
</li>
</ul>
<ul>
<li>
<p>와이드 문자와 윈도우즈</p>
<ol>
<li>윈도우즈 헤더 파일 타입</li>
</ol>
<ul>
<li>
<p>typedef char CHAR;</p>
</li>
<li>
<p>typedef wchar_t WCHAR;</p>
</li>
</ul>
<ol>
<li>8비트 문자열</li>
</ol>
<p>typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;</p>
<p>typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;</p>
<p>typedef CONST CHAR *LPCCH, *PCCH;</p>
<p>typedef CONST CHAR *LPCSTR, *PCSTR;</p>
<ol start="2">
<li>16비트 문자열</li>
</ol>
<p>typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;</p>
<p>typedef CONST WCHAR *LPCWSTR, *PCWSTR;</p>
<p>typedef CONST WCHAR *LPCWCH, *PCWCH;</p>
</li>
<li>
<p>윈도우즈 함수 호출 : UNICODE 식별자 정의에 따라 다른 MessageBox 호출됨.</p>
</li>
</ul>
<ol>
<li>
<p>int WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT)</p>
<ul>
<li>WINUSERAPI int WINAPI MessageBoxA(HWND hWnd , LPCSTR lpText, LPCSTR lpCaption, UINT uType);
WINUSERAPI int WINAPI MessageBoxW(HWND hWnd , LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
#ifdef UNICODE
#define MessageBox MessageBoxW
#else
#define MessageBox MessageBoxA
#endif // !UNICODE</li>
</ul>
</li>
</ol>
<ul>
<li>윈도우즈의 문자열: UNICODE 식별자 정의에 따라 다른 문자열 함수가 호출됨.</li>
</ul>
<p>WINBASEAPI int WINAPI lstrlenA( LPCSTR lpString );
WINBASEAPI int WINAPI lstrlenW( LPCWSTR lpString );
#ifdef UNICODE
#define lstrlen lstrlenW
#else
#define lstrlen lstrlenA
#endif // !UNICODE</p>
<ul>
<li>윈도우즈에서 printf 사용하기</li>
</ul>
<h1 id="윈도우즈와-메시지" style="position:relative;"><a href="#%EC%9C%88%EB%8F%84%EC%9A%B0%EC%A6%88%EC%99%80-%EB%A9%94%EC%8B%9C%EC%A7%80" aria-label="윈도우즈와 메시지 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>윈도우즈와 메시지</h1>
<p>// hInstance : 인스턴스 핸들, hPrevInstance : WIN16와 호환성을 위해 남겨둠,</p>
<p>// lpCmdLine : 프로그램에 전달되는 명령행 인자, nCmdShow : 처음 뜰 때 메인 윈도우 화면에 표시하는 방법(SW_SHOWNOMAL 등)</p>
<p>#include &#x3C;windows.h></p>
<p>LRESULT CALLBACK WndProc(HWND,UINT,WPARAM,LPARAM);
HINSTANCE g_hInst;
LPCTSTR lpszClass=TEXT(“First”);</p>
<p>int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance
,LPSTR lpszCmdParam,int nCmdShow)
{
HWND hWnd;
MSG Message;
WNDCLASS WndClass;
g_hInst=hInstance;</p>
<p>WndClass.cbClsExtra=0;
WndClass.cbWndExtra=0;
WndClass.hbrBackground=(HBRUSH)GetStockObject(WHITE_BRUSH);
WndClass.hCursor=LoadCursor(NULL,IDC_ARROW);
WndClass.hIcon=LoadIcon(NULL,IDI_APPLICATION);
WndClass.hInstance=hInstance;
WndClass.lpfnWndProc=WndProc;
WndClass.lpszClassName=lpszClass;
WndClass.lpszMenuName=NULL;
WndClass.style=CS_HREDRAW | CS_VREDRAW; //윈도우 사이즈 변경시 WM_PAINT 호출
RegisterClass(&#x26;WndClass);</p>
<p>hWnd=CreateWindow(lpszClass,lpszClass,WS_OVERLAPPEDWINDOW,
CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
NULL,(HMENU)NULL,hInstance,NULL);
1번째 : 윈도우 클래스 이름을 나타내는 포인터</p>
<p>2번째 : 윈도우 이름을 나타내는 포인터</p>
<p>3번째 : 윈도우 스타일</p>
<ul>
<li>
<p>WS_OVERLAPPEDWINDOW : WS_OVERLAPPED, WS_CAPTION, WS_SYSMENU,WS_THICKFRAME,WS_MINIMIZEBOX,</p>
<p>WS_MAXIMIZEBOX 속성을 모두 갖는 윈도우를 생성한다.</p>
</li>
<li>
<p>4번째 : 시스템이 적절한 디폴트 위치에 윈도우를 생성</p>
</li>
</ul>
<p>ShowWindow(hWnd,nCmdShow);</p>
<p>UpdateWindow(hWnd);</p>
<p>while (GetMessage(&#x26;Message,NULL,0,0)) {
TranslateMessage(&#x26;Message);
DispatchMessage(&#x26;Message);
}
return (int)Message.wParam;
}</p>
<p>LRESULT CALLBACK WndProc(HWND hWnd,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
switch (iMessage) {
case WM_DESTROY:
PostQuitMessage(0);
return 0;
}
return(DefWindowProc(hWnd,iMessage,wParam,lParam));
}</p>
<ul>
<li>
<p>윈도우 : 사용자로부터 입력을 받거나 텍스트와 그래픽 형태로 출력하는 하면의 직사각형 영역을 말한다.</p>
</li>
<li>
<p>윈도우 종류</p>
<ul>
<li>
<p>애플리케이션 윈도우 : 툴바, 스크롤바</p>
</li>
<li>
<p>대화상자</p>
</li>
<li>
<p>자식윈도우, 컨트롤윈도우, 자식 윈도우 컨트롤 : push button, radio button, check box, list box, scroll bar</p>
</li>
</ul>
</li>
<li>
<p>윈도우 프로시저</p>
</li>
</ul>
<p>while(GetMessage(&#x26;msg, NULL, 0, 0))
{
TranslateMessage(&#x26;msg);
DispatchMessage(&#x26;msg);
}</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">- 메시지 처리 함수 : 메시지가 발생할 때 프로그램의 반응을 처리하는 일을 하며 WinMain 함수와는 별도로 WndProc이라는 이름으로

                            존재한다.

- WndProc은 WinMain에서 호출하는 것이 아니라 윈도우즈에 의해 호출된다.

- WinMain내의 메시지 루프는 메시지를 메시지 처리 함수로 보내주기만 할 뿐이며 WndProc은 메시지가 입력되면 윈도우즈에 의해

  호출되어 메시지를 처리한다.

- 운영체제에 의해 호출되는 응용 프로그램내의 함수를 콜백(CallBack) 함수라고 한다.

- 메시지 큐에 쌓이지 않고 곧바로 윈도우 프로시저에 전달되는 것은 ?</code></pre></div>
<ul>
<li>
<p>대기 메시지와 비대기 메시지</p>
<ul>
<li>
<p>대기 메시지는 메시지 큐에 쌓인 메시지를 윈도우 프로시저에 전달하고 비대기 메시지는 윈도우즈가 직접 윈도우 프로시저에 전달함.</p>
</li>
<li>
<p>대기메시지 : 주로 사용자의 행위로 인한 결과(WM_KEYDOWN, WM_LBUTTONDOWN 등)</p>
</li>
<li>
<p>비대기메시지 : 특정 윈도우즈 함수를 호출함으로써 종종 발생한다.</p>
<ol>
<li>CreateWindow() 호출하면, 윈도우를 생성하고 그 과정에서 윈도우 프로시저에 WM_CREATE 메시지를 보내다.</li>
</ol>
</li>
</ul>
</li>
<li>
<p>윈도우 함수 호출</p>
</li>
</ul>
<ul>
<li>
<p>GetStockObject() 그래픽 객체를 얻는다.</p>
</li>
<li>
<p>RegisterClass() 프로그램의 윈도우를 위한 윈도우 클래스를 등록한다.</p>
</li>
<li>
<p>ShowWindow() 윈도우를 화면에 표시한다.</p>
</li>
<li>
<p>UpdateWinow() 윈도우가 자기 자신을 그리도록 명령한다.</p>
</li>
<li>
<p>GetClientRect() 윈도우의 클라이언트 영역 치수를 얻는다.</p>
</li>
<li>
<p>PostQuitMessage() : 메시지 큐에 종료(quit) 메시지를 삽입한다.</p>
</li>
<li>
<p>DetWindowProc() : 메시지에 대한 디폴트 처리를 담당한다.</p>
</li>
</ul>
<ul>
<li>
<p>새로운 데이터 타입</p>
<ul>
<li>
<p>MSG : 메시지 구조체</p>
</li>
<li>
<p>WNDCLASS : 윈도우 클래스 구조체</p>
</li>
<li>
<p>PAINTSTRUCT : 그리기 구조체</p>
</li>
<li>
<p>RECT : 직사각형 구조체</p>
</li>
</ul>
</li>
<li>
<p>핸들( 단순히 숫자(흔히 32비트 크기)로서 객체를 참조한다.</p>
<ul>
<li>
<p>HINSTRANCE : 프로그램 자체 인스턴스 핸들</p>
</li>
<li>
<p>HWND : 위도우 핸들</p>
</li>
<li>
<p>HDC : 디바이스 컨텍스트 핸들.</p>
</li>
</ul>
</li>
<li>
<p>헝가리안 표기법</p>
</li>
<li>
<p>윈도우 클래스 등록하기(RegisterClass(&#x26;wndclass) // WNDCLASS wndclass;</p>
</li>
</ul>
<ul>
<li>
<p>애플리케이션 윈도우를 생성하려면 우선 RegisterClass()를 호출함으로써 윈도우 클래스를 등록해야한다.</p>
</li>
<li>
<p>WNDCLASS ASCII 버전</p>
</li>
</ul>
<p>typedef struct tagWNDCLASSA {
UINT style;
WNDPROC lpfnWndProc;
int cbClsExtra;
int cbWndExtra;
HINSTANCE hInstance;
HICON hIcon;
HCURSOR hCursor;
HBRUSH hbrBackground;
LPCSTR lpszMenuName;
LPCSTR lpszClassName;
} WNDCLASSA, *PWNDCLASSA, NEAR *NPWNDCLASSA, FAR *LPWNDCLASSA;</p>
<ul>
<li>10개의 필드를 초기화 한후 RegisterClass()를 호출함.</li>
</ul>
<ol>
<li>
<p>2번째 필드(lpfnWndProc)</p>
<ul>
<li>WndProc을 윈도우 클래스의 윈도우 프로시저로 설정한다.</li>
</ul>
<p>예) wndclass.lpfnWndProc = WndProc</p>
<ul>
<li>WndProc은 이 윈도우 클래스를 기반으로 생성한 모든 윈도우에 전달되는 메시지를 처리한다.</li>
</ul>
</li>
</ol>
<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">if(!RegisterClass(&amp;wndclass))
{
  MessageBox(NULL, TEXT(&quot;This program requires Windows NT!&quot;), szAppName, MB_ICONERROR);

  return 0;
}</code></pre></div>
<p>//프로그램 컴파일시 UNICODE 식별자를 정의하고 WINDOWS NT계열에서 RegisterClassW() 구현되어 있어서 돌아감.</p>
<p>// 하지만 Windows 0x 계열에서는 RegisterClassW() 구현안되므로 위에 코드처럼 사용자에게 알려주고 0을 리턴하게 함.</p>
<ul>
<li>윈도우 생성하기</li>
</ul>
<ul>
<li>윈도우, 윈도우 클래스의 차이</li>
</ul>
<p>예) 푸시 버튼 윈도우 공통된 윈도우 클래스와 연관된 윈도우 프로시저는 윈도우즈 내부에 존재함.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">    동일한 동작에 대한 정의 : 윈도우 프로시저/ 문자열, 화면위치 변경 등 이런 특성은 윈도우 정의에 일부분으로 설정</code></pre></div>
<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">hwnd = CreateWindow(szAppName, //생성하고자 하는 윈도우의 클래스를 지정하는 문자열
  TEXT(&quot;The Hello Program&quot;),
  WS_OVERLAPPEDWINDOW,
  CW_USEDEFAULT,
  CW_USEDEFAULT,
  CW_USEDEFAULT,
  CW_USEDEFAULT,
  NULL,
  NULL,
  hInstance,
  NULL);</code></pre></div>
<p>-CreateWindow는 HWND 타입에 윈도우 핸들을 리턴하고 프로그램들은 핸들을 이용하여 윈도우를 참조할 수 있다</p>
<ul>
<li>윈도우 표시하기</li>
</ul>
<p>ShowWindow(hwnd, iCmdShow); : 윈도우가 화면에 드러나게 한다.</p>
<ol>
<li>
<p>hwnd : CreateWindow()로 방금 생성한 윈도우 핸들</p>
</li>
<li>
<p>iCmdShow : 초기에 윈도우가 화면에 떠허게 표시될지를 결정함(정상, 최소화, 최대화 중 하나)</p>
</li>
<li>
<p>윈도우 클래스에 지정한 배경 브러시로 윈도우 클라이언트 영역 지워짐</p>
</li>
</ol>
<ul>
<li>ShowWindow() ,UpdateWindow() 차이점</li>
</ul>
<ol>
<li>
<p>같은 점 : WM_PAINT 메시지를 윈도우 프로시저로 보냄</p>
</li>
<li>
<p>다른 점 : UpdateWindow를 메시지 큐에 저장하지 않고 바로 윈도우 프로시저로 보냄으로써 윈도우를 빠르게 화면에 출력하게 함.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">        과거에는 컴퓨터 처리속도가 느려서 ShowWindow 하나만 했을 경우에 느리게 나오는 문제가 있어서 UpdateWindow를 쓰게

        되었지만 현재는 컴퓨터 속도이 빨라져서 안써도 상관은 없다.</code></pre></div>
</li>
</ol>
<ul>
<li>메시지 루프</li>
</ul>
<ol>
<li>
<p>윈도우즈는 현재 수행되고 있는 각 윈도우즈 프로그램마다 ‘메시지 큐’를 유지한다.</p>
<p>-입력 이벤트가 발생시 윈도우즈는 이벤트를 ‘메시지로 바꾸어 프로그램의 메시큐에 저장해 둔다.</p>
</li>
</ol>
<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">typedef struct tagMSG {
HWND hwnd;
UINT message;
WPARAM wParam;
LPARAM lParam;
DWORD time; // 메시지가 메시지 큐에 들어간 시간
POINT pt; // 메시지가 메시지 큐에 들어갈때 좌표.
} MSG, *PMSG, NEAR *NPMSG, FAR \*LPMSG;</code></pre></div>
<ol start="2">
<li>
<p>GetMessage(&#x26;msg, NULL, 0, 0) : 메시지 필드가 WM_QUIT이 아니라면 0이 아닌 값을 리턴함. 맞다면 0을 리턴해서 메시지 수신을</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                            못하게 함.</code></pre></div>
</li>
</ol>
<ul>
<li>
<p>MSG 구조체 타입 변수인 msg의 포인터를 윈도우즈에 넘겨준다.</p>
</li>
<li>
<p>윈도우즈는 메시지 큐로부터 메시지를 꺼낼 올 때마다 메시지 구조체의 각 필드를 채운다.</p>
<p>● hwnd : 메시지가 향할 윈도우를 나타내는 핸들.</p>
<p>● message : 메시지 식별자로서, 메시지를 나타내는 숫자이다. 예) 마우스 왼쪽을 누를시 WM_LBUTTONDOWN 이 된다.</p>
</li>
</ul>
<ol start="3">
<li>TranslateMessage(&#x26;msg)</li>
</ol>
<ul>
<li>
<p>msg 구조체를 윈도우즈에 넘겨서 키보드 메시지 변환을 한다.</p>
</li>
<li>
<p>WM_KEYDOWN인지와 눌려진 키가 문자키인지 검사하고 조건이 맞을경우 메시지큐에 WM_CHAR 메시지를 만들어서 붙인다.</p>
</li>
</ul>
<ol start="4">
<li>DispatchMessage(&#x26;msg)</li>
</ol>
<ul>
<li>
<p>msg 구조체를 윈도우즈에 넘기고 윈도우즈는 이 메시지를 적절한 윈도우 프로시저에 보내서 처리하도록 한다.</p>
<p>이것은 윈도우즈가 윈도우 프로시저를 호출한다는 것이다.</p>
</li>
</ul>
<p>WndProc가 리턴을 해야지 DispatchMessage도 리턴하게 되고 그 이후에 GetMessage로 넘어가게 됨</p>
<ul>
<li>윈도우 프로시저</li>
</ul>
<ul>
<li>
<p>윈도우가 클라이언트 영역에 표시하는 내용과 사용자의 입력에 대한 반응을 결정하는 것을 말한다.</p>
</li>
<li>
<p>MSG 구조체의 처음 필드 네개와 동일하다.</p>
</li>
<li>
<p>프로그램이 간접적으로 자신의 윈도우 프로시저를 호출하기 위해서 SendMessag를 사용할 수 있다.</p>
</li>
</ul>
<ul>
<li>메시지 처리하기</li>
</ul>
<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  switch(message)
  {
    case WM_DESTROY:
    PostQuitMessage(0);
    return 0;
  }
  return DefWindowProc(hwnd, message, wParam, lParam);
}</code></pre></div>
<ul>
<li>
<p>윈도우 프로시저가 받는 모든 메시지는 숫자로 확인할 수 있는데, 이 숫자는 message 매개변수에 전달된다.</p>
</li>
<li>
<p>윈도우 프로시저가 처리하지 않기로 한 메시지는 윈도우즈 함수인 DefWindowProc에 전달해서 디폴트로 처리되도록 해야한다.</p>
</li>
</ul>
<ul>
<li>
<p>WM_PAINT 메시지</p>
<ul>
<li>
<p>윈도우의 클라이언트 영역 일부 또는 전체가 ‘무효’ or ‘갱신’되어야 함을 프로그램에 알리는 역할을 한다.</p>
</li>
<li>
<p>윈도우가 처음 생성될 때는 프로그램이 화면에 아무것도 그리지 않은 상태이므로 클라이언트 영역 저네가 무효화된다.</p>
</li>
<li>
<p>WinMain() : ShowWindow, UpdateWindow를 호출시 윈도우 프로시저에 지시하여 클라이언트 영역에 무언가를 그리게 한다.</p>
</li>
</ul>
<p>예) hdc = BeginPaint(hwnd, &#x26;ps);</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">  EndPaint(hwnd, &amp;ps);</code></pre></div>
<ul>
<li>
<p>BeginPaint()를 호출했을 때, 윈도우즈는 클라이언트 영역이 아직 지워지지 않았을 경우, 클라이언트 영역의 배경을 지운다.</p>
<p>배경을 지울 때는 윈도우 클래스를 등록할 때 WNDCLASS 구조체의 hbrBackground 필드로 지정한 브러시를 사용함.</p>
<p>현재, wndclass.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH); 이므로 흰색으로 칠하게 된다.</p>
</li>
<li>
<p>BeginPaint() 호출은 전체 클라이언트 영역을 유효화하고, 디바이스 컨텍스트 핸들을 리턴한다.</p>
</li>
<li>
<p>디바이스 컨텍스트 : 물리적 출력 장치와 관련 디바이스 드라이버를 통틀어서 나타내는 개념으로 윈도우의 클라이언트 영역에</p>
<p>텍스트와 그래픽을 출력하기 위해서 디바이스 컨텍스트 핸들이 필요하다.</p>
</li>
<li>
<p>EndPaint()는 디바이스 컨텍스트 핸들을 해제하여 더 이상 유효하지 않게 한다.</p>
</li>
</ul>
</li>
<li>
<p>WM_DESTROY 메시지</p>
<ul>
<li>
<p>윈도우즈가 사용자에 명령에 따라 윈도우를 파괴하는 중임을 나타낸다. (종료버튼, 시스템 메뉴 - 닫기)</p>
</li>
<li>
<p>PostQuitMessage(0) -메시지 큐에 WM_QUIT 메시지를 삽입</p>
</li>
<li>
<p>return msg.wParam -PostQuitMessage() 에 넘겨준 값(보통 0)이 그대로 들어 있다.</p>
</li>
</ul>
</li>
<li>
<p>WM_SYSCOMMAND, WM_CLOSE, WM_DESTROY</p>
</li>
</ul>
<ol>
<li>
<p>WM_SYSCOMMAND : 창 사용자 (시스템 또는 컨트롤 메뉴 라고도 함)는 창 메뉴에서 명령을 선택 하는 경우에 메시지를 수신 또는</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                            최대화 단추를 선택 하는 경우 최소화 단추, 복원 단추, 닫기 단추 -매개변수에 SC_CLOSE 호출될 경우</code></pre></div>
</li>
<li>
<p>WM_CLOSE : 윈도우가 닫히기 전에 메시지가 전달 된다. 아직 윈도우가 파괴된 것은 아니므로 윈도우가 파괴되는 것을</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                 중간에 제어 할 수 있다. -DestroyWindow() 호출(윈도우 프로시저 : WM_DESTROY 호출)</code></pre></div>
</li>
<li>
<p>WM_DESTROY : 윈도우가 메모리에서 파괴될 때 발생한다. -PostQuitMessage() 호출함으로써 메시키큐에 WM_QUIT 넣고</p>
</li>
<li>
<p>WM_QUIT : 프로그램을 끝낼 때 발생하는 메시지이다. -WinMain()의 메시지 루프가 종료되고 프로그램이 끝난다.</p>
</li>
</ol>
<h1 id="텍스트-출력" style="position:relative;"><a href="#%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%B6%9C%EB%A0%A5" aria-label="텍스트 출력 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>텍스트 출력</h1>
<ul>
<li>WM_PAINT()</li>
</ul>
<ul>
<li>UpdateWindow() 메시지는 클라이언트 영역을 다시 그려야 함을 윈도우 프로시저에 알린다.</li>
</ul>
<ul>
<li>
<p>윈도우 프로시저는 다음과 같은 이벤트 중 하나가 발생하면 WM_PAINT 메시지를 처리한다.</p>
<ul>
<li>
<p>사용자가 윈도우를 이동하거나 드러냄으로써 이전에 가려진 윈도우 영역이 드러날때.</p>
</li>
<li>
<p>사용자가 윈도우의 크기를 조정할 때(윈도우 클래스 스타일에 CS_HREDRAW, CS_VREDRAW 비트 설정했을 때)</p>
</li>
<li>
<p>프로그램에서 ScrollWindow() 또는 ScrollDC()를 사용하여 클라이언트 영역의 일부를 스크롤할 때</p>
</li>
<li>
<p>프로그램에서 InvalidateRect() 또는 InvalidateRgn()을 사용하여 명시적으로 WM_PAINT 메시지를 생성할 때</p>
</li>
</ul>
</li>
<li>
<p>WM_PAINT 메시지를 큐에 넣는경우</p>
<ul>
<li>
<p>윈도우 위에 놓여 있는 대화상자나 메시지 상자를 윈도우즈가 제거할 때</p>
</li>
<li>
<p>메뉴가 열렸다가 닫혔을 때</p>
</li>
<li>
<p>툴 팁(tool tip)이 표시될 때</p>
</li>
</ul>
</li>
<li>
<p>GDI 개요</p>
</li>
</ul>
<ul>
<li>윈도우의 클라이언트 영역에 무언가를 그리기 위해서는 윈도우즈의 그래픽 장치 인터페이스(Graphics Device Interface,GDI) 함수사용</li>
</ul>
<ul>
<li>디바이스 컨텍스트</li>
</ul>
<ul>
<li>
<p>디바이스 컨텍스트 핸들은 윈도우가 GDI 함수를 사용하기 위한 일종의 허가증이라고 할 수 있다.</p>
</li>
<li>
<p>CreateDC() 호출로 생성한 디바이스 컨텍스트를 제외하고는, 메시지 한 개를 처리할 때 얻은 디바이스 컨텍스트 핸들을 저장해</p>
<p>두었다가 다른 메시지를 처리할 때 사용해서는 안된다.</p>
</li>
</ul>
<ul>
<li>디바이스 컨텍스트 핸들 얻기: 1번째 방법</li>
</ul>
<ul>
<li>
<p>BeginPaint(), EndPaint()</p>
<ol>
<li>
<p>BeginPaint는 무효 영역의 배경을 지움으로써, 그리기 위한 준비를 한다. Return 값은 디바이스 컨텍스트 핸들이다.</p>
</li>
<li>
<p>WM_PAINT 메시지를 처리하는 동안 반드시 BeginPaint(), EndPaint()를 쌍으로 호출해야함.</p>
</li>
</ol>
</li>
<li>
<p>WM_PAINT(), 메시지를 처리하지 않는 경우 메시지를 DdfWindowProc()에 전달해야함.</p>
</li>
</ul>
<p>case WM_PAINT:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> BeginPaint(hwnd, &amp;ps);

 EndPaint(hwnd, &amp;ps);

 return 0;</code></pre></div>
<ul>
<li>
<p>InvalidateRect() 호출함으로써 클라이언트 영역의 직사각형을 무효화한다면, 마지막 인자로 배경을 지울지 여부를 지정함.</p>
<p>TRUE : 배경을 지움 / 배경을 지움, FALSE : 배경을 지우지 않음</p>
</li>
</ul>
<ul>
<li>
<p>디바이스 컨텍스트 핸들 얻기 : 2번째 방법</p>
<ul>
<li>
<p>GetDC(), ReleaseDC()</p>
<ol>
<li>
<p>GetDC(), RelaseDC()도 쌍으로 호출해야 한다. 메시지를 처리하는 동안 GetDC() 호출된다면 윈도우 프로시저 탈출하기 전에</p>
<p>반드시 ReleaseDC()를 호출해야한다.</p>
</li>
</ol>
</li>
</ul>
<p>hdc = GetDC(hwnd);</p>
<p>ReleaseDC(hwnd, hdc);</p>
</li>
</ul>
<ul>
<li>
<p>GetDC(), GetWindowDC() 차이점</p>
<p>● GetDC()는 윈도우 클라이언트 영역에 출력할 수 있는 /GetWindowDC() 윈도우 전체에 출력할 수 있는</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                디바이스 컨텍스트 리턴                               디바이스 컨텍스트 핸들 리턴 - 윈도우타이틀바 출력가능</code></pre></div>
</li>
</ul>
<ul>
<li>
<p>BeginPaint(), EndPaint() / GetDC(), ReleaseDC() 차이점</p>
<ol>
<li>
<p>BeginPaint, EndPaint는 WM_Paint 메시지를 처리할 때 사용한다. / GetDC, ReleaseDC는 WM_Paint 메시지 이외의 처리</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                                                                       클라이언트 영역 일부를 그릴 때</code></pre></div>
</li>
<li>
<p>WM_PAINT 메시지 루틴에서만 사용 : BeginPaint, EndPaint / DC핸들 얻기 위한 일반적인 방법 : GetDC, ReleaseDC</p>
<p>( 메시지 내에서 그림 그리기 위한 전문적인 함수)</p>
</li>
<li>
<p>BeginPaint, EndPaint 호출하면 무효영역-유효화 됨 / GetDC, ReleaseDC는 무효 영역을 유효화하지 않음</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                                                        하려면 ValidateRect(hwnd, NULL) 호출해서 영역전체 유효화</code></pre></div>
</li>
<li>
<p>BeginPaint, EndPaint 얻은 디바이스 컨텍스트 핸들의 / GetDC로 얻은 디바이스 컨텍스트 핸들의 디폴트 클리핑 영역은</p>
<p>디폴트 클리핑 영역은 무효영역 클라이언트 영역이다.</p>
</li>
</ol>
<ul>
<li>클리핑 영역 : 화면에 보이는 가시영역</li>
</ul>
</li>
<li>
<p>TextOut() 세부사항&#x3C;TextOut(hdc, 100, 100, TEXT(“HI”), 2);</p>
<ol>
<li>
<p>첫번째 인자는 GetDC(), BeginPaint()의 호출하여 얻은 리턴값</p>
</li>
<li>
<p>2~3번째는 문자열이 출력될 좌표, 4번째는 문자열, 5번째는 문자열의 길이 -TextOut 함수는 널 종료문자열을 사용하지 않음.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                                                                              아스키제어(\n, \0등) 사용시 상자나 채워진 블록모양출력</code></pre></div>
</li>
</ol>
</li>
<li>
<p>문자 정렬방법 - SetTextAlign(HDC hdc, UINT fMode) : 예) SetTextAlign(hdc, TA_CENTER);</p>
</li>
<li>
<p>글자크기</p>
</li>
</ul>
<ul>
<li>
<p>텍스트의 치수를 알아내려면, 디바이스 컨텍스트 핸들을 얻은 후 GetTextMetrics() 호출한다.</p>
<p>TEXTMETRIC tm;</p>
<p>hdc = GetDC(hwnd);</p>
<p>GetTextMetrics(hdc, &#x26;tm);</p>
<p>ReleaseDC(hwnd, hdc);</p>
</li>
<li>
<p>TEXTMETRIC 구조체는 디바이스 컨텍스트에 현재 선택된 포트에 관한 다양한 정보를 제공한다.</p>
</li>
<li>
<p>시스템 폰트의 치수는 윈도우즈를 다시 부팅되기 전까지는 변하지 않으므로, GetTextMetrics 사용 위치는 윈도우</p>
<p>프로시저에서 WM_CREATE 메시지를 처리할 때 사용하는게 가장 좋은 위치이다.</p>
</li>
</ul>
<ul>
<li>GetSystemMetrics</li>
</ul>
<p>Windows 응용 프로그램 프로그래밍 인터페이스 (API) 함수 GetSystemMetrics()를 사용 하 여 너비 및 높이 창 디스플레이의 다양한 요소의 얻을 수 있습니다.</p>
<p>예) int x = GetSystemMetrics(SM_CXSCREEN); Width of screen
int y = GetSystemMetrics(SM_CYSCREEN); Height of screen</p>
<ul>
<li>클라이언트 영역 크기</li>
</ul>
<ul>
<li>
<p>GetSystemMetrics(), GetClientRect(), WM_SIZE에 lParam이용</p>
</li>
<li>
<p>WM_SIZE : 윈도우의 크기가 변경될때 윈도우 프로시저에 WM_SIZE 메시지를 보낸다.</p>
<p>cxClient = LOWORD(lParam);</p>
<p>cyClient = HIWORD(lParam);</p>
</li>
</ul>
<ul>
<li>스크롤 바</li>
</ul>
<ul>
<li>
<p>윈도우 스타일 식별자인 WS_VSCROLL, WS_HSCROLL 을 CreateWindow() 세번째 인자에 포함시키면 생성됨.</p>
</li>
<li>
<p>스크롤바가 차지하는 공간은 클라이언트 영역에 포함안됨</p>
</li>
<li>
<p>수직 스크롤바의 폭, 수평 스크롤바의 높이는 GetSystemMetrics 호출로 가능하다.</p>
</li>
<li>
<p>SetScrollRange : 스크롤 바의 범위, setScrollPos : 스크롤 바의 위치</p>
</li>
</ul>
<h1 id="그리기-기초" style="position:relative;"><a href="#%EA%B7%B8%EB%A6%AC%EA%B8%B0-%EA%B8%B0%EC%B4%88" aria-label="그리기 기초 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>그리기 기초</h1>
<ul>
<li>GDI(Graphics Device Interface) : 비디오 디스플레이와 프린터에 그래픽을 표시하는 역할을 하는 서브시스템</li>
</ul>
<ul>
<li>윈도우즈의 그래픽은 GDI32.DLL 이 외부에 공개하는 함수에 의해 주로 처리한다.</li>
</ul>
<ul>
<li>
<p>GDI 함수 호출</p>
<ul>
<li>
<p>디바이스 컨텍스트 핸들</p>
<ol>
<li>WM_PAINT 메시지 처리 : BeginPaint, EndPaint / 그 외는 GetDC,ReleaseDC</li>
</ol>
</li>
<li>
<p>GetTextMetrics : 현재 선택된 폰트의 치수 정보를 얻기 위해서</p>
</li>
<li>
<p>TextOut : 클라이언트 영역에 텍스트를 표시 / 텍스트 색상 변경 : SetTextColor</p>
</li>
<li>
<p>SetTextAlign : 텍스트 시작 위치 정렬</p>
</li>
<li>
<p>CreatePen, CreatePenIndirect, ExtCreatePen : 펜의 여러 속성 지정함.</p>
</li>
</ul>
</li>
<li>
<p>디바이스 컨텍스트</p>
<ul>
<li>
<p>프로그램이 DC를 얻는다는 것은 장치를 사용할 수 있도록 윈도우즈가 허가한다는 뜻이다.</p>
</li>
<li>
<p>디바이스 컨텍스트는 많은 속성들을 포함하고 있어서 TextOut 호출시 속성 관련 세팅을 하지 않아도 DC에 속성을 따르게 되는 것이다.</p>
<p>변경하고 싶으면 속성 변경하는 함수를 호출하면 된다.</p>
</li>
</ul>
</li>
<li>
<p>디바이스 컨텍스트 핸들 얻기</p>
<ol>
<li>비디오 디스플레이의 특정 윈도우와 연관된 디바이스 컨텍스트를 얻기 위해사용(BeginPaint, GetDC, GetWindowDC)</li>
</ol>
<ul>
<li>
<p>BeginPaint,EndPant에 PAINTSTRUCT 구조체에 3번째 인자 rcPaint 필드가 있어서 윈도우 클라이언트 영역에서 무효 영역을</p>
<p>둘러싸는 직사각형을 정의함.</p>
</li>
<li>
<p>GetDC, ReleaseDC() : 윈도우 클라이언트 영역에 적용</p>
</li>
<li>
<p>GetWindowDC, ReleaseDC : 윈도우 전체에 적용되는 디바이스 컨텍스트 핸들을 얻을 수 있다.</p>
<p>이 디바이스컨텍스는 클라이언트 영역,윈도우 타이틀바, 메뉴, 스크롤바, 프레임을 포함.</p>
</li>
</ul>
<ol start="2">
<li>디바이스 컨텍스트 핸들을 얻기 위한 다른 방법</li>
</ol>
</li>
</ul>
<ul>
<li>
<p>CreateDC() : 특정 장치에 대 한 장치 컨텍스트를 만듭니다.</p>
</li>
<li>
<p>CreateIC() : 특정 장치에 대한 정보 컨텍스트를 만듭니다.이 디바이스 컨텍스트를 만들지 않고 해당 장치에 대한 정보를 빠르게 제공</p>
</li>
<li>
<p>CreateCompatibleDC(hdc) : 다른 장치 컨텍스트와 호환되는 메모리 디바이스 컨텍스트를 만듭니다. 메모리에 이미지를 준비하기위해</p>
</li>
<li>
<p>CreateMetaFile : GDI 호출은 화면에 표시되지 않지만 메타피일의 일부로 저장된다.</p>
<p>-메타파일 : 다른 파일을 설명하거나 정의하는 정보를 담고 있는 파일(GDI 함수포함, 벡터방식 : 화면깨짐이 없다.)</p>
</li>
</ul>
<ul>
<li>
<p>디바이스 컨텍스트 정보 얻기</p>
<ul>
<li>
<p>GetDeviceCaps : 물리적 디스플레이 장치(비디오 디스플레이, 프린터 등)에 대한 정보를 얻을 때 쓰인다.</p>
<p>GetDeviceCap(hdc, iIndex) - hdc가 화면 디바이스 컨텍스트 핸들이면, GetSystemMetrics와 정보가 동일하다</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">iIndex - WINGDI.H 파일에 명시</code></pre></div>
<ol>
<li>
<p>GetDeviceCaps(hdc, HORZRES); GetDeviceCaps(hdc, VERTRES);</p>
</li>
<li>
<p>GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN) 인자 사용시 동일하다.</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>색상에 대해서 알아보기</p>
</li>
</ul>
<ul>
<li>
<p>GetDeviceCaps을 사용하면 장치가 다양한 종류의 그래픽을 처리할 수 있는 능력이 있는지 여부를 결정할 수 있다.</p>
<ul>
<li>
<p>GetDeviceCaps(hdc, PLANES) : 색상 편면의 개수 / GetDeviceCaps(hdc, BITSPIXEL) : 픽셀당 색상 비트수</p>
<p>GetDeviceCaps(hdc, NUMCOLORS) : 비디오 카드에서 동시에 표시할 수 있는 색상 수</p>
</li>
</ul>
</li>
<li>
<p>COLORREF : GDI 함수 호출에서는 특정 색상을 참조할 때 사용함. #define DWORD COLORREF</p>
<p>COLORREF의 원색 값을 추출 할때 GetRValue, GetGValue, GetBValue 매크로를 사용</p>
</li>
<li>
<p>GetNearestColor - 디더링(혼합)을 사용함으로써 실제 장치가 표시할 수 있는 색상보다 많은 색상을 표현함.</p>
</li>
</ul>
<ul>
<li>
<p>디바이스 컨텍스트 속성</p>
<ul>
<li>
<p>윈도우즈는 디바이스 컨텍스트를 사용하여 ‘속성’을 저장함으로써 GDI 함수가 화면에 작동하는 방식을 좌우한다.</p>
</li>
<li>
<p>프로그램이 디바이스 컨텍스트를 얻으면, 윈도우즈는 모든 속성을 디폴트 값으로 설정함.</p>
</li>
</ul>
</li>
<li>
<p>디바이스 컨텍스트 저장하기</p>
<ul>
<li>
<p>GetDC(), BeginPaint() 호출 -모든 속성을 디폴트로 설정한 DC 리턴</p>
</li>
<li>
<p>ReleaseDC(), EndPaint() 호출 -DC해제, 수정한 모든 속성값은 사라짐</p>
</li>
<li>
<p>속성값을 미리 변경 : 윈도우 클래스 등록때 스타일로 포함시킴</p>
</li>
<li>
<p>SaveDC, RestoreDC : DC 속성 변경 후 다시 그전 DC 상태로 변경시 사용함.</p>
<p>idSaved = SaveDC(hdc); // SaveDC(hdc);</p>
<p>RestoreDC(hdc, idSaved); // 리턴값 저장 시 // RestoreDC(hdc, -1); // 가장 최근에 SaveDC() 저장한 상태로 DC 복원</p>
</li>
</ul>
</li>
<li>
<p>직선</p>
</li>
</ul>
<ul>
<li>
<p>Polyline(), PolylineTo() 일련의 연결된 직선을 그린다.</p>
<p>Polyline, PolylineTo 다른점</p>
<ol>
<li>
<p>Polyline은 현재 위치를 사용하지도 변경하지도 않는다.</p>
</li>
<li>
<p>PolylineTo : 현재 위치를 시작 위치로 사용하고 마지막으로 그린 선의 끝점으로 현재 위치를 이동시킨다.</p>
</li>
</ol>
<p>Polyline, LineTo</p>
<p>LineTo를 여러번 호출하면 플로터나 혹은 다른 그리기 모드에서 출력 결과가 보기 좋게 안나오고, 또한 Polyline을 이용시 쉽게 선을</p>
<p>그릴 수 있다.</p>
</li>
<li>
<p>MoveToEx(hdc, xBeg, yBeg, NULL) : DC에 속성 중 현재 위치 값을 설정함. 마지막 인자는 이전의 현재 위치값을 POINT로 담아둔다.</p>
</li>
<li>
<p>LineTo(hdc, xEnd, yEnd); 현재 위치에서 이낮로 지정한 점까지 직선을 그린다.</p>
</li>
<li>
<p>GetCurrnetPositionEx(hdc, &#x26;pt) : 현재 위치 값을 구해줌.(MoveTo로 현재의 위치를 변경가능)</p>
</li>
</ul>
<ul>
<li>경계 상자 함수 : 직사각형 형태의 “경계 상자”로부터 만들어진다는 점</li>
</ul>
<ul>
<li>
<p>Rectangle() 직사각형을 그리는 것</p>
</li>
<li>
<p>Ellipse() : 타원을 그리는 함수</p>
</li>
<li>
<p>RoundRect() : 모서리가 둥근 직사각형</p>
</li>
<li>
<p>Arc : 호는 채워진 영역이 아니라 타워 곡선, Pie : 윈도우즈는 호의 양 끝점과 타원의 중심을 선으로 연결한다.</p>
</li>
<li>
<p>Chord, Pie로 그린 그리믜 내부에 현재 브러시로 채워진다.</p>
</li>
</ul>
<ul>
<li>곡선</li>
</ul>
<ul>
<li>
<p>Bezier(HDC hdc, CONST POINT* lppt, DWORD cPoints);</p>
</li>
<li>
<p>곡선의 시작점과 끝점 그리고 두 개의 조절점으로 구성된 배열을 두 번째 인수로 넘겨주고 세번째 인수 cPoints에 점의 개수를 주면</p>
<p>곡선이 그려진다.</p>
</li>
<li>
<p>곡선하나를 그리는데는 4개의 점이 필요하지만 두 개 이상의 곡선을 그릴때는 다음 공식만큼의 점이 필요하다.</p>
<p>=필요한 점 = 그려질 곡선 수*3 +1</p>
</li>
</ul>
<ul>
<li>내장 펜 사용하기</li>
</ul>
<ul>
<li>
<p>내장 펜 중 하나에 대한 핸들을 얻으려면 GetStockObject()를 호출한다.</p>
<p>hPen = GetStockObject(WHITE_PEN);</p>
</li>
<li>
<p>디바이스 컨텍스트에 펜을 선택해야한다.</p>
</li>
</ul>
<p>hPen(이전 디바이스컨텍스트) = SelectObject(hdc, hPen);</p>
<p>=한 문자으로 요약가능 SelectObject(hdc, GetStockObject(WHITE_PEN))</p>
<ul>
<li>펜 생성, 선택, 삭제</li>
</ul>
<ul>
<li>펜과 같은 GDI 객체를 사용할 때는 세 가지 규칙을 지켜야 한다.</li>
</ul>
<ol>
<li>
<p>생성한 모든 GDI 객체는 결국 삭제해야한다.</p>
</li>
<li>
<p>유효한 디바이스 컨텍스트에 선택되어 있는 GDI 객체는 삭제해서는 안된다.</p>
</li>
</ol>
<p>CreatePen - // hPen = SelectObject // SelectObject(hdc, hPen) // DeleteObject</p>
<ol start="3">
<li>내장 객체는 삭제해서는 안되다.</li>
</ol>
<ul>
<li>
<p>펜 생성(CreatePen, SelectObject, DeleteObject)</p>
</li>
<li>
<p>CreatePen, CreatePenIndirect (논리펜 생성)</p>
</li>
</ul>
<ol>
<li>CreatePenIndirect에서 서로 다른 펜을 직접 초기화하여 사용할 경우 더욱 효과적이다.(LOGPEN 구조체를 이용)</li>
</ol>
<ul>
<li>LOGPEN 구조체 값을 얻어올 수 있다.</li>
</ul>
<ol>
<li>GetObject(hPen, sizeof(LOGPEN), (LPVOID)&#x26;logpen);</li>
</ol>
<ul>
<li>현재 선택된 펜 핸들이 필요하다면 다음과 같이 호출하면 된다.</li>
</ul>
<ol>
<li>hPen = GetCurrentObject(hdc, OBJ_PEN);</li>
</ol>
<ul>
<li>틈새 채우기</li>
</ul>
<ul>
<li>
<p>SetBkColor(hdc, crColor) // GetBKMode : 배경 모드를 얻을때 쓰임</p>
<p>틈새를 채우기 위해서 배경색상을 바꿀때 사용함. 배경모드를 TRANSPARENT로 변경시 틈색을 채우지 않고 또한 배경색상을 무시한다.</p>
</li>
</ul>
<ul>
<li>
<p>그리기 모드</p>
<ul>
<li>
<p>윈도우즈가 선을 그리기 위해 펜을 사용할 때는 실제로 펜의 픽셀과 목적지 화면의 픽셀 사이에 비트별 Boolean 연산을수행함.</p>
<p>여기서 픽셀은 펜과 하면의 색상을 결정함. 픽셀에 대해 비트별 부울 연산을 수행하는 것을 ‘래스트 연산’ 혹은 ‘ROP’라 한다.</p>
</li>
</ul>
</li>
<li>
<p>채워진 영역에 그리기</p>
</li>
</ul>
<ul>
<li>
<p>윈도우즈는 여섯개의 내장 브러시를 정의함(WHITE_BRUSH,BLACK_BRUSH,NULL_BRUSH,LTGRAY_BRUSH,DKGRAY_BRUSH,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                                       GRAY_BRUSH)</code></pre></div>
</li>
<li>
<p>윈도우즈 브러시 핸들 : HBRUSH</p>
<ol>
<li>
<p>HBRUSH hBrush = GetStockObject(GRAY_BRUSH); //핸들을 얻을 수 있다.</p>
</li>
<li>
<p>SelectObject(hdc, hBrush) // 디바이스 컨텍스트 선택</p>
</li>
<li>
<p>SelectObject(hdc, GetStockObject(NULL_PEN)) // 경계가 없는 그림</p>
</li>
<li>
<p>SelectObject(hdc, GetStockObject(NULL_BRUSH)) // 그림 경계 or 내부 채우지 않으려면</p>
</li>
</ol>
</li>
</ul>
<ul>
<li>다각형 함수와 다각형 채우기 모드</li>
</ul>
<ul>
<li>
<p>Polygon(hdc, apt, iCount) : 경계가 있고 내부가 채워진 그림을 그리는 여섯번째 함수</p>
</li>
<li>
<p>PolyPolygon(hdc, apt, aiCounts, iPolycount)은 여러개의 다각형을 그린다.</p>
<ol>
<li>내부를 채우는 방식 : SetPolyFillMode(hdc, iMode) : iMode(ALTERNATE, WINDING)</li>
</ol>
</li>
</ul>
<ul>
<li>
<p>브러시로 내부 채우기</p>
<ul>
<li>
<p>윈도우즈는 논리 브러시 만들 수 있게 다섯개의 함수 제공</p>
<ol>
<li>
<p>CreateSolidBrush(COLORREF) : 특별한 Solid Color를 가지는 논리 브러시를 만들어준다.</p>
</li>
<li>
<p>CreateHatchBrush(fnStyle, COLORREF) : 특별한 Hatch Pattern과 생상을 가지는 논리 브러시를 만들어준다.</p>
</li>
<li>
<p>CreatePatternBrush(HBITMAP) : 특정 비트맵 패턴을 가지는 논리 브러시를 만들어준다.</p>
</li>
<li>
<p>CreateDIBPatternBrush(HGLOBAL, UINT) : 장치 독립적인 특정 비트맵을 가지는 논리 브러시를 만들어준다.</p>
</li>
<li>
<p>CreateBrushIndirect(LOGBRUSH) : 특별한 Hatch, Stype, Color 가지는 논리 브러시를 만들어준다ㅏ.</p>
</li>
</ol>
</li>
</ul>
<p>typedef struct tagLOGBRUSH
{
UINT lbStyle;
COLORREF lbColor;
LONG lbHatch;
} LOGBRUSH, *PLOGBRUSH, NEAR *NPLOGBRUSH, FAR *LPLOGBRUSH;</p>
</li>
</ul>
<ol>
<li>SelectObject() : 디바이스 컨텍스트 선택</li>
</ol>
<ul>
<li>
<p>장치 좌표계</p>
<ul>
<li>
<p>모든 장치 좌표계에서 단위는 픽셀로 표현한다.</p>
</li>
<li>
<p>화면 좌표 : 전체 화면을 사용한다면 화면 좌표를 사용함.</p>
<p>CreateDC() “DISPLAY” 인자를 사용한다면 GDI 함수의 논리 좌표는 디폴트로 화면 좌표에 매핑됨</p>
</li>
<li>
<p>전체윈도우좌표 : 타이틀바, 스크롤바, 테두리 등을 포함한 프로그램의 애플리케이션 윈도우 전체를 나타낸다.</p>
<p>GetWindowDC() 디바이스 컨텍스트를 얻으면 GDI 함수의 논리 좌표가 전체 윈도우 좌표에 매핑됨</p>
</li>
<li>
<p>장치 좌표계 : 클라이언트 영역 좌표 // GetDC(), BeginPaint() 디바이스 컨텍스트를 얻으면 클라이언트 좌표로 변환됨</p>
</li>
<li>
<p>ClientToScreen() : 클라이언트 영역 좌표 -화면좌표 // ScreenToClient() : 화면좌표 -클라이언트 영역 좌표</p>
</li>
</ul>
</li>
<li>
<p>뷰포트와 윈도우</p>
</li>
</ul>
<ul>
<li>
<p>매핑모드 : 윈도우(논리좌표)에서 뷰포트(장치좌표)로의 매핑을 정의</p>
</li>
<li>
<p>뷰포트 지정 : 장치 좌표(Pixel) 사용한다.</p>
</li>
<li>
<p>윈도우 지정 : 논리 좌표(피셀, 밀리미터, 인치등) 사용한다.</p>
</li>
<li>
<p>장치점을 논리점으로 변환 - 논리점을 장치점으로 변환</p>
<p>DPtoLP(hdc, pPoint, iNumber); LPtoDP(hdc, pPoint, iNumber)</p>
<p>GetClientRect(hwnd, &#x26;rect);</p>
<p>DPtoLP(hdc, (PPOINT)&#x26;rect, 2);</p>
</li>
<li>
<p>SetViewportOrgEx(hdc, xViewOrg, yViewOrg, NULL) 바꾸면 논리점(0, 0)은 장치점(xViewOrg, yViewOrg)에 매핑된다.</p>
<p>SetWindowOrgEx(hdc, xWinOrg, yWinOrg, NULL) 바꾸면 논리점(xWinOrg, yWinOrg)는 장치점(0,0) 매핑된다.</p>
<p>GetViewportOrgEx(hdc, &#x26;pt); / GetWindowOrgEx(hdc, &#x26;pt) // 현재의 뷰포트와 윈도우 원점을 얻을 수 있다.</p>
</li>
</ul>
<ul>
<li>
<p>메트릭 매핑 모드</p>
<ul>
<li>
<p>윈도우는 논리 좌표를 물리적 치수로 표현(다섯개의 매핑모드 제공)</p>
<ol>
<li>MM_LOENGLISH/MM_LOMETRIC/MM_HIENGLISH/MM_TWIPS/MM_HIMETRIC</li>
</ol>
</li>
</ul>
</li>
<li>
<p>사용자 정의 매핑모드</p>
<ul>
<li>MM_ISOTROPIC과 MM_ANISOTROPIC은 뷰포트 범위와 윈도우 범위를 변경할 수 있는 유일한 매핑 모드이다.</li>
</ul>
</li>
<li>
<p>직사각형, 리전, 클리핑</p>
</li>
</ul>
<ul>
<li>
<p>직사각형 작업하기</p>
<ol>
<li>
<p>FillRect(hdc, &#x26;rect, hBrush) : 지정한 브러시로 직사각형을 채운다.</p>
</li>
<li>
<p>FrameRect(hdc, &#x26;rect, hBrush) : 브러시를 이용하여 직사각형 프레임을 그리지만, 내부를 채우지 않는다.</p>
</li>
<li>
<p>InvertRect(hdc, &#x26;rect) : 직사각형 내의 모든 픽셀을 반전시킨다.(1->0 , 0->1)</p>
</li>
</ol>
</li>
<li>
<p>Rect 구조체 조작할 수 있는 9개의 함수 제공</p>
<ol>
<li>
<p>SetRect(&#x26;rect, xLeft, xTop, xRight, Bottom) : Rect 구조체의 네 개의 필드를 특정 값으로 설정해줌</p>
</li>
<li>
<p>OffsetRect(&#x26;rect, x, y) : x,y축 따라 일정 단위만큼 이동시킨다.</p>
</li>
<li>
<p>InflateRect((&#x26;rect, x, y) : 직사각형의 크기를 증가 혹은 감소시킨다.</p>
</li>
<li>
<p>SetRectEmpty(&#x26;rect) : 직사각형의 모든 필드를 0으로 설정한다.</p>
</li>
<li>
<p>CopyRect(&#x26;DestRect, &#x26;SrcRect) : 한 직사각형을 또다른 직사각형에 복사한다.</p>
</li>
<li>
<p>IntersectRect(&#x26;DestRect, &#x26;SrcRect1, &#x26;SrcRect2) : 두 직사각형의 교집합</p>
</li>
<li>
<p>UnionRect(&#x26;DestRect, &#x26;SrcRect1, &#x26;SrcRect2) : 두 직사각형의 합집합</p>
</li>
<li>
<p>bEmtyp = IsRectEmpty(&#x26;rect) : 직사각형이 비어 있는지 알려줌</p>
</li>
<li>
<p>bInRect = PtInRect(&#x26;rect, point) : 점이 직사각형 내에 있는지 알려줌</p>
</li>
</ol>
</li>
</ul>
<ul>
<li>리전 생성과 그리기</li>
</ul>
<ul>
<li>
<p>리전 : 사각형, 타원형, 다각형 등의 각종 도형으로 구성된 영역</p>
</li>
<li>
<p>CreateRectRgn(xLeft, yTop, xRight, yBottom) or CreateRectRgnIndirect(&#x26;rect); // 리전은 직사각형을 기술한다.</p>
</li>
<li>
<p>CreateEllipticRgn(xLeft, yTop, xRight, yBottom) or CreateEllipticRgnIndirect(&#x26;rect); // 타워형 리전</p>
</li>
<li>
<p>CreatePolyonRgn(&#x26;point, iCount, iPolyFillMode) iPolyFillMode : ALTERNATE or WINDING</p>
</li>
<li>
<p>CreatePolyPolygonRgn() 사용하면 여러개의 다각형으로 구성된 리전을 만들 수 있다.</p>
</li>
<li>
<p>CombineRgn(hDestRgn, hSrcRgn1, hSrcRgn2, iCombine)</p>
<p>hSrcRgn1, hSrcRgn2 두 개의 리전을 합쳐 새로운 리전 hDestRgn을 만든다. iCombine은 결합방법을 지정한다.</p>
<p>리턴값은 4개로 나뉘며(NULLREGION:비어있다/SIMPLEREGION:하나의 사각형으로 구성된 리전</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                            /COMPLEXREGION:복수 개의 사각형 또는 곡선으로 구성된 리전/ERROR : 에러 발생)</code></pre></div>
</li>
</ul>
<ul>
<li>
<p>리전 핸들로 FillRgn, FramRgn, InvertRgn, PaintRgn 쓰이게 된다.</p>
</li>
<li>
<p>직사각형과 리전으로 클리핑하기</p>
<ul>
<li>
<p>invalidateRgn(hwnd, hRgn, bErase) : 클라이언트 리전 영역을 무효화시킨다.</p>
<p>validateRgn(hwnd, hRgn) : 클라이언트 리전 영역을 유효화시킨다.</p>
</li>
</ul>
</li>
</ul>
<h1 id="키보드" style="position:relative;"><a href="#%ED%82%A4%EB%B3%B4%EB%93%9C" aria-label="키보드 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>키보드</h1>
<ul>
<li>키보드 기초</li>
</ul>
<ul>
<li>
<p>키보드 입력은 메시지 형태로 프로그램의 윈도우 프로시저에 전달된다.</p>
</li>
<li>
<p>특정 키보드 이벤트는 입력 포커스를 가진 윈도우를 받는다.(입력 포커스를 가진 윈도우에 키 이벤트가 전달됨)</p>
</li>
<li>
<p>활성윈도우가 자식윈도우(리스트박스, 체크박스등) 가지고 있다면 자식 윈도우가 입력포커스를 가진다.</p>
<p>자식윈도우가 활성윈도우는 아니라는 사실을 명심해야한다.</p>
</li>
</ul>
<p>* 큐의 동기화</p>
<p>사용자가 키를 누르고 뗄 경우 -하드웨어 스캔 코드(디바이스드라이버) -시스템 메시지 큐 -애플리케이션 메시지 큐</p>
<ul>
<li>
<p>시스템 메시지 큐 -애플리케이션 메시지 큐</p>
<p>윈도우의 포커스가 변경될 경우 시스템 메시지큐에 메시지를 다른 윈도우에 전달하기 위해서</p>
</li>
</ul>
<p>* 키누름 메시지</p>
<ul>
<li>
<p>WM_KEYDOWN, WM_KEYUP</p>
</li>
<li>
<p>WM_SYSKEYDOWN, WM_SYSKEYUP : Alt 키와 함께 눌러지는 키보드 메시지, 시스템의 내부적인 용도로 사용할 때 쓰임</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                                    이 메시지를 처리할 경우 반드시 DefWindowProc으로 이 메시지를 보내야 한다.</code></pre></div>
</li>
<li>
<p>GetMessageTime()을 호출하면 키를 누르거나 뗐을 때의 상대적인 시간을 얻을 수 있다.</p>
</li>
</ul>
<ul>
<li>가상 키 코드(wParam 확인)</li>
</ul>
<ul>
<li>
<p>가상 키 코드는 wParam 매개변수에 저장되어 있다.</p>
</li>
<li>
<p>WINUSER.H에 VK_로 시작하는 이름으로 정의되어 있음.</p>
</li>
</ul>
<ul>
<li>lParam 정보(WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, WM_SYSKEYUP)</li>
</ul>
<ul>
<li>키누름을 해석하는데 유용한 부가 정보가 들어감.</li>
</ul>
<ol>
<li>
<p>반복카운트(0~15 : 16비트) : 키누름 메시지가 나타내는 키누름의 개수다.</p>
</li>
<li>
<p>OEM 스캔코드(16~23 : 8비트) : 키보드 하드웨어가 발생시키는 코드</p>
</li>
<li>
<p>확장키 플래그(24) : IBM 확장 키보드에 있는 추가적인 키에 누름이 발생했을 1로 세팅</p>
</li>
<li>
<p>컨텍스트코드(29) : Alt키가 눌려져 있으면 1로 세팅</p>
</li>
<li>
<p>이전키상태(30) : 키를 이전에 뗀 상태라면 0이고, 키를 이전에 누른 상태라면 1이다.(KeyUp은 항상 1로 세팅됨)</p>
</li>
<li>
<p>전환상태(31) : WM_KEYDOWN : 0, WM_KEYUP : 1(키를 누르면 0, 키를 떼는 중이면 1)</p>
</li>
</ol>
<ul>
<li>
<p>시프트상태(시프트키(Shift,Ctrl, Alt), 토클키(Caps Lock, NumLock) 눌렸는지 알기위해서)</p>
<ol>
<li>리턴값(GetKeyState, GetAsyncKeyState)</li>
</ol>
</li>
</ul>
<p>0x8000 은 현재 키가 눌려진 상태를 뜻하고, 0x0001은 지난번 호출과 이번 호출사이에 키가 눌려진 적이 있었다라는 것을 뜻한다.</p>
<p>예) if( GetAsyncKeyState(VK_RETURN) &#x26; 0x8000 ) // 하는 이유는 정확한 시점에서 키의 상태를 확인하기 위해서</p>
<ul>
<li>SHORT GetKeyState(int nVirtKey)</li>
</ul>
<ol>
<li>GetKeyState 함수의 리턴값이 0x8xxx 경우에는 해당키가 눌린 상태이고,0x8xxx가 아닐 경우는 해당키가 눌리지 않은 상태이다.</li>
</ol>
<ul>
<li>GetAsyncKeyState / GetKeyState 다른점</li>
</ul>
<ol>
<li>
<p>GetAsyncKeyState : 메시지큐와 상관없이 입력되는 순간 즉각적으로 읽어들여서 동작한다.</p>
<p>GetKeyState: 메시지큐에 저장된 메시지에 따라 반환되는 값이 다르다.</p>
</li>
<li>
<p>GetKeyState는 해당키가 눌렸으면 음수값(0xffffff80, oxffffff82) 아닐 경우 0을 반환, 이전에 누르고 호출시점에 안눌릴경우 1로 남는다.</p>
</li>
</ol>
<ul>
<li>문자메시지</li>
</ul>
<ol>
<li>
<p>GetMessage로 문자 메시지 - TranslateMesage : 키누름메시지(WM_KEYDOWN, WM_SYSKEYDOWN),</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                                                   Shift key(Shift, Ctrl, Alt), 토글키(Caps Lock, Num Lock, Scroll Lock)</code></pre></div>
<p>=메시지 큐에 WM_CHAR( 문자메시지를 넣게 된다)</p>
</li>
</ol>
<ul>
<li>네 개의 문자 메시지</li>
</ul>
<ul>
<li>
<p>WM_KEYDOWN -WM_CHAR, WM_DEADCHAR</p>
</li>
<li>
<p>WM_SYSKEYDOWN -WM_SYSCHAR, WM_SYSDEADCHAR</p>
</li>
<li>
<p>WM_CHAR : wParam, lParam 인자 설명</p>
<ol>
<li>
<p>wParam : TCHAR str = (TCHAR)wParam -ANSI or Unicode 문자코드</p>
</li>
<li>
<p>lParam : 키누름메시지(WM_KEYDOWN,WM_SYSKEYDOWN)의 lParam과 동일하다.</p>
</li>
</ol>
</li>
<li>
<p>fUnicode = IsWindowUnicode(hwnd) -fUnicode 변수가 TRUE(유니코드 메시지)</p>
</li>
<li>
<p>GetKeyNameText() : 키보드 메시지, 키누름 메시지에 대해 가상 키 코드와 키 이름을 보여줄때 사용함.</p>
</li>
</ul>
<ul>
<li>
<p>메시지순서</p>
<ul>
<li>
<p>문자메시지 : WM_KEYDOWN - WM_CHAR - WM_KEYUP</p>
<p>WM_KEYDOWN 메시지로부터 TranslateMessage 호출되므로 WM_CHAR 사이에 끼게 된다.</p>
</li>
</ul>
</li>
<li>
<p>제어 문자 처리</p>
</li>
</ul>
<ul>
<li>
<p>WM_KEYDOWN : Insert, Shift, Ctrl, Alt 읽어야 할 경우</p>
</li>
<li>
<p>WM_CHAR : 키보드 문자 입력을 읽어야 할 경우</p>
<p>Backspace, Tab, Escape, Enter : WM_CHAR 에서 미리 지정된 ANSI C 이스케이프로 구분해서 사용함.</p>
</li>
</ul>
<p>case WM_CHAR:</p>
<p>if(wParam == ‘\b’) // if(wParam == ‘\t’)</p>
<ul>
<li>
<p>데드문자 메시지</p>
<ul>
<li>
<p>데드키란 단독으로 문자를 구성할 수 없는 키이며, 이키에 의해 발생된 데드 문자는 다음에 입력되는 문자와 조합되어 하나의 문자를</p>
<p>만든다.</p>
</li>
</ul>
</li>
</ul>
<p>WM_KEYDOWN
WM_DEADCHAR
WM_KEYUP
WM_KEYDOWN
WM_CHAR
WM_KEYUP</p>
<ul>
<li>캐럿</li>
</ul>
<ul>
<li>
<p>프로그램에 텍스트를 입력할 때 일반적으로 작은 밑줄이나 수직 막대 혹은 상자가 나타나서 다음에 입력한 글자가 화면의 어느 위치에</p>
<p>나타날지 알려준다.</p>
<ol>
<li>커서 : 마우스 위치를 나타내는 작은 비트맵 이미지 - 캐럿과 다른 의미</li>
</ol>
</li>
<li>
<p>캐럿 관련 함수</p>
</li>
</ul>
<ol>
<li>
<p>BOOL CreateCaret(HWND, HBITMAP, nWidth, nHeight)</p>
</li>
<li>
<p>BOOL DestroyCatret(VOID)</p>
</li>
<li>
<p>BOOL ShowCaret(hwnd) // 주기적으로 계속 깜박이며 다음 삽입 위치를 기다린다.</p>
</li>
<li>
<p>BOOL HideCaret(hwnd)</p>
</li>
<li>
<p>BOOL SetCaretPos(int X, int Y) : 캐럿의 위치를 지정(캐럿의 숨겨져 있어도 위치 변경가능)</p>
</li>
<li>
<p>BOOL GetCaretPos(LPPOINT)</p>
</li>
</ol>
<h1 id="마우스" style="position:relative;"><a href="#%EB%A7%88%EC%9A%B0%EC%8A%A4" aria-label="마우스 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>마우스</h1>
<ul>
<li>마우스 기초</li>
</ul>
<ul>
<li>
<p>fMouse = GetSystemMetrics(SM_MOUSEPRESENT) : 마우스 존재 여부 검사(TRUE : 설치 O, FALSE : 설치 X)</p>
</li>
<li>
<p>cButtons = GetSystemMetrics(SM_CMOUSEBUTTONS) : 마우스의 버튼 수를 알려줌</p>
</li>
<li>
<p>SystemParametersInfo() : 더블 클릭 속도등 각종 마우스 파라미터를 직접 설정하거나 얻을 때 사용함.</p>
</li>
</ul>
<ul>
<li>클라이언트 영역 마우스 메시지</li>
</ul>
<ol>
<li>키보드 메시지, 마우스 메시지 다른점</li>
</ol>
<ul>
<li>
<p>키보드 메시지 : 입력 포커스(EditBox)를 가진 윈도우에게만 키보드 메시지를 보냄</p>
</li>
<li>
<p>마우스 메시지 : 윈도우 위, 활성 x, 입력포커스를 가지고 있지 않은 경우에도 윈도우 프로시저는 마우스 메시지를 받는다.</p>
</li>
</ul>
<ol start="2">
<li>마우스 위치값</li>
</ol>
<ul>
<li>x = LOWARD(lParam) / y = HIWARD(lParam)</li>
</ul>
<ol start="3">
<li>wParam : 마우스 버튼, Shift, Ctrl 키의 상태를 나타낸다.</li>
</ol>
<p>MK_CONTROL, MK_LBUTTON, MK_RBUTTON, MK_MBUTTON, MK_SHIFT 조합키 상태를 알려줌.</p>
<ul>
<li>
<p>알게된 내용</p>
<p>int ShowCursor(BOOL bShow);</p>
<p>리턴값은 내부 카운트값으로서 TRUE일 경우에는 내부 카운트가 증가하고, FALSE일경우에는 내부 카운트가 감소한다.</p>
<p>내부카운트가 0과 같거나 클 경우 화면에 커서가 보인다.</p>
</li>
</ul>
<p>GetCursorPos(&#x26;point) // point 값은 스크린 좌표값이다. 클라이언트로 영역으로 바꿀경우 ScreenToClient 함수를 써야함.</p>
<p>SetCursorPos(x, y) //x ,y 값도 클라이언트 좌표가 아닌 스크린 좌표값이다.(클라이언트 좌표값이면ClientToScreent 함수를 이용해야함</p>
<ul>
<li>
<p>마우스 더블클릭</p>
<ul>
<li>
<p>윈도우 프로시저가 더블 클릭 마우스 메시지를 받기 원한다면, RegisterClass()를 호출하기 전에 윈도우 클래스 구조체의 style 필드를</p>
<p>초기화 할때 CS_DBLCLKS 식별자를 포함한다.</p>
</li>
</ul>
</li>
<li>
<p>비클라이언트 영역 마우스 메시지</p>
<ul>
<li>
<p>윈도우 비클아이언트 영역 : 타이틀 바, 메뉴, 윈도우 스크롤 바를 포함한다.</p>
</li>
<li>
<p>비클라이언트 영역 마우스 메시지는 DefWindowProc()에 전달하여 윈도우즈가 시스템 기능 수행하게 함.</p>
<p>wParam : 마우스를 움직이거나 클릭한 곳이 비클라이언트 영역의 어느 부분인지 나타낸다.</p>
<p>lParam : 하위워드(x) , 상위워드(y) -클라이언트 좌표가 아닌 스크린 좌표이다.</p>
</li>
</ul>
<p>예) xPos = GET_X_LPARAM(lParam);
yPos = GET_Y_LPARAM(lParam);</p>
</li>
</ul>
<h1 id="타이머" style="position:relative;"><a href="#%ED%83%80%EC%9D%B4%EB%A8%B8" aria-label="타이머 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>타이머</h1>
<p>타이머 CH8.타이머 / Windows 프로그래밍<br>
2013. 4. 18. 20:33 수정 삭제
복사<a href="https://blog.naver.com/ssinga1030/90171478579" target="_blank" rel="nofollow">https://blog.naver.com/ssinga1030/90171478579</a>
통계보기</p>
<ul>
<li>
<p>윈도우즈 타이머의 활용</p>
<ol>
<li>
<p>멀티태스킹 : 많은 프로그램이 많은 양을 처리해야한다면, WM_TIMER 메시지를 받을 때마다 각 조각들을 처리가능</p>
</li>
<li>
<p>실시간 갱신 : 시스템 리소스 표시같은 끊임없이 변하는 정보를 타이머로 갱신한다.</p>
</li>
<li>
<p>자동저장 : 특정 주기에 맞게 사용자 작업을 저장한다.</p>
</li>
<li>
<p>‘데모’버전 프로그램 종료 : 데모버전 전달 후 일정시간이 지나서 종료하도록 설계한다.</p>
</li>
<li>
<p>움직임 속도 조절 : 자동으로 연속된 화면을 보여줄때 속도를 조절할 때.</p>
</li>
<li>
<p>백그라운드에서 작업중인 시각적인 정보를 갱신할 때 타이머를 사용</p>
</li>
</ol>
</li>
<li>
<p>시스템과 타이머</p>
</li>
</ul>
<ul>
<li>
<p>윈도우는 사용자가 설정한 타이머의 카운트 값을 설정하고 하드웨어 타이머 틱이 발생 될때마다 카운트를 감소 시킨 후 0이 되었을 때</p>
<p>WM_TIMER 메시지를 전달하고 다시 원래 카운트로 리셋한다.</p>
</li>
</ul>
<ul>
<li>타이머 메시지는 비동기적이지 않다.</li>
</ul>
<ul>
<li>
<p>자신의 프로그램이 WM_TIMER 메시지 처리를 위해 비동기적으로 중단되지 않는다.</p>
</li>
<li>
<p>WM_PAINT처럼 메시지 큐에 저장되어서 순차적으로 처리가 된다.</p>
</li>
</ul>
<ul>
<li>타이머 사용</li>
</ul>
<ol>
<li>첫번째 방법</li>
</ol>
<ul>
<li>
<p>SetTimer(hwnd, 1, uiMsecInterval, NULL);</p>
<p>1번째인자 : 윈도우 핸들, 2번째 인자 : 타이머의 번호, 3번째 인자 : 1/1000 타이머의 주기, 4번째 인자 : 콜백함수</p>
<p>KillTimer(hwnd, 1) : 1번째 인자 : 윈도우 핸들, 2번째 인자 : 타이머의 번호</p>
</li>
<li>
<p>WM_TIMER</p>
</li>
</ul>
<ol start="2">
<li>두번째 방법(콜백함수)</li>
</ol>
<ul>
<li>
<p>SetTimer(hwnd, 1, uiMsecInterval, TimerProc);</p>
</li>
<li>
<p>윈도우즈가 타이머 발생시 함수를 호출 할 수 있게 해주는 것이다.</p>
</li>
<li>
<p>VOID CALLBACK TimerProc( HWND hwnd, UINT message, UINT iTimerID, DWORD dwTime );</p>
</li>
</ul>
<p>1번째 인자 : 윈도우 핸들/ 2번째 인자 : 항상 WM_TIMER / 3번째 인자 : 타이머 ID/4번째 인자 : 윈도우즈가 시작후 경과된 시간</p>
<ol start="3">
<li>세번째 방법</li>
</ol>
<ul>
<li>
<p>iTimerID = SetTimer(NULL, 0, wMsecInterval, TimerProc);</p>
<p>1번째 매개변수 : hwnd 를 NULL/ 2번째 매개변수 무시한다(0) -함수의 리턴값이 타이머 ID가 된다.</p>
</li>
<li>
<p>KillTimer(NULL, iTimerID)</p>
</li>
</ul>
<ul>
<li>현재시각 얻기</li>
</ul>
<p>typedef struct _SYSTEMTIME { // st
WORD wYear;
WORD wMonth;
WORD wDayOfWeek;
WORD wDay;
WORD wHour;
WORD wMinute;
WORD wSecond;
WORD wMilliseconds;
} SYSTEMTIME;</p>
<ul>
<li>
<p>GetLocalTime(LPSYSTEMTIME) : 표준시간대를 알려준다.(현재시간)</p>
</li>
<li>
<p>GetSystemTime(LPSYSTEMTIME) : 협정세계시(그리니치 시각)</p>
</li>
</ul>
<h1 id="자식-윈도우-컨트롤" style="position:relative;"><a href="#%EC%9E%90%EC%8B%9D-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4" aria-label="자식 윈도우 컨트롤 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>자식 윈도우 컨트롤</h1>
<ul>
<li>
<p>자식 윈도우 컨트롤</p>
<ul>
<li>
<p>자식윈도우에서 부모윈도우 핸들을 얻는 방법</p>
<p>hwndParent = GetParent(hwnd)</p>
</li>
<li>
<p>부모윈도우에 메시지를 보내는 방법</p>
<p>SendMessage(hwndParent, message, wParam, lParam);</p>
</li>
<li>
<p>자신윈도우 -부모윈도우</p>
<p>자식윈도우(컨트롤) 자신에게 변화가 있을 경우(Button Click등) 부모 윈도우에게 WM_COMMNAD 통지 메시지를 보냄.</p>
<p>이 메시지는 자식윈도우(컨트롤)가 기동했음을 알려준다.</p>
<p>LOWORD(wParam) : 자식 윈도우 ID, HIWORD(wParam) : 알림코드, lParam : 자식윈도우의 핸들</p>
</li>
</ul>
</li>
<li>
<p>버튼 클래스</p>
<ul>
<li>
<p>오너드로우(Owner Draw)</p>
<p>비트맵이나 도형이미지를 가지는 경우에는 컨트롤이 직접 비트맵을 출력하지 못하여 이때 컨트롤을 소유한 부모 윈도우가 비트맵을</p>
<p>그려주는 방식을 오너드로우라고 말한다. 정리하면 컨트롤을 소유한 부모 윈도우가 내용물을 그려주는 형식을 말한다.</p>
</li>
<li>
<p>CreateWindow의 3번째 인자에 BS_OWNERDRAW 스타일을 추가하면 오너드로우 스타일을 적용하라는 의미이다.</p>
<ol>
<li>
<p>WM_MEASUREITEM : 항목의 높이를 지정</p>
</li>
<li>
<p>WM_DRAWITEM : 자신이 그려야 한다는 사실을 메시지를 통해서 알려준다.</p>
</li>
</ol>
<p>lPamra : DRAWTIEMSTRUCT 구조체의 포인터가 들어 있다.</p>
</li>
</ul>
</li>
<li>
<p>오너드로우 사용하는 이유</p>
<ol>
<li>
<p>리스트박스 자체는 또한 윈도우이다. 그러므로 문자열 추가시 WM_PAINT 호출되어서 출력이 되지만 그 외에 비트맵과 도형이미지</p>
<p>가지는 경우에는 직접 비트맵을 출력하지 못하므로 부모윈도우에서 대신 그려줘야하는 경우</p>
</li>
<li>
<p>실시간으로 변경되는 정보를 표시할 때 항목을 수정하는 것보다는 오너 드로우로 구현하는 것이 편리한 경우</p>
</li>
</ol>
</li>
<li>
<p>자식윈도우 생성하기</p>
</li>
</ul>
<p>CreateWindow { TEXT(“button), //클래스 이름</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">         TEXT("PUSHBUTTON);               // 윈도우 텍스트

                   WS_CHILD|WM_VISIBLE             // 윈도우 스타일

                   cxChar                                      // x위치

                   cyChar                                      // y위치

                   20*cxChar                                 // 폭

                   70*cyChar/4                             // 높이

                   hwnd                                       // 부모윈도우

                   (HMENU) i                                 // 자식윈도우 ID

                   ((LPCTREATESTRUCT) lParam)->hIstance  // 인스턴스 핸들

                   NULL                                        // 여분의 매개변수</code></pre></div>
<ul>
<li>
<p>인스턴스 핸들을 얻는 방법 3가지</p>
<ul>
<li>
<p>WM_CREATE시 :</p>
<p>lParam에 CREATESTRUCT 형식의 구조체에 대한 포인터가 들어 있다.</p>
</li>
<li>
<p>전역변수를 이용하는 방법</p>
<p>hInst = hInstance;</p>
</li>
<li>
<p>LONG GetWindowLong(hwnd, GWL_HINSTANCE);</p>
</li>
</ul>
</li>
<li>
<p>인스턴스 핸들(HINSTANCE), 윈도우 식별자(핸들 - HWND), 컨트롤 ID</p>
<ol>
<li>
<p>인스턴스 : 실행파일이 메모리상에 올라가 있는 시작주소를 의미한다.</p>
<p>-실행중인 프로그램들을 구분하기 위한 식별값으로 인스턴스 핸들을 이용한다.</p>
<p>-GetProcAddress 값이 다른 DLL에서 메모리에 올라간 함수주소를 얻을 경우 나오는 HMODULE과 동일하다.</p>
</li>
<li>
<p>윈도우 식별자 핸들(HWND)</p>
<p>-해당 프로그램의 윈도우들을 구분하기 위한 식별값을 말한다. (부모윈도우, 컨트롤 윈도우 핸들등)</p>
</li>
<li>
<p>컨트롤 ID</p>
<p>-컨트롤의 ID는 컨트롤간의 구분을 위해 사용하는 것이므로 한 부모 아래의 컨트롤끼리 중복되지 않는 ID를 가지기만 하면 된다</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> 내부적인 리소스로 관리됨.</code></pre></div>
</li>
</ol>
</li>
<li>
<p>ID값 얻는 방법</p>
<p>id = GetWindowLong(hwndChild, GWL_ID);</p>
<p>id = GetDlgCtrlID(hwndChild);</p>
</li>
<li>
<p>윈도우 핸들 얻는방법(ID와 부모윈도우 핸들을 안다면)</p>
</li>
</ul>
<p>hwndChild = GetDlgItem(hwndParent, id);</p>
<ul>
<li>자식 윈도우가 부모 윈도우에게 보내는 메시지(자식윈도우 생성시)</li>
</ul>
<ul>
<li>
<p>BN_CLICKED / BN_PAINT / BN_DISABLE 등</p>
</li>
<li>
<p>자식윈도우에서 부모윈도우에 WM_COMMAND호출(BN_CLICKED) - SendMessage(hwndButton, BM_SETSTATE, TRUE, 0)</p>
</li>
</ul>
<ul>
<li>부모 윈도우가 자식 윈도우에게 보내는 메시지</li>
</ul>
<ol>
<li>
<p>BM_GETCHECK, BM_SETCHECK</p>
<ul>
<li>체크박스와 라디오 단추의 체크표시를 설정하기 위해서 보낸다.</li>
</ul>
</li>
<li>
<p>BM_GETSTATE, BM_SETSTATE</p>
<ul>
<li>한 윈도우를 마우스로 누르거나 Space Bar를 눌렀을 때의 상태를 의미한다.</li>
</ul>
</li>
<li>
<p>BM_SETSTYLE</p>
<ul>
<li>단추가 만들어진 후 단추의 스타일을 변경할 수 있게 한다.</li>
</ul>
</li>
<li>
<p>BM_CLICK, BM_GETIMAGE, BM_SETIMAGE</p>
</li>
</ol>
<ul>
<li>
<p>푸시버튼</p>
<ul>
<li>
<p>on/off 표시도 하지않고 곧바로 동작을 시작하기 위해서 주로 사용된다.</p>
</li>
<li>
<p>푸시버튼이 누릴경우 BN_CLICKED인 WM_COMMAND 메시지를 부모 윈도우에 보낸다.</p>
</li>
</ul>
</li>
<li>
<p>체크박스(텍스트가 같이 표시된 정사각형 상자)</p>
<ul>
<li>
<p>체크박스에 체크표시 생성하려면 wParam : 1, 체크표시를 지우려면 wParam : 0</p>
<p>SendMessage(hwndButton, BM_SETCHECK, 1, 0); - 체크표시 생성</p>
<p>SendMessage(hwndButton, BM_SETCHECK, 0, 0); - 체크표시 삭제</p>
<p>iCheck = (int)SendMessage(hwndButton, BM_GETCHECK, 0, 0); 버튼이 체크되면 TRUE, 그렇지 않으면 FALSE</p>
</li>
</ul>
</li>
<li>
<p>라디오 버튼</p>
<p>SendMessage(hwndButton, BM_SETCHECK, 1, 0); - 체크표시 생성</p>
<p>SendMessage(hwndButton, BM_SETCHECK, 0, 0); - 체크표시 삭제</p>
</li>
<li>
<p>그룹박스</p>
<ul>
<li>다른 컨트롤과 달리 키보드, 마우스 입력 처리 x, 부모 윈도우에 WM_COMMAND 메시지도 보내지 않는다.</li>
</ul>
</li>
<li>
<p>버튼 텍스트 바꾸기</p>
<ul>
<li>
<p>SetWindowText(hwnd, pszString)</p>
<p>hwnd : 텍스트를 바꿀 대상 윈도우의 핸들, pszString : 널로 끝나는 문자열을 가리키는 포인터</p>
</li>
<li>
<p>iLength = GetWindowText(hwnd, pzxBuffer, iMaxLength); //현재 텍스트를 얻어온다.</p>
</li>
<li>
<p>iLength = GetWindowTextLength(hwnd) : 특정 텍스트 길이에 대비하려면 리턴반은 길이로 텍스트 버퍼를 할당한다.</p>
</li>
</ul>
</li>
<li>
<p>보이는 버튼과 활성화된 버튼</p>
<ul>
<li>
<p>자식 윈도우가 입력을 받으려면 화면에 표시되고 또한 활성화 되어야 한다.</p>
<p>자식 윈도우 숨길경우 : ShowWindow(hwndChild, SW_HIDE)</p>
<p>자식 윈도우 현재 보이는지 확인 : IsWindowVisible(hwndChild)</p>
<p>자식 윈도우 활성화/비활성화 : EnableWindow(hwndChild, FALSE), EnableWindow(hwndChild, TRUE)</p>
<p>자식 위도우 활성 여부 : IsWindowEnabled(hwndChild)</p>
</li>
</ul>
</li>
<li>
<p>버튼과 입력 포커스</p>
</li>
</ul>
<ol>
<li>부모윈도우 -자식윈도우 포커스 움직일경우</li>
</ol>
<p>case WM_KILLFOCUS : ( 부모에 KILLFOCUS -wParam에 입력포커스를 얻은 자식윈도우 핸들이 들어가 있음</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">for( i=0; i&lt; NUM; i++)</code></pre></div>
<p>{</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">    if(hwndChild[i] == (HWND)wParam)

    {</code></pre></div>
<p>SetFocus(hwnd)</p>
<p>break;</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">    }</code></pre></div>
<p>}</p>
<ol start="2">
<li>
<p>자식 윈도우 -부모 윈도우 포커스 움직일경우</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">  case WM_KILLFOCUS:

  if(hwnd == GetParent((HWND)wParam)

  {

              SetFocus(hwnd);

              break;

   }</code></pre></div>
</li>
</ol>
<ul>
<li>
<p>시스템 색상</p>
<ul>
<li>GetSysColor()와 SetSysColor()를 이용하면 이들 색상을 얻거나 설정할 수 있다.</li>
</ul>
</li>
<li>
<p>WM_CTLCOLORBTN 메시지</p>
<ul>
<li>
<p>버튼 색상을 프로그램에서 우리가 선호하는 색상에 맞추는 방법으로 WM_CTLCOLORBTN 메시지를 처리한다.</p>
<p>이 메시지는 자식 윈도우가 자신의 클라이언트 영역을 그리려고 할 때 윈도우 프로시저에게 보내는 것이다.</p>
<p>부모 윈도우는 이 기회를 이용하여, 자식 윈도우 프로시저가 그리기에 사용할 색상을 바꿀 수 있다.</p>
</li>
</ul>
<ol>
<li>
<p>wParam : 버튼의 장치 컨텍스트에 대한 핸들</p>
</li>
<li>
<p>lParam : 버튼의 윈도우 핸들</p>
</li>
<li>
<p>SetTextColor를 사용하여 텍스트 색상을 설정함</p>
</li>
<li>
<p>SetBkColor를 사용하여 텍스트 배경을 설정함.</p>
</li>
<li>
<p>자식 윈도우에게 브러쉬 핸들을 반환한다.</p>
</li>
</ol>
</li>
<li>
<p>WM_CTLCOLORBTN의 문제점</p>
<p>푸시 버튼과 오너 드로우 버튼만 부모 윈도우에 WM_COTCOLORBTN 메시지를 보낼 수 있고, 부모 윈도우가 이 메시지를 처리하여</p>
<p>배경을 칠할 브러시를 리턴한 경우, 오너 드로우 버튼만 이에 응답할 수 있다.</p>
</li>
</ul>
<p>LRESULT CALLBACK WinProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">switch (msg) {
    case WM_CTLCOLORSTATIC: {
        if ((HWND)lParam == filterNameOff) {
        static HBRUSH hBrushColor;

            if (!hBrushColor) {
                hBrushColor = CreateSolidBrush(RGB(0xFF, 0xFF, 0xFF)); // White background is returned
                SetBkColor((HDC)wParam, RGB(0xFF, 0xFF, 0xFF));          // White background for text
            }

            // Background color that is used to repaint the control (doesn't affect text background)
            return (LRESULT)hBrushColor;
        }
    }</code></pre></div>
<ul>
<li>
<p>오너드로우 버튼</p>
<ol>
<li>
<p>CreateWindow의 3번째 인자에 BS_OWNERDRAW 스타일 추가</p>
</li>
<li>
<p>BS_OWNERDRAW 스타일로 생성한 버튼은 자신이 다시 그려져야 할 때마다 부모 윈도우에 WM_DRAWITEM 메시지를 보낸다.</p>
<p>버튼이 처음 생성될 때, 버튼을 누르거나 뗄 때, 입력 포커스를 잃거나 얻을 때, 즉 다시 그려질 때 WM_DRAWITEM 호출된다.</p>
</li>
<li>
<p>lParam은 DRAWITEMSTRUCT 구조체를 가리키는 포인터.(버튼을 그리는데 필요한 정보가 들어있음)</p>
<ul>
<li>
<p>hdc = 버튼의 디바이스 컨텍스트</p>
</li>
<li>
<p>rcItem = 버튼의 크기를 제공하는 Rect 구조체</p>
</li>
<li>
<p>CtlID = 컨트롤 윈도우 ID</p>
</li>
<li>
<p>itemState = 버튼이 눌렸는지 혹은 입력 포커스를 가지고 있는지 나타냄</p>
<p>만약, 버튼이 눌려있으면 itemState 1로 세팅(ODS_SEELECTED) 상수를 이용하여 검사</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>스태틱 클래스</p>
<ul>
<li>
<p>마우스, 키보드 입력을 받아들이지도 않고, 부모 윈도우에 WM_COMMAND 메시지를 보내지도 않는다.</p>
</li>
<li>
<p>스태틱 자식 윈도우 위로 마우스를 옮기거나 클릭 시 자식 윈도우는 WM_NCHITTEST 메시지를 가로채고,</p>
<p>HTTRANSPARENT를 윈도우에 반환한다.</p>
</li>
<li>
<p>SS_LEFT, SS_RIGHT, SS_CENTER를 포함하는 문자열 정렬</p>
</li>
</ul>
</li>
<li>
<p>스크롤바 클래스</p>
<ul>
<li>
<p>스크롤바는 부모 윈도우에 WM_COMMAND를 보내지 않는대신, WM_VSCROLL, WM_HSCROLL 메시지를 보낸다.</p>
</li>
<li>
<p>lParam 값 : 윈도우 핸들</p>
<p>i = GetWindowLong((HWND)lParam, GWL_ID)</p>
</li>
<li>
<p>wParam</p>
<p>nScrollCold = (int)LOWORD(wParam) // SB_PAGEDOWN, SB_LINEDOWN등</p>
<p>nPos = (Short int)HIWORD(wParam) // SB_THUMPOSION, SB_THUMTRACK 발생시 Postion값을 변경할 수 있다.</p>
</li>
</ul>
</li>
<li>
<p>윈도우 서브클래싱</p>
<ul>
<li>
<p>현존하는 윈도우 프로시저에 끼어들어서 프로그램내에서 일부 메시지를 처리하고 나머지는 원래 윈도우 프로시저에 전달하기</p>
<p>위해서 쓰인다.</p>
</li>
<li>
<p>이유 : 몇개의 기능만 구현한 프로그램을 실행하고 나머지는 원래 프로시저로 넘기기 위해서 사용된다.</p>
</li>
</ul>
<p>예) OldScroll = (WNDPROC)SetWindowLong(hwnd, GWL_WNDPROC, (LONG)ScrollProc);</p>
<ul>
<li>그 이후 CallWindowsProc()를 사용하여 이전의 스크롤 바 윈도우 프로시저를 호출하게 된다.</li>
</ul>
</li>
<li>
<p>배경 색칠하기</p>
<ul>
<li>DWORD SetClassLong(HWND, int nIndex, LONG INewVal);</li>
</ul>
<p>=윈도우의 배경색 뿐만이 아니라 커서, 아이콘등을 윈도우 클래스에 등록한 것을 전부바꿀때 사용됨.</p>
<ul>
<li>반환값 : 성공시 - 이전 값이 지정된 32비트 정수, 실패시 : 0 이 리턴됨</li>
</ul>
</li>
</ul>
<p>예) SetClassLong(hwnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(color[0], color[1], color[2]));</p>
<ul>
<li>
<p>에디트 클래스</p>
<ol>
<li>에디트 클래스 스타일</li>
</ol>
<p>hwndEdit = CreateWindow(TEXT(“edit”), NULL, WS_CHILD|WS_VISIBLE|WS_HSCROLL|WS_VSCROLL|</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                    WS_BORDER|ES_LEFT|ES_MULTILINE|ES_AUTOHSCROLL|ES_AUTOVSCROLL,

                                    0, 0, 0, 0, hwnd, (HMENU) 1, ((LPCTREAESTRUCT)lParam)->hInstance, NULL);</code></pre></div>
<ol>
<li>
<p>정렬 : ES_LEFT, ES_RIGHT, ES_CENTER</p>
</li>
<li>
<p>행 : 디폴트는 단일행 / 다중 행 MULTILINE</p>
</li>
<li>
<p>자동 수평/수직 스크롤 : ES_AUTOHSCROLL, ES_AUTOVSCROLL =끝까지 문자가 입력되었을 때 자동으로 수평/수직 스크롤이됨</p>
</li>
</ol>
<ol start="2">
<li>에디트 컨트롤 통지</li>
</ol>
<ol>
<li>
<p>LOWORD(wParam) : 자식 윈도우 ID</p>
</li>
<li>
<p>HIWORD(wParam) : 통지코드</p>
</li>
<li>
<p>lParam : 자식 윈도우 핸들</p>
</li>
</ol>
<ul>
<li>
<p>통지코드</p>
<p>● EN_ERRSPACE : 에디트 컨트롤이 메모리 할당 할 수 없을 경우</p>
<p>● EM_MAXTEXT : 에디트 컨트롤에 텍스트를 삽입할 공간이 부족할 경우</p>
<p>=위의 두개의 통지코드에 대한 처리를 해줘야 한다.</p>
</li>
</ul>
<ol start="3">
<li>에디트 컨트롤에 보낼 수 있는 메시지</li>
</ol>
<ol>
<li>
<p>선택된 내용을 잘라내기 : SendMessage(hwndEdit, WM_CUT, 0, 0);</p>
</li>
<li>
<p>선택된 내용을 복사하기 : SendMessage(hwndEdit, WM_COPY, 0, 0); //삽입하기 WM_PASTE</p>
</li>
<li>
<p>선택된 내용을 삭제하기 : SendMessage(hwndEdit, WM_CLEAR, 0, 0);</p>
</li>
</ol>
</li>
<li>
<p>리스트박스 클래스</p>
<ol>
<li>리스트 박스 스타일</li>
</ol>
<p>hwndList = CreateWindow (TEXT (“listbox”), NULL,
WS_CHILD | WS_VISIBLE | WS_BORDER| WS_VSCROLL | LBS_NOTIFY,
10, 20, 200, 300,
hwnd, (HMENU) 2,
(HINSTANCE) GetWindowLong (hwnd, GWL_HINSTANCE), NULL) ;</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">1) LBS_NOTIFY : 리스트 박스는 어떠한 일이 일어나도 통지 메시지를 보내지 않으므로 통지메시지 사용시 꼭 추가해야함.

                        쓰인이유 - 과거 컴퓨터 느릴 시 조금이라도 속도를 빠르게 하기 위해서 사용됨(WM_COMMAND로 받음)

2) ﻿LBS_SORT : 리스트 박스내의 항목들을 정렬

3) LBS_MULTIPLESEL, LBS_EXTENDEDSEL : 리스트 박스 디폴트 선택 타입은 단일 선택 타입이다 하지만 2개의 타입을

                                                                 추가해주면 다중 or 확장 선택 리스트 박스를 추가할 수 있다.﻿﻿﻿﻿

4) LBS_STANDARD -LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER</code></pre></div>
<ol start="2">
<li>리스트 박스 문자열</li>
</ol>
<ol>
<li>
<p>리스트 박스 리턴값</p>
<ul>
<li>
<p>LB_ERRSPACE : SendMessage() 리턴이 LB_ERRSPACE는 내용을 저장할 메모리 공간이 부족할 때 리턴됨.</p>
</li>
<li>
<p>LB_ERROR : 다른 이유로 오류가 발생할 경우</p>
</li>
<li>
<p>성공시 문자열이 추가된 위치의 인덱스 값을 리턴함.</p>
</li>
</ul>
</li>
<li>
<p>리스트 박스 문자열 삽입</p>
<ul>
<li>
<p>SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)szString);</p>
<p>=4번째 인자는 널을 끝나는 문자열에 포인터값</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">  LBS_SORT 사용시 3번째 인자 0으로 세팅, 안할 경우 Index 값을 지정해줘야한다.</code></pre></div>
</li>
</ul>
</li>
<li>
<p>리스트 박스 문자열 삭제</p>
<ul>
<li>
<p>SendMessage(hwndList, LB_DELETESTRING, index, 0)</p>
<p>SendMessage(hwndList, LB_RESETCONTENT, 0, 0);</p>
<p>차이점 : LB_DELETESTRING은 인덱스에 있는 문자열 삭제, LB_RESETCONTENT는 모든 항목을 제거하는 것이다.</p>
</li>
</ul>
</li>
<li>
<p>리스트 박스 갱신</p>
<ul>
<li>
<p>SendMessage(hwnd, WM_SETREDRAW, FALSE, 0);</p>
<p>SendMessage(hwnd, WM_SETREDRAW, TRUE, 0);</p>
</li>
</ul>
<p>=리스트 박스 윈도우 프로시저는 항목이 추가되거나 삭제될 때 화면을 갱신한다. 막약 추가하거나 삭제할 문자열이 많은 경우</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> 컨트롤의 다시 그리기 플래그를 끔으로써 갱신 동작을 일시 금지 시키고 이후에 다시 동작시키게 할 수 있다.

 또한 스타일에 LBS_NOREDRAW 스타일을 추가할 경우 화면 갱신 플래그를 꺼진 상태로 시작할 수 있다.</code></pre></div>
</li>
<li>
<p>리스트 박스 항목 선택, 빼기</p>
<ul>
<li>
<p>리스트박스 항목의 개수 : iCount = SendMessage(hwndList, LB_GETCOUNT, 0, 0);</p>
</li>
<li>
<p>항복 선택 : SendMessage(hwndList, LB_SETCURSEL, iIndex, 0);</p>
</li>
<li>
<p>시작 글자에 기반한 항목 선택 : iIndex = SendMessage(hwndList, LB_SELECTSTRING, iIndex, (LPARAM)szSearchString);</p>
</li>
<li>
<p>현재 선택된 항목을 알고 싶을 경우 : iIndex = SendMessage(hwndList, LB_GETCURSEL, 0, 0);</p>
</li>
<li>
<p>문자열의 길이 알기 위해서 : ILength = SendMessage(hwndList, LB_GETTEXTLEN, iIndex, 0);</p>
</li>
<li>
<p>텍스트 버퍼에 저장 : iLength = SendMessage(hwndList, LB_GETTEXT, iIndex, (LPARAM)szBuffer);</p>
</li>
<li>
<p>특정 항목의 선택 상태 설정 : SendMessage(hwndList, LB_SETSEL, wParam, iIndex);</p>
</li>
<li>
<p>턱정 항목의 선택 상태 알기 위해 : iSelect = SendMessage(hwndList, LB_GETSEL, iIndex, 0);</p>
</li>
</ul>
</li>
<li>
<p>리스트 박스로부터 메시지 받기</p>
<ul>
<li>
<p>자식윈도우 : LOWORD(wParam)</p>
</li>
<li>
<p>통지코드 : HIWORD(wParam)</p>
</li>
<li>
<p>lParam : 자식 윈도우 핸들</p>
</li>
<li>
<p>WM_COMMAND 통지코드</p>
<p>LBN_SELCHANGE : 현재 리스트 박스 선택이 변경됨을 알려줌.</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li>
<p>알게된 API</p>
<p>GetEnvironmentVariable(lpName, lpBuffer, nSize) : 환경변수 이름 반환하기.</p>
<p>=lpName : 환경변수 이름 / lpBuffer : 환경변수가 가지고 있는 정보를 반환하여 저장될 버퍼, nSize : 버퍼에 들어갈 최대 크기</p>
</li>
</ul>
<h1 id="메뉴와-그밖에-리소스" style="position:relative;"><a href="#%EB%A9%94%EB%89%B4%EC%99%80-%EA%B7%B8%EB%B0%96%EC%97%90-%EB%A6%AC%EC%86%8C%EC%8A%A4" aria-label="메뉴와 그밖에 리소스 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>메뉴와 그밖에 리소스</h1>
<ul>
<li>아이콘, 커서, 문자열, 커스텀 리소스</li>
</ul>
<ol>
<li>리소스의 분리</li>
</ol>
<ul>
<li>
<p>일반적으로 프로그램은 코드와 데이터로 구분됨</p>
</li>
<li>
<p>코드 : 데이터를 처리하는 수단 / 데이터 : 코드가 아닌 모든 것을 데이터라고 지칭할 수 있음(비트맵, 메뉴, 아이콘 등)</p>
</li>
<li>
<p>리소스란 : 코드의 논리와 무관한 데이터의 집합</p>
</li>
<li>
<p>리소스와 코딩 과정이 분리시 장점</p>
</li>
</ul>
<ol>
<li>
<p>디자이너와 프로그래머가 분담하여 작업을 하기가 편리하다. 프로그래머는 열심히 프로그램의 논리를 만들고 디자이너는 리소스만</p>
<p>예쁘게 만들어 결합시키면 되기 때문이다.</p>
</li>
<li>
<p>리소스를 수정하더라도 프로그램을 일일이 다시 컴파일하지 않아도 되므로 컴파일 속도가 현저히 빨라진다.</p>
</li>
<li>
<p>한번 만들어 놓은 리소스를 다른 프로젝트에 쉽게 가져다 쓸 수 있어 리소스의 재사용에 유리하다.</p>
</li>
<li>
<p>리소스는 교체가 가능한 모듈이므로 상황에 따라 다른 형태의 리소스를 사용할 수 있다.(다국어 버전, 스킨기능 등)</p>
</li>
<li>
<p>RC파일 : 사용하고자 하는 리소스의 종류, 모양 등을 작성한 파일</p>
</li>
<li>
<p>RES : RC파일을 리소스 컴파일러(RC.exe)로 컴파일 하면 RES라는 이진 파일이 생성됨.</p>
</li>
</ol>
<p>-링크과정에서 obj, res 파일이 합쳐져서 .exe 실행파일이 생성됨.</p>
<ol start="3">
<li>
<p>Resource.h : RC파일에서 지정한 Define된 값을 이용하여서 Resource.h파일을 그 리소스에 ID값을 부여함.</p>
<p>예) *.rc : MENUITEM “&#x26;New”, ID_MENUITEM40020</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">  Resource.h  : #define ID_MENUITEM40020                40020</code></pre></div>
</li>
</ol>
<p>● 알게된 내용 - DISCARDABLE(윈도우즈가 (필요하다면) 추가적인 공간을 얻기 위해 리소스를 메모리에서 제거할 수 있음을 나타낸다.)</p>
<ol start="3">
<li>
<p>리소스를 만들고 프로젝트에 포함시키는 과정을 정리</p>
</li>
<li>
<p>프로그램에 아이콘 추가하기</p>
</li>
</ol>
<ul>
<li>
<p>아이콘을 추가하기 위해서 insert/Resource 선택해서 Icon을 추가한다.</p>
</li>
<li>
<p>리소스 폅집기에서 FileName과 ID값을 지정함. &#x3C; *.rc파일과 resource.h 파일에 추가됨.></p>
</li>
</ul>
<p>-*.rc : IDI_ICON&#x3C;IDICON DISCARDABLE “icondemo.ico”<FileName></p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">  *.h :  #define IDI_ICON                        101</code></pre></div>
<ul>
<li>
<p>아이콘 핸들 얻는 방법</p>
<p>hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON));</p>
<p>HICON LoadIcon( HINSTANCE, LPCTSTR);</p>
</li>
</ul>
<p>#define MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))</p>
<p>-정수타입의 리소스ID를 문자열 포인터에 대입할 수 없으므로 캐스팅을 할 때 쓰이는 매크로가 MAKEINTRESOURCE 이다.</p>
<ul>
<li>
<p>아이콘의 크기 얻는 방법(32 x 32 : Visual C++ 생성한 아이콘 크기)</p>
<p>cxIcon = GetSystemMetrics(SM_CXICON);</p>
<p>cyIcon = GetSystemMetrics(SM_CYICON);</p>
<p>좀 더 작은 16x16 픽셀의 사이즈를 얻을 경우 XM_CXSMSIZE, SM_CYSMSIZE 쓰인다.</p>
</li>
<li>
<p>아이콘을 그릴 때 : DrawIcon(HDC, x, y, HICON)</p>
</li>
</ul>
<p>● LoadIcon(NULL, IDI_APPLICATION) - hInstance가 NULL 이므로 윈도우즈가 미리 정의된 아이콘임을 알려준다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                                      IDI_APPLICATION은 WINUSER.H 미리 정의되어 있다.

                                                      #define IDI_APPLICAION MAKEINTRESOURCE(32512)</code></pre></div>
<ul>
<li>
<p>프로그램 실행중에 아이콘을 전환할 경우</p>
<p>SetClassLong(hwnd, GCL_HICON, LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ALTICON))</p>
</li>
<li>
<p>LoadIcon은 핸들을 얻지만 핸들을 파괴할 필요가 없다.</p>
</li>
</ul>
<ol start="5">
<li>사용자 맞춤 커서 추가하기</li>
</ol>
<ul>
<li>
<p>윈도우 클래스를 정의</p>
<p>wndclass.hCursor = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CURSOR));</p>
<p>wndclass.hCursor = LoadCursor(hInstance, szCursor); - 커서를 텍스트 이름으로 정의</p>
</li>
</ul>
<ol start="6">
<li>문자열 리소스</li>
</ol>
<ul>
<li>
<p>문자열 리소스는 주로 프로그램을 다른 언어로 변환하는 것을 쉽게 하기 위해서 사용된다.</p>
</li>
<li>
<p>문자열 테이블 생성</p>
<p>insert/Resource - String Table 추가</p>
</li>
<li>
<p>LoadString(hInstance, id, szBuffer, iMaxLength)</p>
<p>2번째 인자 : 각 문자열 앞쪽에 있는 ID값</p>
<p>3번째 인자 : 문자열을 받을 버퍼의 주소, 4번째는 szBuffer로 옮길 문자의 최대 개수</p>
<p>리턴 : 문자열에 들어 있는 문자의 개수를 리턴함.</p>
</li>
<li>
<p>문자열 리소스는 최대 4K까지의 길이를 가질 수 있다.</p>
</li>
<li>
<p>문자열 리소스 장점</p>
</li>
</ul>
<ol>
<li>우선 첫째로 문자열 자체가 코드와 분리됨으로써 문자열만 따로 관리할 수 있으며 프로젝트를 유지하는데도 큰 도움을 준다.</li>
</ol>
<ol start="2">
<li>
<p>문자열 리소스를 사용하는 두번째 이점은 다국어 버전을 쉽게 만들 수 있다는 점이다</p>
<p>3)﻿ 문자열이 소스와 분리되어 있으면 문자열을 고쳐도 소스를 다시 컴파일할 필요가 없어 개발 기간도 빨라진다.</p>
</li>
</ol>
<ol start="7">
<li>
<p>메뉴</p>
<ul>
<li>
<p>메뉴 추가</p>
<p>Insert/Resource - Menu 항목 추가</p>
</li>
<li>
<p>메뉴 속성 변경</p>
<p>Caption : 사용자에게 보여질 메뉴의 이름 / ID : 프로그램에서 이 메뉴 항목을 지칭하는 이름이다.</p>
</li>
<li>
<p>메뉴항목의 속성 : ID<em>상위메뉴</em>캡션 : ID_FILE_MENU</p>
</li>
<li>
<p>윈도우 클래스를 정의</p>
<p>wndclass.lpszMenuName = MAKEINTRESOURCE(IDR_MENU1)</p>
</li>
<li>
<p>메뉴의 특성</p>
<ol>
<li>
<p>1번째 특성은 메뉴에 보이는 것 : 텍스트 문자열 or 비트맵</p>
</li>
<li>
<p>2번째 특성은 WM_COMMAND에 wParam 하위비트에 각 메뉴의 ID값을 전달해서 메뉴의 선택을 윈도우 프로시저에게 알려줌</p>
</li>
<li>
<p>3번째 특성은 메뉴 항목의 속성(비활성, 활성, 체크등을 표시해줌)</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>● 알게 된 내용</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">  - HMENU GetMenu(hwnd) - 메뉴의 핸들얻음

  - CheckMenuItem(hMenu, menuID, uCheck)

    예) CheckMenuItem(hMenu, LOWORD (wParam) - ID, MF_CHECKED) ;

  - EnableMenuItem(hMenu, menuID, nEnable)

    예) EnableMenuItem(hMenu, LOWORD (wParam), MF_GRAYED/MF_ENABLED)</code></pre></div>
<ol start="8">
<li>키보드 가속기</li>
</ol>
<ul>
<li>
<p>키보드 가속기 장점</p>
<ol>
<li>
<p>메뉴와 키보드 가속기 로직을 프로그래머가 중복 구현할 필요가 없다.</p>
<p>TranslateAccelerator()에서 지정한 윈도우의 윈도우 프로시저에 윈도우즈가 WM_COMMAND 메시지를 보낸다.</p>
</li>
</ol>
</li>
<li>
<p>단축키와 키보드 가속기에 다른점</p>
<ol>
<li>
<p>단축키 : 반드시 Alt키와 함께 사용해야 하며 메뉴에 있는 항목을 키보드로 선택하는 빠른 방법</p>
</li>
<li>
<p>키보드 가속기 : 메뉴와 상관없이 언제든지 사용가능하다.</p>
</li>
</ol>
</li>
<li>
<p>가속기 추가</p>
<p>Insert/Resource - Accelerator 추가</p>
</li>
<li>
<p>키보드 가속기의 속성 - ID : 액셀레이터의 ID, KEY : 액셀레이터가 사용할 키, Modifiers : Key와 함께 눌러질 조합키</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                             Type :  아스키코드, 가상키코드</code></pre></div>
</li>
<li>
<p>가속시 테이블 로드</p>
<p>hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1));</p>
<p>1번째 인자 : 프로그램의 인스턴스, 2번째 인자 : 액셀러레이터 테이블의 이름 문자열 포인터</p>
</li>
<li>
<p>키누름 변환</p>
<p>TranslateAccelator(HWND, HACCEL, LPMSG)</p>
<ol>
<li>
<p>키보드 메시지가 WM_COMMAND 메시지로 변경하여 액셀러레이터가 동작할 수 있도록 함.</p>
</li>
<li>
<p>동작방식</p>
</li>
</ol>
<p>KEYDOWN(Ctrl) - TranslateAccelator(FALSE) - TranslateMessage - DispatchMessage - WndProc - 처리완료</p>
<p>KEYDOWN(A) - TranslateAccelator(TRUE) - WndProc - WM_COMMAND 호출되서 처리되게 함.</p>
</li>
</ul>
<p>HACCEL hAccel;</p>
<p>hAccel=LoadAccelerators(hInstance,MAKEINTRESOURCE(IDR_ACCELERATOR1));
while(GetMessage(&#x26;Message,0,0,0)) {
if (!TranslateAccelerator(hWnd,hAccel,&#x26;Message)) {
TranslateMessage(&#x26;Message);
DispatchMessage(&#x26;Message);
}
}</p>
<h1 id="대화상자" style="position:relative;"><a href="#%EB%8C%80%ED%99%94%EC%83%81%EC%9E%90" aria-label="대화상자 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>대화상자</h1>
<blockquote>
<p>WndClass.cbClsExtra=0;
WndClass.cbWndExtra=0;
WndClass.hbrBackground=(HBRUSH)(COLOR_WINDOW+1);
WndClass.hCursor=LoadCursor(NULL,IDC_ARROW);
WndClass.hIcon=LoadIcon(NULL,IDI_APPLICATION);
WndClass.hInstance=hInstance;
WndClass.lpfnWndProc=WndProc;
WndClass.lpszClassName=lpszClass;
WndClass.lpszMenuName=NULL;
WndClass.style=CS_HREDRAW | CS_VREDRAW;
RegisterClass(&#x26;WndClass);</p>
</blockquote>
<p>BOOL CALLBACK AboutDlgProc(HWND hDlg,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
switch (iMessage) {
case WM_INITDIALOG:
return TRUE;
case WM_COMMAND:
switch (LOWORD(wParam)) {
case IDOK:
EndDialog(hDlg,IDOK);
return TRUE;
case IDCANCEL:
EndDialog(hDlg,IDCANCEL);
return TRUE;
}
break;
}
return FALSE;
}</p>
<p>LRESULT CALLBACK WndProc(HWND hWnd,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
switch (iMessage) {
case WM_LBUTTONDOWN:
DialogBox(g_hInst,MAKEINTRESOURCE(IDD_DIALOG1),hWnd,AboutDlgProc);
return 0;
case WM_DESTROY:
PostQuitMessage(0);
return 0;
}
return(DefWindowProc(hWnd,iMessage,wParam,lParam));
}</p>
<ul>
<li>
<p>대화상자</p>
<ul>
<li>프로그램과 사용자간의 대화, 곧 명령 및 정보 전달을 위한 특별한 윈도우</li>
</ul>
</li>
<li>
<p>대화상자 템플릿</p>
</li>
</ul>
<ul>
<li>
<p>대화상자의 모양을 정의하는 이진 데이터</p>
</li>
<li>
<p>대화상자 자체의 속성은 물론이고 대화상자 내에 생성되는 컨트롤의 위치, 크기 , 속성등도 정의되어 있음.</p>
</li>
<li>
<p>DialogBoxIndirect(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc);</p>
</li>
<li>
<p>LPCDLGTEMPLATE 구조체에 위치, 크기 속성( pdt->style = WS_POPUP, pdt->x = 10, pdt->y = 20; )</p>
</li>
</ul>
<ul>
<li>모드형 대화상자</li>
</ul>
<ul>
<li>프로그램이 모드형 대화상자를 표시, 사용자는 대화상자와 프로그램 내의 다른 윈도우 사이에 전환할 수 없다.</li>
</ul>
<ul>
<li>대화상자 프로시저</li>
</ul>
<ol>
<li>
<p>대화상자 프로시저 정의</p>
<ul>
<li>
<p>윈도우 프로시저가 윈도우에서 발생하는 메시지를 처리하는 것과 마찬가지로 대화상자 프로시저는 대화상자에서 발생하는 메시지를</p>
<p>처리함.</p>
</li>
</ul>
</li>
<li>
<p>대화상자 프로시저 역할</p>
<ul>
<li>
<p>대화상자 생성 시 자식 윈도우 컨트롤 초기화, 자식 윈도우 컨트롤이 발생시킨 메시지 처리, 대화상자의 종료 처리</p>
</li>
<li>
<p>WM_PAINT, 키보드와 마우스 메시지 처리하지 않음</p>
</li>
</ul>
</li>
<li>
<p>대화상자, 윈도우 프로시저 다른점</p>
</li>
<li>
<p>윈도우 : LRESULT / 대화상자 : BOOL형 리턴 ( 대화상자가 FALSE를 리턴할 경우 그 메시지 나머지는 운영체제가 처리함)</p>
</li>
<li>
<p>윈도우 : 특정 메시지 처리하지 않을 경우(DefWindowProc()호출) / 대화상자 : 메시지 처리하면 TRUE, 그렇지 않으면 FALSE</p>
</li>
<li>
<p>윈도우 : WM_CREATE / 대화상자 : WM_INITDIALOG 호출됨&#x3C; 초기화 ></p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                               -WM_PAINT, WM_DESTROY 메시지 처리 안함.</code></pre></div>
</li>
<li>
<p>WM_COMMAND 호출</p>
<ul>
<li>
<p>대화상자 프로시저에서 주로 처리하는 메시지</p>
</li>
<li>
<p>LOWORD(wParam)에 메시지를 보낸 컨트롤의 ID가 전달, HIWORD(wParam) 통지코드가 전달됨.</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>대화상자 호출/ 종료</li>
</ul>
<p>int DialogBox(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc)</p>
<ul>
<li>
<p>1번째 인수 : 리소스를 가진 인스턴스 핸들 / 2번째 인수 : 대화상자 템플릿의 리소스 ID</p>
<p>3번째 인수 : 대화상자를 소유할 부모 윈도우, 네번째 인수는 대화상자 프로시저의 이름</p>
<p>예) DialogBox (hInstance, TEXT (“AboutBox”), hwnd, AboutDlgProc) ;</p>
</li>
</ul>
<p>BOOL EndDialog(HWND hDlg, int nResult)</p>
<ul>
<li>1번째 인수 : 대화상자 프로시저로 전달된 핸들 / 2번째 인수 : 대화상자를 호출한 DialogBox 함수의 리턴값으로 전달됨.</li>
</ul>
<ul>
<li>컨트롤과의 통신</li>
</ul>
<ol>
<li>핸들과 ID</li>
</ol>
<ol>
<li>윈도우 핸들 얻는 방법(차일드 ID 알경우)</li>
</ol>
<p>HWND GetDlgItem(HWND hDlg, int nIDDlgItem) : 1번째 인수는 대화상자의 핸들, 두번째 인수로 컨트롤의 ID주면 핸들값을 얻을 수 있다.</p>
<p>=컨트롤을 이동시키거나 숨길 때 핸들값이 사용됨(ShowWindow, MoveWindow)</p>
<ol start="2">
<li>컨트롤의 윈도우 핸들로부터 ID를 구하는데 사용</li>
</ol>
<p>int GetDlgCtrlID(HWND hwndCtl)</p>
<p>id = GetWindowLong(HWND, GWL_ID);</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">= 윈도우 핸들로부터 ID값을 구하는데 사용함.</code></pre></div>
<p>SendDlgItemMessage(HWND, hDlg, int nID, UNIT MSG, WPARAM wParam, LPARAM lPrame)</p>
<p>=SendMessage(GetDlgItem(hDlg, ID) ~ 2개의 함수를 합쳐놓은 API 제공</p>
<p>=SendDlgItemMessage(hdlg, id, BM_SETCHECK, 1,0);</p>
<ul>
<li>컨트롤의 값 읽기</li>
</ul>
<ol>
<li>문자열을 읽고 출력하는함수</li>
</ol>
<ul>
<li>UINT GetDlgItemText( HWND hDlg, int nIDDlgItem, LPTSTR lpString, int nMaxCount );</li>
<li>BOOL SetDlgItemText( HWND hDlg, int nIDDlgItem, LPCTSTR lpString );</li>
</ul>
<ol start="2">
<li>정수를 읽고 출력하는 함수</li>
</ol>
<ul>
<li>
<p>UINT GetDlgItemInt( HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned );</p>
</li>
<li>
<p>BOOL SetDlgItemInt( HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned );
=네번째 인수 bSigned가 TRUE일 경우는 부호있는 정수값을 읽어주며 FALSE일 경우는 부호를 무시하고 무조건 양수로 읽어준다</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">세번째 인수는 지정된 BOOL형 포인터에 에러가 있는지 없는지 대입(에러검사가 필요없는 경우 NULL 전달함)</code></pre></div>
</li>
</ul>
<ul>
<li>Radio Button 컨트롤 사용법(3개의 기능이 모두 같다) - wParam 1이여야지 체크가 됨.</li>
</ul>
<ol>
<li>SendMessage(GetDlgItem(hDlg, id), BM_SETCHECK, i == LOWORD(wParam), 0);</li>
</ol>
<p>for(int I=IDC_BLACK; I&#x3C;=IDC_WHITE; I++)</p>
<p>SendMessage(GetDlgItem(hDlg, I), BM_SETCHECK, I==LOWORD(wParam), 0);</p>
<ol start="2">
<li>SendDlgItemMessage(hDlg, id, BM_SETCHECK, i == LOWORD(wParam), 0);</li>
</ol>
<p>for(int I=IDC_BLACK; I&#x3C;=IDC_WHITE; I++)</p>
<p>SendDlgItemMessage(hDlg, I, BM_SETCHECK, I==LOWORD(wParam), 0);</p>
<ol start="3">
<li>
<p>CheckRadioButton(hDlg, idFirst, idLast, idCheck)</p>
<p>-idFirst부터 idLast 끼지 모든 라이오 버튼 컨트롤의 체크 표시를 끄되, 예외적으로 ID가 idCheck인 라디오 버튼만 체크표시한다.</p>
</li>
</ol>
<ul>
<li>
<p>체크박스 컨트롤 사용법</p>
<p>1.CheckDlgButton(hDlg, idCheckbox, iCheck);</p>
<p>-iCheck가 1이면 버튼을 체크, 0이면 체크가 제거됨.</p>
</li>
</ul>
<ol start="2">
<li>iCheck = IsDlgButtonChecked(hDlg, idCheckBox) : 체크 박스의 상태를 얻을 수 있다.</li>
</ol>
<ul>
<li>대화상자 프로시저 인자전달</li>
</ul>
<ol>
<li>DialogBoxParam(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam)</li>
</ol>
<p>예)</p>
<p>typedef struct</p>
<p>{</p>
<p>int iColor, iFigure;</p>
<p>} ABOUTBOX_DATA</p>
<p>static ABOUTBOX_DATA ad = { IDC_BLACK, IDC_RECT };</p>
<p>if(DialogBoxParam(hInstance, TEXT(“AboutBox”), hwnd, AboutDlgProc, &#x26;ad))</p>
<p>-WM_INITDIALOG 메시지를 받을 때 lParam으로 전달된다.</p>
<p>pad = (ABOUTBOX_DATA*) lParam;</p>
<p>ad = *pad;</p>
<ul>
<li>
<p>모달리스 / 모달 대화상자</p>
<ol>
<li>차이점</li>
</ol>
<ol>
<li>
<p>모달 : DialogBox() 함수를 이용, 대화상자가 파괴된 후에야 값을 리턴한다</p>
<p>모달리스 : CreateDialog() 함수를 이용, 윈도우 핸들을 즉시 리턴해준다.</p>
</li>
<li>
<p>모달리스형은 흔히 캡션바와 시스템 메뉴를 포함 /모달형은 캡션바와 시스템메뉴 제공하지않음(다른영역 이동X)</p>
</li>
<li>
<p>모달리스형은 WS_VISIBLE을 생략한다면 CreateDialog 호출 후 ShowWindow()를 반드시 호출</p>
</li>
</ol>
<p>예) hDlgModaless = CreateDialog(…);</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">   ShowWindow(hDlgModaless, SW_SHOW);</code></pre></div>
<ol start="2">
<li>모달리스 구현사항</li>
</ol>
<p>hDlgModaless = CreateDialog(hInstance, lpTemplate, hWndParent, lpDialogFunc);</p>
<p>-DialogBox에 인자와 같다.</p>
<p>while(GetMessage(&#x26;msg, NULL, 0, 0)){</p>
<p>if(!IsWindow(hDlgModaless) || !IsDialogMessage(hDlgModaless, &#x26;msg)) // 모달리스 대화상자 사용시</p>
<p>{</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">   if(!TranslateAccelerator(hwnd, hAccel, &amp;msg)) //키보드 가속기 사용시

   {

 TranslateMessage (&amp;msg) ;
 DispatchMessage  (&amp;msg);</code></pre></div>
</li>
</ul>
<p>}</p>
<p>}</p>
<p>BOOL IsWindow(HWND) -유효한 윈도우 핸들인지 조사</p>
<ul>
<li>하는 이유 : 대화상자를 두번 만들지 않게 하기 위해서 사용된다.</li>
</ul>
<p>BOOL IsDialogMessage(hDlg, lpMsg)</p>
<ul>
<li>하는 이유 : 메시지를 점검 한 후 대화상자와 관련된 메시지이면 이 메시지를 처리하고 TRUE를 리턴함. 아니라면 FALSE리턴</li>
</ul>
<p>DestroyWindow(hDlg) -모달은 EndDialog지만 모달리스는 DestroyWindow를 호출하게 된다.</p>
<p>CreateDialog에서 리턴한 핸들을 NULL로 초기화해줘야함.</p>
<ul>
<li>
<p>알게된 내용 : CreateWindow에서 Style중 WS_CLIPCHILDREN 사용하는 이유?</p>
<p>-프로그램이 대화상자를 지우지 않고도 메인 윈도우를 다시 그릴 수 있게 해주는 Style이다.</p>
</li>
<li>
<p>공통 대화상자</p>
<ul>
<li>하나의 표준화된 사용자 인테페이스를 장려하기 위해서 개발되었다.</li>
</ul>
</li>
</ul>
<ol>
<li>
<p>파일열기 대화상자</p>
</li>
<li>
<p>색상 대화상자</p>
</li>
<li>
<p>폰트 선택 대화상자</p>
</li>
<li>
<p>찾기 대화상자</p>
</li>
</ol>
<h1 id="클립보드" style="position:relative;"><a href="#%ED%81%B4%EB%A6%BD%EB%B3%B4%EB%93%9C" aria-label="클립보드 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>클립보드</h1>
<ul>
<li>
<p>클립보드 : 프로그램간에 또는 내부적으로 교환할 데이터를 잠시 저장해 두는 곳</p>
</li>
<li>
<p>힙 할당(TEXT -클립보드)</p>
<ul>
<li>
<p>HGLOBAL GlobalAlloc(UNIT uFlags, DWORD dwByte) : 힙에 메모리를 할당하는 함수</p>
</li>
<li>
<p>LPVOID GlobalLock(HGLOBAL hMem) : 메모리의 실제 위치의 포인터 리턴</p>
</li>
<li>
<p>BOOL GlobalUnLock(HGLOBAL hMem)</p>
</li>
<li>
<p>HGLOVAL GlobalFree(HBLOBAL hMem)</p>
</li>
</ul>
</li>
<li>
<p>비트맵 -클립보드</p>
<p>hBlt = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP));</p>
<p>CF_BITMAP 세팅 후 클립보드에 복사하고 읽을 수 있다.</p>
</li>
</ul>
<p>HGLOBAL hmem;</p>
<p>TCHAR *ptr;</p>
<p>hmem=GlobalAlloc(GHND, lstrlen(str)+1);
ptr=(TCHAR *)GlobalLock(hmem);
memcpy(ptr,str,lstrlen(str)+1);
GlobalUnlock(hmem);</p>
<p>if (OpenClipboard(hWnd)) { // 클립보드 독점
EmptyClipboard();
SetClipboardData(CF_TEXT,hmem);
CloseClipboard();</p>
<p>}</p>
<ul>
<li>
<p>클립보드 함수</p>
<p>BOOL OpenClipboard(HWND hWndNewOwner) // 인수 : 윈도우 핸들</p>
<p>BOOL EmptyClipboard(); // 클립보드 지움</p>
<p>HANDLE SetClipboardData(UINT uFormat, HANDLE hMem) // uFormat : CF_BITMAP, CF_TEXT등</p>
<p>-hMem 데이터가 uFormat으로 클립보드에 복사된다. 호출이후부터는 사용자가 hMem 메모리 변경불가능(시스템관리:클립보드)</p>
<p>-SetClipboardData(CF_TEXT, hmem);</p>
<p>BOOL CloseClipBoard(); // 클립보드 닫음(생략시 다른사용자가 클립보드 사용X)</p>
<p>BOOL IsClipboardFormatAvailable(UINT format) // uFormat : CF_BITMAT, CF_TEXT등 클립보드에 있는지 검사</p>
<p>HANDLE GetClipBoardData(UINT format)</p>
<p>-hmem = GetClipBoardData(CF_TEXT);</p>
<p>-HBITMAP hBit = (HBITMAP)GetClipBoardData(CF_BITMAP)</p>
</li>
<li>
<p>새로운 클립보드 포멧을 등록</p>
<p>UINT RegisterClipboardFormat(LPCTSTR lpszFormat)</p>
<p>예)</p>
<p>MyFormat = RegisterClipboardFormat(“MOVIE”);</p>
<p>SetClipboardData(MyFormat, hmem);</p>
</li>
<li>
<p>클립보드 포맷을 관리하는 함수</p>
</li>
</ul>
<p>int CountClipboardFormats(void) // 등록된 포멧의 개수</p>
<p>UINT EnumClipboardFormats(UINT format); // 각 포멧 열거함</p>
<p>int GetClipboardFormatName(UINT format, LPTSTR lpszFomatName, int cchMaxCount); // 포멧의 등록 이름을 구함.</p>
<ul>
<li>
<p>클립보드 뷰어</p>
<ul>
<li>
<p>클립보드 내용의 변화를 통지받는 프로그램</p>
</li>
<li>
<p>뷰어끼리 체인으로 연결되어 있어, 최근에 설치된 뷰어가 맨앞에 위치하고 체인을 통해서 뒤에 뷰어에게 변화나 상태를 전달함.</p>
</li>
<li>
<p>클립보드의 내용 변경 : SetClipboardViewer(CF_TEXT, hmem) -윈도우 WM_DRAWCLIPBOARD 호출 ->모든 뷰어에게 추가를 알림</p>
</li>
<li>
<p>클립보드 뷰어 삭제 : ChangeClipboadChain(hWnd, hNext) -WM_CHANGECBCHAIN -모든 뷰어에게 삭제를 알림</p>
</li>
</ul>
</li>
</ul>
<h1 id="프린터" style="position:relative;"><a href="#%ED%94%84%EB%A6%B0%ED%84%B0" aria-label="프린터 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>프린터</h1>
<ul>
<li>인쇄과정</li>
</ul>
<p>프로그램 - GDI - 스풀러 - 디바이스드라이버 - 프린터</p>
<ol>
<li>
<p>스풀러 : 적절한 프린터 디바이스 드라이버를 메모리 로딩 - 고수준 출력 명령을 저널 레코드로 변환 - 디스크에 파일로 저장</p>
<ul>
<li>저장된 출력 명령을 바탕으로 백그라운드에서 인쇄 - 저널레코드 (디바이스드라이버 알수있도록 DDI(Device Driver Interface) 변환</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>프린터 DC</p>
<ol>
<li>
<p>인쇄대화상자 호출하는 함수</p>
<ul>
<li>BOOL PrintDlg(LPPRINTDLG lppd);</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>pd.lStructSize = sizeof(PRINTDLG); //구조체 크기
pd.Flags = PD_RETURNDC; // 프린터 DC 구함
pd.hwndOwner = hWndMain; // 윈도우 핸들
pd.nFromPage = 1;
pd.nToPage = 1;
pd.nMinPage = 1;
pd.nMaxPage = 1;
pd.nCopies = 1;
PrintDlg(&#x26;pd);
hPrtdc = pd.hDC; // 프린트 DC 사용을 위해 HDC 대입</p>
<ol start="2">
<li>
<p>HDC CreateDC(LPCTSRT lpszDriver, LPCTSTR lpszDevice, LPCTSTR lpszOutput, CONST DEVMODE *lpInitData)</p>
<ul>
<li>
<ol>
<li>driver name, 2. device name, 3. NULL 4. 디바이스 드라이버에 특정 초기화 데이터</li>
</ol>
</li>
<li>
<p>특정 이름의 디바이스의 DC를 구할 때 사용함.</p>
</li>
</ul>
</li>
</ol>
<p>PRINTER_INFO_4 *pi4;</p>
<p>EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &#x26;cbNeed, &#x26;cbReturn);
pi4=(PRINTER_INFO_4 *)malloc(cbNeed);
EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, (PBYTE)pi4, cbNeed, &#x26;cbNeed, &#x26;cbReturn);</p>
<p>hdc = CreateDC(NULL, pi4->pPrinterName, NULL, NULL);</p>
<ol start="3">
<li>
<p>인쇄의 시작</p>
<ul>
<li>int StartDoc(HDC hdc, Const DOCINFO *lpdi);</li>
</ul>
</li>
</ol>
<p>doc.cbSize = sizeof(DOCINFO);
doc.lpszDocName = TEXT(“TEST Document”);
doc.lpszOutput = NULL; // 출력파일 이름, NULL 일 경우 프린터 DC로 출력
doc.lpszDatatype = NULL;
StartDoc(hPrtdc, &#x26;doc);</p>
<ol start="4">
<li>프린터 드라이버에게 데이터를 받아들이도록 준비시킴(새로운 페이지 시작)</li>
</ol>
<ul>
<li>
<p>int StartPage(HDC hdc)</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> StartPage(hPrtdc);</code></pre></div>
</li>
</ul>
<ol start="5">
<li>한 페이지 출력을 완료 후 새 용지를 로드</li>
</ol>
<ul>
<li>int EndPage(HDC hdc);</li>
</ul>
<p>EndPage(hPrtdc);</p>
<ol start="6">
<li>인쇄가 마무리</li>
</ol>
<ul>
<li>int EndDoc(HDC hdc)</li>
</ul>
<p>EndDoc(hPrtdc);</p>
<p>DeleteDC(hPrtdc);</p>
<ul>
<li>폰트의 변경</li>
</ul>
<p>xpage = GetDeviceCaps(hPrtdc, HORZRES); // 장치크기의 픽셀수
ypage = GetDeviceCaps(hPrtdc, VERTRES);
Rectangle(hPrtdc,0,0,xpage,ypage);</p>
<p>dpiY = GetDeviceCaps(hPrtdc, LOGPIXELSY); // 인치당 픽셀수</p>
<p>// 화면 해상도와 프린터의 해상도가 높기 때문에 아래와 같은 계산식이 필요함.</p>
<p>// 1 inch = 72 point = 인치당 픽셀수 구한값(pixel)</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> point = n*1/72*dpiY</code></pre></div>
<p>MyFont = CreateFont(20*dpiY/72, 0,0,0,FW_NORMAL, FALSE,FALSE,FALSE,HANGEUL_CHARSET,3,2,1,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                           VARIABLE_PITCH|FF_ROMAN,TEXT("궁서"));</code></pre></div>
<ul>
<li>비트맵 출력</li>
</ul>
<p>Result=GetDeviceCaps(hPrtdc, RASTERCAPS) &#x26; RC_BITBLT;
if (!Result) goto end;
hbit=(HBITMAP)LoadImage(g_hInst, MAKEINTRESOURCE(IDB_BITMAP1),
IMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);
..
MemDC=CreateCompatibleDC(hPrtdc);
OldBitmap=(HBITMAP)SelectObject(MemDC, hbit);
StretchBlt(hPrtdc,dpiX,dpiY,4<em>dpiX,4</em>by/bx*dpiY,MemDC,0,0,bx,by,SRCCOPY);</p>
<ul>
<li>
<p>주의사항</p>
<ol>
<li>
<p>프린터로 비트맵 출력 시 StretchBlt 함수로 출력해야함(Bitblt를 그대로 출력시 프린터에 화면에 나온거보다 작게 출력됨)</p>
</li>
<li>
<p>비트맵 출력이 가느한지 조사해야함.</p>
<p>GetDeviceCaps(hPrtdc, RASTERCAPS) -래스터 출력이 가능한지 확인</p>
<p>RC_BITBLT -비트맵 전송지원 지원</p>
</li>
<li>
<p>LoadImage 함수로 읽어야 한다. - 화면색상포맷과 프린터의 색상 포맷이 맞지 않기 때문에(DDB로 불러드리기때문에)</p>
</li>
</ol>
<p>LR_CREATEDIBSECTION - DIB 섹션으로 읽은 후 출력할 때 비트맵 포맷이 프린터에 맞게 변환된다.</p>
</li>
</ul>
<ul>
<li>
<p>여러 페이지 출력</p>
<ol>
<li>
<p>문서의 길이 계산</p>
<ul>
<li>
<p>사용자가 선택한 문서의 길이 알아내야함.</p>
<p>PD_ALLPAGES, PD_PAGENUMS, PD_SELECTION</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>if (pd.Flags &#x26; PD_PAGENUMS) {
nFirstPage=pd.nFromPage;
nFinalPage=pd.nToPage;
} else {
nFirstPage=pd.nMinPage;
nFinalPage=pd.nMaxPage;
}</p>
<ol start="2">
<li>시작페이지와 끝페이지 인쇄(for문으로 돌면서 인쇄해야함)</li>
</ol>
<p>for(nPage = nFirstPage; nPage &#x3C;= nFinalPage; nPage++)</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> {

      StartPage()

      EndPage()

  }

  EndDoc();</code></pre></div>
<ul>
<li>취소 프로시저(인쇄 취소시)</li>
</ul>
<ol>
<li>취소 프로시저와 취소 대화상자 필요함.</li>
</ol>
<p>// 취소대화상자</p>
<p>g_hDlgCancel=CreateDialog(g_hInst, MAKEINTRESOURCE(IDD_DIALOG1),
hWndMain, (DLGPROC)AbortDlgProc); // 모달리스로 대화상자 만듦</p>
<p>LRESULT CALLBACK AbortDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
switch (message) {
case WM_INITDIALOG:
return TRUE;
case WM_COMMAND:
g_bPrint=FALSE; // 취소 버튼 누를시 FALSE 세팅
EnableWindow(hWndMain, TRUE);
DestroyWindow(g_hDlgCancel);
g_hDlgCancel=NULL;
return TRUE;
}
return FALSE;
}</p>
<p>// 최소 프로시저. 이 함수에서 TRUE를 리턴하면 인쇄를 계속하고 FALSE를 리턴하면 인쇄를 취소한다.</p>
<p>SetAbortProc(hPrtdc, (ABORTPROC)AbortProc); // 취소 프로시저 추가</p>
<p>EnableWindow(hWndMain, FALSE); // 인쇄하려는 동안 프로그램을 종료, 다른 작업을 못하게 하기위해서</p>
<p>BOOL CALLBACK AbortProc(HDC hPrtdc, int iError)
{
MSG msg;
while (g_bPrint &#x26;&#x26; PeekMessage(&#x26;msg, NULL,0,0,PM_REMOVE)) { // g_bPrint 가 FALSE 가 될시 인쇄가 취소된다.
if (!IsDialogMessage(g_hDlgCancel, &#x26;msg)) {
TranslateMessage(&#x26;msg);
DispatchMessage(&#x26;msg);
}</p>
<p>return g_bPrint;</p>
<p>}</p>
<ul>
<li>프린터 열거</li>
</ul>
<ol>
<li>프린터 열거</li>
</ol>
<ul>
<li>
<p>시스템에 설치된 프린터와 프린터서버 등을 열거한다.</p>
</li>
<li>
<p>BOOL EnumPrint(DWORD Flags, LPTSTR Name, DWORD Level, LPBYTE pPrinterEnum, DWORD cbBuf, LPDWORD pcbNeeded,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                   LPDWORD pcReturnd);</code></pre></div>
<ol>
<li>
<p>Flags : 조사할 오브젝트 종류를 지정함(PRINTER_ENUM_LOCAL,, PRINTER_ENUM_SHARED)</p>
</li>
<li>
<p>Name : 조사할 대상의 추가정보(대부분 NULL 세팅) - 특정도메인내 프린터목록 조사시 도메인명을 적을 수는 있음.</p>
</li>
<li>
<p>Level, pPrinterEnum : Level 2 -PRINTER_INFO_2 // 프린터의 원하는 정보를 얻을 때 쓰이며 1~5까지 구성되어 있음</p>
</li>
<li>
<p>cbBuf : 배열의 크기</p>
</li>
<li>
<p>pcbNeeded : 필요한 메모리양</p>
</li>
<li>
<p>pcReturned : 구조체 배열의 크기를 리턴</p>
</li>
</ol>
</li>
</ul>
<p>typedef struct _PRINTER_INFO_4A {
LPSTR pPrinterName;
LPSTR pServerName;
DWORD Attributes;
} PRINTER_INFO_4A, *PPRINTER_INFO_4A, *LPPRINTER_INFO_4A;</p>
<p>PRINTER_INFO_4 *pi4;</p>
<p>EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &#x26;cbNeed, &#x26;cbReturn);
pi4=(PRINTER_INFO_4 *)malloc(cbNeed);
EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, (PBYTE)pi4, cbNeed, &#x26;cbNeed, &#x26;cbReturn);
for (i=0;i&#x3C;cbReturn;i++) {
wsprintf(Mes,“프린터 이름: %s, 종류:%s ”, pi4[i].pPrinterName,
pi4[i].Attributes==PRINTER_ATTRIBUTE_LOCAL ? “로컬”:“네트워크”);
TextOut(hdc,10,y++*20,Mes,lstrlen(Mes));
}
free(pi4);</p>
<ul>
<li>
<p>속성조사</p>
<ol>
<li>
<p>해상도, 크기(픽셀), 크기(사이즈)</p>
<p>GetDeviceCaps(HDC, HORZRES/HORZSIZE/LOGPIXELSX);</p>
</li>
<li>
<p>프린터 이름을 토대로 속성 확인(한 부씩 인쇄, 양면인쇄)</p>
<p>DeviceCapabilities(szPrinter, szPrinter, DC_COLLATE/DC_DUPLEX, NULL, NULL); //한부씩 인쇄, 양면인쇄</p>
</li>
<li>
<p>OpenPrinter, GetPrinter, ClosePrinter : 프린터 이름으로 핸들값을 얻어서 PRINTER_INFO값을 얻고 세팅가능</p>
<p>GetPrinter, EnumPrinters PRINTER_INFO의 크기를 같은 방법으로 얻을 수 있음.</p>
</li>
</ol>
</li>
</ul>
<h1 id="비트맵과-bitblt함수" style="position:relative;"><a href="#%EB%B9%84%ED%8A%B8%EB%A7%B5%EA%B3%BC-bitblt%ED%95%A8%EC%88%98" aria-label="비트맵과 bitblt함수 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>비트맵과 Bitblt함수</h1>
<ul>
<li>
<p>메모리 DC 쓰는 이유(비트맵)</p>
<ul>
<li>
<p>비트맵과 같은 경우 대용량 데이터 이므로 곧바로 출력할 경우 출력속도가 느리게 되는 단점이 발생함.</p>
<p>(비트맵 곧바로 화면 출력못하게 되어 있음)</p>
</li>
</ul>
<p>-메모리 DC에 그려두고 화면 DC에 고속복사해서 보여주게 하기 위해서 사용됨.</p>
</li>
<li>
<p>메모리 DC -화면 DC에 고속복사 함수</p>
<ol>
<li>BOOL BitBlt(hdcDest, xDest, xDest, nWidth, nHeight, hdcSrc, nXsrc, nYSrc, dwRop) - 래스터 연산 : 256가지</li>
</ol>
<p>dwRop : 래스터 연산 방법을 지정</p>
<p>-SRCCOPY : 소스 영역을 대상 영역에 복사한다.</p>
<ol start="2">
<li>
<p>비트맵 전송시 확대 및 축소 가능</p>
<p>BOOL StretchBlt(hdcDest, xOriginDest, YOriginDest, nWidthDest, nHeightDest, hdcSrc, nXOriginSrc, nYOriginSrc, nWidthSrc,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                   nHeightSrc, dwRop) - 래스터 연산 : 256가지</code></pre></div>
<ul>
<li>
<p>StretchBlt(hdc, 0,0,246,320,MemDc,0,0,123,160,SRCCOPY)</p>
</li>
<li>
<p>SetStretchBltMode 모드 변경가능.</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li>
<p>BOOL PatBlt(HDC hdc, int nXLeft, int nYLeft, int nWidth, int nHeight, DWORD dwRop) - 래스터 연산 : 16가지</p>
<ul>
<li>
<p>지정한 사각영역을 현재 DC에 선택된 브러시로 채움</p>
</li>
<li>
<p>FillRect는 사각영역으로 브러시로 채우지만 PatBlt는 dwRop에 따라서 바뀔 수가 있다.(검정, 흰색으로 채울 경우)</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>GDI 비트맵 객체</li>
</ul>
<ol>
<li>DDB 비트맵 생성함수</li>
</ol>
<ul>
<li>
<p>CreateBitmap(cx, cy, cPlanes, cBitsPixel, bits);</p>
</li>
<li>
<p>CreateCompatibleBitmap(hdc, cx, cy) -hdc이용해서 GetDeviceCaps(PLANES(색상면의수), BITPIXEL(픽셀당비트수)) 정보를</p>
<p>얻음 -내부적으로 CreateBitmap 호출함.</p>
</li>
<li>
<p>CreateCompatibleBitmap(&#x26;bitmap) -BITMAP 구조체에 주소를 설정</p>
<p>● GetObject(hBitmap, sizeof (BITMAP), &#x26;bitmap) -구조체의 값 얻을 수 있음</p>
</li>
</ul>
<ul>
<li>
<p>메모리 디바이스 컨텍스트</p>
<p>hdcMem = CreateCompatibleDC(hdc);</p>
<ol>
<li>
<p>인자로 NULL 지정 시 비디오 디스플레이와 호환되는 메모리 디바이스 컨텍스트 생성</p>
</li>
<li>
<p>DeleteDC 호출 후 파괴</p>
</li>
</ol>
</li>
<li>
<p>비트맵 리소스 로드</p>
<p>hBitmap = LoadBitmap(hInstance, szBitmapName);</p>
<ol>
<li>
<p>시스템 비트맵 로딩 : hinstance =NULL</p>
</li>
<li>
<p>DeleteObject 삭제</p>
</li>
</ol>
</li>
<li>
<p>흑백 비트맵 포멧(리소스 생성없이 color array로 흑백비트맵생성)</p>
<p>static BYTE bits[] = {0x51, ~~};</p>
<ol>
<li>
<p>bitmap.bmBits = (PSTR)bits;</p>
<p>hBitmap = CreateBitmapIndirect(&#x26;bitmap);</p>
</li>
<li>
<p>hBitmap = CreateBitmapIndirect(&#x26;bitmap);</p>
<p>SetBitmapBits(hBitmap, sizeof(bits), bits);</p>
</li>
<li>
<p>hBitmap = CreateBitmap(20, 5, 1, 1, bits); //width, height,planes,bitsPixel,color data array</p>
<p>-DeleteObject 함수 호출해서 해제시켜줘야 한다.</p>
</li>
</ol>
</li>
</ul>
<h1 id="장치독립적인비트맵" style="position:relative;"><a href="#%EC%9E%A5%EC%B9%98%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%B8%EB%B9%84%ED%8A%B8%EB%A7%B5" aria-label="장치독립적인비트맵 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>장치독립적인비트맵</h1>
<ul>
<li>DIB &#x26; DDB 차이점</li>
</ul>
<ul>
<li>
<p>DDB(Device Dependent Bitmap) : 장치 설정대로 출력되는 비트맵(32bit -32bit, 흑백 -흑백)</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                            장점 : 정보가 일치하므로 빠른 속도로 이미지를 출력

                                            단점 : 장치의 의존하므로 다른 장치에선 정확히 출력이 안된다.</code></pre></div>
</li>
<li>
<p>DIB(Device Independent Bitmap) : 장치와 상관없이 헤더에 나온 세팅대로 출력하는 비트맵</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                             장점 : 어떤한 설정을 가진 장치에서도 동일한 이미지정보를 출력

                                             단점 : 비트맵 출력 속도가 떨어질 수 있음( 비트맵 구성이 다르다면 변환작업이 필요)</code></pre></div>
</li>
</ul>
<ul>
<li>DIB 구조</li>
</ul>
<ol>
<li>
<p>BITMAPFILEHEADER 구조체</p>
<ul>
<li>비트맵 파일 자체에 관한 정보를 가진다.</li>
</ul>
</li>
</ol>
<p>typedef struct tagBITMAPFILEHEADER {
WORD bfType;
DWORD bfSize;
WORD bfReserved1;
WORD bfReserved2;
DWORD bfOffBits;
} BITMAPFILEHEADER, FAR *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;</p>
<ol start="2">
<li>
<p>BITMAPINFOHEADER 구조체</p>
<ul>
<li>BITMAPFILEHEADER 구조체 바로 뒤에 위치하면서 DIB의 크기(가로 폭, 세로 높이)와 색상 포멧에 관한 정보등을 가진 구조체이다.</li>
</ul>
</li>
</ol>
<p>typedef struct tagBITMAPINFOHEADER{
DWORD biSize;
LONG biWidth;
LONG biHeight;
WORD biPlanes;
WORD biBitCount;
DWORD biCompression;
DWORD biSizeImage;
LONG biXPelsPerMeter;
LONG biYPelsPerMeter;
DWORD biClrUsed;
DWORD biClrImportant;
} BITMAPINFOHEADER, FAR *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;</p>
<ol start="3">
<li>RGBQUAD 구조체</li>
</ol>
<ul>
<li>비트맵에서 사용되는 색상 테이블 정의</li>
</ul>
<p>typedef struct tagRGBQUAD {
BYTE rgbBlue;
BYTE rgbGreen;
BYTE rgbRed;
BYTE rgbReserved;
} RGBQUAD;</p>
<ol start="4">
<li>
<p>DIB 출력</p>
<ol>
<li>SetDIBitsToDevice</li>
</ol>
</li>
</ol>
<p>BYTE* pRaster;</p>
<p>int SetDIBitsToDevice(HDC hdc,int xDest,int yDest,DWORD dwWidth,DWORD dwHeight,int xSrc,int ySrc,UINT uStartScan</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                           UINT cScanLines,CONST VOID *lpvBits,CONST BITMAPINFO *lpbmi,UINT fuColorUse);</code></pre></div>
<ul>
<li>
<p>Return : 스캔 라인의 갯수</p>
</li>
<li>
<p>9번째 인자(cScanLines) : 스캔 라인수 = 비트맵의 높이</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">               &lt; 비트맵 ></code></pre></div>
<p>BITMAPFILEHEADER *fh = NULL;</p>
<p>fh = (BITMAPFILEHEADER*)malloc(GetFileSize(hFile, NULL));</p>
<p>BYTE* lpvBits = (PBYTE)fh+fh->bfOffBits;</p>
</li>
<li>
<p>lpvBits : 비트맵의 실제 모양인 래스터 데이터 포인터(BITMAPFILEHEADER+BITMAPINFOHEADER == bfOffBits(FILEHEADER))</p>
</li>
<li>
<p>fuColorUse : DIB_RGB_COLORS - 색상값 / DIB_PAL_COLORS - 팔레트의 인덱스</p>
<ol start="2">
<li>StretchDIBits( 확대 출력시 )</li>
</ol>
</li>
</ul>
<p>int StretchDIBits(HDC hdc,int XDest,int YDest,int nDestWidth,int nDestHeight,int XSrc, int YSrc,int nSrcWidth,int nSrcHeight</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                   CONST VOID *lpvBits,CONST BITMAPINFO *lpbmi,UINT iUsage,DWORD dwRop);</code></pre></div>
<ul>
<li>
<p>Return : 스캔 라인의 갯수</p>
</li>
<li>
<p>iUsage : DIB_RGB_COLOR(색상테이블 색상값), DIB_PAL_COLORS(팔레트의 인덱스)</p>
</li>
<li>
<p>dwRop : 래스터 연산</p>
</li>
</ul>
<ol start="5">
<li>DDB 변환</li>
</ol>
<p>HBITMAP CreateBitmap(HDC hdc, CONST BITMAPINFOHEADER *lpbmih, DWORD fdwInit, CONST VOID *lpbInit</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                               CONST BITMAPINFO* lpbmi, UINT fuUsage)'</code></pre></div>
<p>{</p>
<p>if(hdc)</p>
<p>hBitmap = CreateCompatibleBitmap(hdc, cx, cy);</p>
<p>else</p>
<p>hBitmap = CreateBitmap(cx,cy,1,1,NULL);</p>
<p>if(fdwInit)</p>
<p>{</p>
<p>hdcMem = CreateCompatibleDC(hdc);</p>
<p>SelectObject(hdcMem, hBitmap);</p>
<p>SetDIBitsToDevice(hdcMem,0,0,cx,cy,0,0,0,cy,lpbInit,lpbmi,fuUsage);</p>
<p>DeleteDC(hdcMem);</p>
<p>}</p>
<p>return hBitmap;</p>
<p>}</p>
<ul>
<li>내부적으로 메모리 DC를 만들고 호환 비트맵에 DIB를 출력하는 일을 한다.(BitBlt로 출력)</li>
</ul>
<ol start="6">
<li>DIB 섹션</li>
</ol>
<ul>
<li>
<p>이점 : 래스터 데이터를 직접 조작, 크기가 큰 파일을 다루기가 편리(파일 매핑 오브젝트)</p>
</li>
<li>
<p>HBITMAP CreateDIBSection(HDC hdc, CONST BITMAPINFO *pbmi, UINT iUsage, VOID **ppvBits,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                    HANDLE hSection, DWORD dwOffset);</code></pre></div>
</li>
</ul>
<ol start="7">
<li>DIB로 변환</li>
</ol>
<ul>
<li>
<p>CreateBitmap, CreateCompatibleBitmap 장치에 의존하므로 속도가 빠르지만 DIB로 저장시에는 아래 API가 호출되어야한다.</p>
</li>
<li>
<p>int GetDIbits(HDC hdc,HBITMAP hBitmap,UINT uStartScan,UINT uScanLines,LPVOID lpvBits,LPBITMAPINFO lpbi, UINT uUsage);</p>
</li>
</ul>
<h1 id="텍스트와-폰트" style="position:relative;"><a href="#%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80-%ED%8F%B0%ED%8A%B8" aria-label="텍스트와 폰트 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>텍스트와 폰트</h1>
<ul>
<li>
<p>텍스트 그리기 함수</p>
<ol>
<li>
<p>SetTextAlign(HDC hdc, UINT fMode)</p>
<p>● fMode : 지정하는 정렬 Mode를 세팅함.</p>
<p>TA_UPDATECP : TextOut에서 지정한 x, y 좌표를 무시하고 현재 CP(current position)를 이용한다.</p>
<p>TA_NOUPDATECP : CP를 사용하지 않고 지정한 좌표를 사용하며 CP를 변경하지 않는다.</p>
</li>
<li>
<p>TabbedTextOut(hdc, xStart, yStart, pString, iCount, iNumTabs, piTabStops, xTabOrigin)</p>
<ul>
<li>텍스트 문자열이 탭 문자(‘\t’, 0x09)를 포함한다면,TabbedTextOut()은 인자로 전달된 정수 배열에 기초하여 탭을 공백으로 확장함.</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>예) int tabstop[4] = {8,16,24,32}</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">  wsprintf(temp, "tabbedTextOut\t를\t이용한\t출력");

  1) TabbedTextOut(hdc,0,20,temp,strlen(temp),4,tabstop,0);

  =iNumTabs : 탭의 개수,  piTabStops : 탭 위치를 가지는 배열

  =첫 번째 탭에서는 설정된 문자열의 평균 가로크기의 8배, 두번째 탭에서는 16배 공백으로 띄워줌.

  2) TabbedTextOut(hdc,0,20,temp,strlen(temp),1,tabstop,0);

  =탭키를 만날 때마다 tabstop의 첫 번째 값 즉 8값만큼 균일적으로 공백으로 띄어 주게 된다.</code></pre></div>
<ol start="3">
<li>
<p>ExtTextOut(hdc, x, y,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">             fuOptions, - 텍스트 출력 옵션

             &amp;rect  - 사각영역</code></pre></div>
</li>
</ol>
<p>lpString,</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                   cbCount,

                   lpDx ) - 문자사이 공백값 배열 포인터(int pDx[]={5,6~~} pDx[i] 문자와 오른쪽문자 자간

 - 현재 선택된 글꼴, 배경색, 글자색을 이용하여 문자열을 그린다.

 - &amp;rect, lpDx 둘다 NULL인 경우 TextOut과 같은 기능이다.(TextOut을 내부적으로 보믄 ExtTextOut 호출함.)

1) fuOptions : 어플리케이션이 정의한 사각형을 사용하는 방법을 지정한다.

  ● ETO_CLIPPED : 텍스트가 주어진 사각형으로 클리핑 된다. 영역 안쪽에만 문자열이 출력된다.

  ● ETO_OPAQUE : 현재의 배경 색상으로 채워질 배경 직사각형</code></pre></div>
<ol start="4">
<li>
<p>DrawText(hdc, pString, iCount, &#x26;rect, iFormat);</p>
<ul>
<li>
<p>iFormat을 0으로 설정 : 윈도우즈는 텍스트를 캐리지 리턴문자(‘\r’), 라인피드(‘\n’)로 분리된 일련의 행으로 해석함</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                            DT_WORDBREAK : 사각영역의 오른쪽 끝에서 자동 개행되도록 한다.

                            DT_NOCLIP : 사각영역의 경계를 벗어나도 문자열을 자르지 않고 그대로 출력</code></pre></div>
</li>
<li>
<p>DrawTextEx(hdc, pString, iCount, &#x26;rect, iFormat, &#x26;drawtextparams)</p>
</li>
</ul>
</li>
</ol>
<p>typedef struct tagDRAWTEXTPARAMS
{
UINT cbSize; // 구조체의 크기
int iTabLength; // 각 탭 정지점의 크기
int iLeftMargin; //왼쪽 여백
int iRightMargin; //오른쪽 여백
UINT uiLengthDrawn; // 처리된 문자들의 개수를 받는다.
} DRAWTEXTPARAMS, FAR *LPDRAWTEXTPARAMS;</p>
<ul>
<li>
<p>DWORD GetSysColor(nIndex) : nIndex - 지정된 시스템 칼라를 취득함.(COLOR_MENU, COLOR_WINDOW)</p>
</li>
<li>
<p>현재글자간의 간격</p>
<ul>
<li>
<p>SetTextCharacterExtra(hdc, iExtra) - iExtra 논리단위로서 윈도우는 Pixel로 변환(글자간의 간격을 변경)</p>
</li>
<li>
<p>GetTextCharacterExtra(hdc)</p>
</li>
</ul>
</li>
<li>
<p>폰트만들기</p>
</li>
</ul>
<p>typedef struct tagLOGFONTW
{
LONG lfHeight;
LONG lfWidth;
LONG lfEscapement; // 문자열 각도
LONG lfOrientation; // 개별 문자의 각도
LONG lfWeight; // 문자의 굵기
BYTE lfItalic; // 기울기
BYTE lfUnderline; // 밑줄
BYTE lfStrikeOut; // 취소선
BYTE lfCharSet; // 문자셋
BYTE lfOutPrecision; // 출력정확도(폰트의 높이, 폭, 피치등에 근접한 폰트를 찾을지 지정함)
BYTE lfClipPrecision; //클리핑 영역을 벗어날 때의 처리방법
BYTE lfQuality; // 출력품질(글꼴, 폰트의 외형을 중시)
BYTE lfPitchAndFamily; // 피치 : 개별 글자의 폭, 폰트의 패밀리
WCHAR lfFaceName[LF_FACESIZE]; //타입페이스 : 폰트의 이름
} LOGFONTW, *PLOGFONTW, NEAR *NPLOGFONTW, FAR *LPLOGFONTW;</p>
<p>-CreateFont의 인자값과 같다. LOGFONT 구조체는 CreateFontIndirect의 인자로 쓰이게 된다.</p>
<ul>
<li>
<p>논리 폰트 : CreateFont 함수에 의해 만들어지는 폰트</p>
<p>물리 폰트 : 운영체제나 장치에 실제로 존재하는 폰트</p>
<p>스톡 폰트 : 운영체제에 의해 제공되는 폰트(GetStockObject)</p>
</li>
<li>
<p>폰트열거</p>
</li>
</ul>
<ol>
<li>폰트 열거 함수</li>
</ol>
<ol>
<li>
<p>int EnumFontFamilies(HDC hdc, LPCTSTR lpszFamily, FONTENUMPROC lpEnumFontFamProc, LPARAM lParam)</p>
<p>lpszFamily : 조사하고자 하는 폰트 패밀리 지정함(값이 NULL이면 모든 패밀리를 조사한다.)</p>
<p>lpEnumFontFamProc : 발견된 폰트의 특성을 알려줌</p>
</li>
<li>
<p>int CALLBACK EnumFontFamProc(ENUMLOGFONT FAR *lpelf, NEWTEXTMETRIC FAR *lpntm, int FontType, LPARAM lParam)</p>
<p>ENUMLOGFONT - LOGFONT 구조체, ElFullName - 폰트타입 문자열,</p>
<p>NEWTEXTMETRIC : 폰트의 여러가지 특성값을 가지고 있음.</p>
<p>FontType : 폰트의 종류(장치, 래스터, 트루타입)</p>
</li>
</ol>
<ul>
<li>
<p>물리폰트</p>
<ol>
<li>
<p>BOOL GetTextMetrics(HDC hdc, LPTEXTMETRIC lptm) : 개별 문자의 폭이나 높이에 대한 정보를 구한 후 간격을 적당히 띄우고자</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                                                            할 때 사용함.( hdc에 현재 선택된 물리 폰트의 여러 가지 정보)</code></pre></div>
<ul>
<li>
<p>예) GetTextMetrics(hdc, &#x26;tm)</p>
<p>TextOut(hdc, 0, i*(tm.tmHeight), str, lstrlen(str));</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>BOOL GetTextExtentPoint32(HDC hdc, LPCTSTR lpString, int cbString, LPSIZE lpSize) : 문자열이 크기 구하기 위해서 사용됨.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> - "ijl", "BMW" 같은 세문자지만 전체 폭은 다르다. 이때 쓰이게 된다.

 - 예) GetTextExtentPoint32(hdc, str, lstrlen(str), &amp;sz)

         x += sz.cx;

         TextOut(hdc, x,0, str, lstrlen(str));</code></pre></div>
</li>
<li>
<p>폰트의 설치</p>
<ul>
<li>
<p>lpszFilename : 추가/삭제할 폰트의 경로를 전달해준다. (Windows\Font)</p>
</li>
<li>
<p>int AddFontRsource( LPCTSTR lpszFilename)</p>
<p>● 설치과정</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">1. 폰트파일을 Font 폴더로 복사

2. 폰트등록:AddFontResource

3. WM_FONTCHANGE 방송

   SendMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);

4. 레지스트리에 폰트 이름 기록</code></pre></div>
</li>
</ul>
</li>
<li>
<p>폰트의 삭제</p>
<ul>
<li>
<p>BOOL RemoveFontResource(LPCTSTR lpFileName)</p>
<p>● 설치과정</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">등록된 폰트를 취소:RemoveFontResource - WM_FONTCHANGE 방송 - 레지스트리에 폰트 이름 삭제 - 폰트파일을 삭제</code></pre></div>
</li>
</ul>
</li>
<li>
<p>BOOL GetVersionEx(LPOSVERSIONINFO lpVersionInformation)</p>
<ul>
<li>현재 작동하고 있는 OS의 버전 정보를 제공하는 API</li>
</ul>
<ol>
<li>
<p>OSVERSIONINFO</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> typedef struct _OSVERSIONINFOW {
DWORD dwOSVersionInfoSize; //Version Info 사이즈
DWORD dwMajorVersion;        // OS Version 2.1 -2
DWORD dwMinorVersion;        //OS Version 2.1 -1
DWORD dwBuildNumber;
DWORD dwPlatformId;            // OS platformID -VER_PLATFORM_NT, VER_PLATFORM_WIN32_C3 등
WCHAR  szCSDVersion[ 128 ];     // OS에 추가적인 정보</code></pre></div>
<p>} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW;</p>
</li>
</ol>
</li>
<li>
<p>패스</p>
<ul>
<li>
<p>GDI 함수들에 의해 그려진 도형의 모양</p>
</li>
<li>
<p>패스는 핸들을 가지지 않고 그려지는데 그것은 여러 개의 패스를 만들어 놓고 교체해 가며 사용할 수 없다는 뜻이다.</p>
</li>
<li>
<p>BeginPath(HDC) 와 EndPath(hWnd) 사이를 패스괄호라고 칭하였고, 이때 GDI함수는 출력을 내보내지 않고 패스에 기록하게 된다.</p>
</li>
</ul>
<p>StrokePath(HDC): 외곽선, FillPath(HDC) : 패스의 내부, StrokeAndFillPath(HDC) : 외곽선과 패스 내부</p>
<ul>
<li>클립패스</li>
</ul>
<ol>
<li>SelectClipPath(HDC, iMode)</li>
</ol>
<ul>
<li>SelectClipPath(hdc, RGN_COPY); //RGN_COPY : 핸재 패스가 새 클리핑 영역으로 선택됨</li>
</ul>
<ol start="2">
<li>PathToRegion(hdc) - 패스를 리전으로 바꿀 때 사용함(&#x3C;예hRgn = PathToRegion(hdc) )</li>
</ol>
</li>
<li>
<p>확장펜</p>
</li>
</ul>
<ul>
<li>ExtCreatePen(dwPenStyle, dwWidth, LOGBRUSH, dwStyleCount, lpStyle)</li>
</ul>
<ol>
<li>
<p>PenStyle : PS_SOLID, PS_JOIN_ROUND등 스타일 지정</p>
</li>
<li>
<p>dwWidth : 선의 굵기</p>
</li>
<li>
<p>LOGBRUSH : 구조체안에서 선의 무늬, 스타일 지정</p>
</li>
<li>
<p>dwStyleCount, lpStyle : PS_USERSTYLE 지정(사용자 정의 선을 그을 때 사용 - 안쓸경우 : 인수 두개는 0, NULL로 처리)</p>
<ul>
<li>
<p>dwStyleCount : lpStyle 배열의 크기</p>
</li>
<li>
<p>lpStyle : 5픽셀 찍고 다음 5픽셀 찍지말고.</p>
</li>
</ul>
<p>예) DWORD Style[] = {5,5,4,4,3,3,2,2,1,1};</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> hGeo = ExtCreatePen(PS_USERSTYLE|PS_GEOMETRIC, 1, &amp;logBrush, 10, Style)</code></pre></div>
</li>
</ol>
<h1 id="다중문서-인터페이스" style="position:relative;"><a href="#%EB%8B%A4%EC%A4%91%EB%AC%B8%EC%84%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4" aria-label="다중문서 인터페이스 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>다중문서 인터페이스</h1>
<ul>
<li>
<p>다중문서 인터페이스(Multiple-Document Interface : MDI)</p>
<ul>
<li>
<p>클라이언트 윈도우와 일반 윈도우 차이점</p>
<ol>
<li>
<p>클라이언트 윈도우는 MDICLIENT로 고정되어 있다.</p>
<p>CreateWindow(“MDICLIENT”~~), 운영체제에서 미리 정의되어 있으므로 윈도우 클래스 등록할 필요가 없다.</p>
</li>
<li>
<p>클라이언트 윈도우는 CreateWindow 마지막 인자 lParam에 CLIENTCREATESTRUCT 구조체에 포인터를 넘겨야함.</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>TranslateMDISysAccel(hWndClient, lpMsg)</p>
<ul>
<li>WM_KEYDOWN, WM_SYSCOMMAND 메시지를 MDI 자식 윈도우에 보내는 역할을 한다.</li>
</ul>
</li>
<li>
<p>프레임 윈도우 메시지 처리 / 윈도우 메시지 처리</p>
<ol>
<li>인수차이</li>
</ol>
<ul>
<li>
<p>DefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)</p>
</li>
<li>
<p>DefFrameProc(HWND hWnd,HWND hWndMDIClient,UINT Msg, WPARAM wParam, LPARAM lParam)</p>
<p>=클라이언트 윈도우 핸들이 추가됨.</p>
</li>
</ul>
<ol start="2">
<li>
<p>메시지 처리</p>
<ul>
<li>프레임 윈도우 메시지 처리 후 return 0 대신 break문을 사용해서 처리해야함.(포커스 오류)</li>
</ul>
</li>
</ol>
</li>
<li>
<p>클라이언트 윈도우</p>
<ol>
<li>
<p>GetSubMenu(GetMenu(), 1)</p>
<p>메뉴 -기준으로</p>
<p>서브메뉴 0 (File)</p>
<p>서브메뉴 1 (Window)</p>
</li>
<li>
<p>CLIENTCREATESTRUCT 설명</p>
</li>
</ol>
<ul>
<li>
<p>hWindowMenu : 차일드 목록 관리에 사용될 메뉴 ID</p>
</li>
<li>
<p>idFirstChild : 첫번째 차일드 윈도우의 목록이 출력될 메뉴 항목(최대 9개까지 출력가능함)</p>
</li>
</ul>
<p>ccs.hWindowMenu = GetSubMenu(GetMenu(hwnd), WINDOWMENU)
ccs.idFirstChild = IDM_WINDOWCHILD; // 메뉴에서 첫 차일드 항목 이후 9개의 id가 연속적으로 비어 있어야 한다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                                          그래서 따로 연속 될 수 있는 값으로 #define 해야한다.</code></pre></div>
</li>
</ul>
<ol start="3">
<li>
<p>CreateWindow에 스타일</p>
<ul>
<li>WS_CLIPCHILDREN 클라이언트 윈도우가 다시 그려질 시 자식 윈도우에 WM_PAINT 메시지를 보내지 못하게 하기 위해 세팅함.</li>
</ul>
</li>
</ol>
<ul>
<li>클라이언트 윈도우, MDI 관련 구조체</li>
</ul>
<ul>
<li>
<p>응용프로그램이 MDI 클라이언트 윈도우를 생성하면 CLIENTCREATESTRUCT 구조체를 지정해줘야 합니다.</p>
</li>
<li>
<p>MDI 클라이언트 윈도우가 MDI 자식 윈도우를 생성하면 MDICREATESTRUCT 구조체를 지정해야 합니다.</p>
</li>
</ul>
<ul>
<li>
<p>차일드(자식) 윈도우</p>
<ol>
<li>
<p>차일드 윈도우 주의사항</p>
<ul>
<li>
<p>차일드 윈도우는 메뉴를 가질 수 없으므로 lpszMenuName은 NULL이어야 한다.</p>
</li>
<li>
<p>별도의 아이콘을 지정하는 것이 좋다.(최소화, 시스템 메뉴 구분)</p>
</li>
<li>
<p>여분의 메모리를 남겨두어야 한다. (차일드 윈도우 파일이름이나 일련번호가 저장됨)</p>
</li>
</ul>
</li>
<li>
<p>자식윈도우 생성</p>
</li>
</ol>
<ul>
<li>
<p>MDICREATESTRUCT 속성 채우기</p>
<ol>
<li>
<p>mcs.style = MDIS_ALLCHIDSTYLES</p>
<p>=MDIS_ALLCHILDSTYLES : WS_MINIMIZE | WS_MAXMIZE | WS_HSCROLL | WS_VSCROLL</p>
</li>
<li>
<p>WM_MDICREATE 를 SendMessage에 보내면 자식 윈도우 생성(lParam에 MDICREATESTRUCT 구조체 포인터전달)</p>
</li>
</ol>
<p>typedef struct tagMDICREATESTRUCT {
LPCTSTR szClass;
LPCTSTR szTitle;
HANDLE hOwner;
int x;
int y;
int cx;
int cy;
DWORD style;
LPARAM lParam;</p>
</li>
</ul>
<p>} MDICREATESTRUCT, *LPMDICREATESTRUCT;</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> 3) HWND CreateMDIWindow(LPTSTR lpClassName, LPTSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth,

     int nHeight, HWND hWndParent, HINSTANCE hInstacne, LPARAM lParam);</code></pre></div>
</li>
</ul>
<ol start="3">
<li>자식 윈도우 바둑판식 정렬</li>
</ol>
<ul>
<li>
<p>WM_MDITILE 를 SendMessage에 보내면 자식 윈도우 생성</p>
</li>
<li>
<p>MDITILE_HORIZONTAL 수평정렬, MDITILE_VERTICAL 수직정렬</p>
</li>
</ul>
<ol start="4">
<li>자식 윈도우 계단식 정렬</li>
</ol>
<ul>
<li>
<p>WM_MDICASCADE 를 SendMessage에 보내면 자식 윈도우 생성</p>
</li>
<li>
<p>wParam에 MDITILE_SKIPDISABLED 플래그를 주면 사용금지 된 차일드는 정렬대상에서 제외한다.</p>
</li>
</ul>
<ol start="5">
<li>자식 윈도우 아이콘 정렬</li>
</ol>
<ul>
<li>
<p>WM_MDIICONARRANGE 를 SendMessage에 보내면 자식 윈도우 생성</p>
</li>
<li>
<p>최소화된 아이콘을 정렬함.</p>
</li>
</ul>
<ol start="6">
<li>마지막은 DefMDIChildProc를 불러서 처리해야함(DefWindowProc에 인수와 동일함.)</li>
</ol>
<ul>
<li>
<p>WndClass에서 cbWndExtra = sizeof(int) -여분의 메모리 지정가능.</p>
</li>
<li>
<p>SetWindowLong(hWnd, 0, ChildNum) - 메모리 블록을 참조하는 포인터를 통해서 값들을 저장한다.</p>
</li>
</ul>
<p>index : 윈도우에 여분 메모리가 있을 경우 여분 메모리의 오프셋을 지정할 수도 있다. 이 값은 반드시 양수여야 하며 cbWndExtra-4보다는 작아야 한다. 예를 들어 여분 메모리가 32바이트 지정되어 있으면 nIndex는 0~28까지 지정할 수 있다.</p>
<p>=GetWindowLong(hWnd, 0)을 통해서 저장된 값을 확인할 수 있다.</p>
<h1 id="멀티태스킹과-멀티스레딩--동기화" style="position:relative;"><a href="#%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9%EA%B3%BC-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9--%EB%8F%99%EA%B8%B0%ED%99%94" aria-label="멀티태스킹과 멀티스레딩  동기화 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>멀티태스킹과 멀티스레딩 &#x26; 동기화</h1>
<ul>
<li>
<p>멀티태스킹 : 하나의 운영체제에 여러 개의 프로세스가 동시에 실행되는 환경</p>
</li>
<li>
<p>멀티스레드 : 하나의 프로세스에서 여러 개의 스레드가 동시에 실행되는 환경</p>
</li>
<li>
<p>스레드 : 프로세스 내의 명령어를 실행시켜주는 경로, 일련의 실행코드</p>
<ol>
<li>스레드 생성</li>
</ol>
<ul>
<li>HANDLE CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreateFlags, lpThreadID)</li>
</ul>
</li>
</ul>
<p>1번째 인수 : 스레드 보안속성 지정(핸들끼리 상관하지 않는 한 NULL로 지정됨)</p>
<p>2번째 인수 : 스레드의 스택의 크기(기본 1M 잡힘)</p>
<p>3번째 인수 : 스레드의 시작주소</p>
<p>4번째 인수 : 스레드로 전달하는 작업 내용</p>
<p>5번째 인수 : 스레드 특성 지정(CREATE_SUSPENDED 플래그 지정시 스레드 만들고 실행X - ResumeThread 함수를 호출해야함)</p>
<p>6번째 인수 : 스레드 ID</p>
<p>2 스레드 특성</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">- 같은 프로세스 내의 스레드끼리는 주소공간, 전역변수, 코드를 공유함.</code></pre></div>
<ol start="3">
<li>
<p>스레드 상태 확인</p>
<ul>
<li>
<p>BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)</p>
<p>1번째 인수 : 대상 스레드 핸들</p>
<p>2번째 인수 : 스레드의 종료 코드 조사해 리턴</p>
</li>
</ul>
</li>
<li>
<p>스레드 종료</p>
<ol>
<li>
<p>Return &#x26; ExitThread 차이점과 ExitThread 문제점</p>
<ul>
<li>차이점 :</li>
</ul>
</li>
</ol>
</li>
<li>
<p>문제점 : A,B 함수에 C++객체가 존재할 경우 C함수에서 ExitThread 함수로 종료시 A,B 함수의 소멸자가 호출되지 않아서
메모리 유출현상이 발생되므로 가급적이면 쓰지 않고 Return 되도록 해야한다.</p>
</li>
<li>
<p>ExitThread &#x26; TerminateThread 차이점</p>
<ul>
<li>
<p>VOID ExitThread(DWORD dwExitCode) / BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)</p>
<ol>
<li>
<p>ExitThread : 실행중인 스레드의 특정 위치에서 스레드를 종료</p>
<p>TerminateThread 는 인수로 전달받은 스레드를 강제로 종료시킬 때 사용된다.</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>스레드 중지/재실행</p>
<ul>
<li>
<p>SuspendThread(HANDLE hThread) : 중지카운트 증가</p>
</li>
<li>
<p>ResumeThread(HANDLE hThread) : 중지카운트 감소(0이 될 경우 재실행됨)</p>
</li>
</ul>
</li>
<li>
<p>UI 스레드</p>
<ul>
<li>
<p>작업스레드 : 사용자 눈에 보이지 않고 내부적인 계산만 하고 사라지는 스레드</p>
</li>
<li>
<p>UI 스레드 : 윈도우를 만들고, 메시지 큐와 메시지 루프를 가지는 스레드</p>
</li>
</ul>
</li>
</ul>
<p>예)</p>
<p>RegisterClass(~)</p>
<p>DWORD WINAPI ThreadFunc(LPVOID temp)</p>
<p>{</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">  CreateWindow(~);</code></pre></div>
<p>while(GetMessage(~))</p>
<p>{</p>
<p>TranslateMessage</p>
<p>DispatchMessage</p>
<p>}</p>
<p>}</p>
<p>LRESULT CALLBACK DeCompProc(~)</p>
<p>{</p>
<p>…</p>
<p>}</p>
<ul>
<li>
<p>스레드 우선순위</p>
<ul>
<li>스레디의 우선 순위는 우선 순위 클래스, 우선 순위 레벨 두가지 값의 조합으로 결정함.</li>
</ul>
<ol>
<li>
<p>우선순위 클래스(프로세스) CreateProcess(6번째 인자 세팅)</p>
<p>DWORD GetPriorityClass(HANDLE hProcess);</p>
<p>BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass);</p>
</li>
<li>
<p>우선순위 스레드(스레드)</p>
<p>int GetThreadPriority(HANDLE hThread);</p>
<p>BOOL SeThreadPriority(HAND hThread, int nPriority)</p>
</li>
</ol>
</li>
<li>
<p>C런타임 라이브러리</p>
</li>
</ul>
<ul>
<li>C,C++ 코드로 작성하는 경우 WINAPI 제공하는 CreateThread 사용은 문제가 생길 수 있으므로 _beginThreadex, _endthreadex 써야함.</li>
</ul>
<ol>
<li>
<p>_beginthread, _beginthreadex 차이점</p>
<p>_beingthread는 새로운 스레드 생성하고 난 후 내부적으로 CloseHandle 함수 호출되서 생성된 스레드 핸들러 제거시킴</p>
<p>_beingthreadex 핸들을 리턴(형변환 해야함), CloseHandle 함수가 내부호출을 안하므로 명시적으로 함수를 호출해 줘야한다.</p>
</li>
</ol>
<p>예)</p>
<p>unsigned __stdcall SecondThreadFunc(void *pArg)</p>
<p>{</p>
<p>~</p>
<p>_endthreadex(0);</p>
<p>}</p>
<p>void main()</p>
<p>{</p>
<p>HANDLE hThread;</p>
<p>hThread = (HANDLE)_beginthreadex(NULL, 0, SecondThreadFunc, null, 0, &#x26;threadID);</p>
<p>CloseHandle(hThread);</p>
<p>}</p>
<ul>
<li>TLS(스레드 지역 저장소)</li>
</ul>
<ol>
<li>TLS(Thread Local Storage)</li>
</ol>
<ul>
<li>전역변수나 정적변수에 스레드가 공유하는 문제점을 해결하기 위해서 나오게 되었음</li>
</ul>
<ol start="2">
<li>TLS 함수</li>
</ol>
<ul>
<li>
<p>인덱스 값 얻어오기(슬롯 할당) / 슬롯 해제하기</p>
<p>TlsIndex= TlsAlloc(); TlsFree(TlsIndex);</p>
</li>
<li>
<p>슬롯에 값 세팅 / 슬롯 값 얻어오기</p>
<p>TlsSetValue(TlsIndex, (LPVOID)0); tcount=(int)TlsGetValue(TlsIndex)+1;</p>
</li>
</ul>
<ul>
<li>
<p>동기화</p>
<ul>
<li>복수 개의 스레드가 보조를 맞추어 실행하도록 함으로써 경쟁 상태나 교착상태를 해소하는 것</li>
</ul>
</li>
</ul>
<ol>
<li>DeadLock(교착상태) - 대기 상태가 종료되지 않아 무한정 대기만 하는 비정상적인 상태</li>
</ol>
<p>ThreadFunc1</p>
<p>EnterCriticalSection(&#x26;crit1); - 1</p>
<p>EnterCriticalSection(&#x26;crit2); - 3</p>
<p>LeaveCriticalSection(&#x26;crit2);</p>
<p>LeaveCriticalSection(&#x26;crit1);</p>
<p>ThreadFunc2</p>
<p>EnterCriticalSection(&#x26;crit2);</p>
<p>EnterCriticalSection(&#x26;crit1); - 2</p>
<p>LeaveCriticalSection(&#x26;crit1);</p>
<p>LeaveCriticalSection(&#x26;crit2);</p>
<ol start="2">
<li>
<p>크리티컬 섹션/ 뮤텍스/ 세마포어 차이점</p>
<ol>
<li>
<p>크리티컬 섹션 : 유저모드 객체, 가볍고 빠르다.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                   같은 Process 내의 Thread 동기화 지원</code></pre></div>
</li>
<li>
<p>뮤텍스, 세마포어 : 커널모드 객체, 상대적으로 무겁고 느린편</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                       여러 Process의 Thread간의 동기화를 지원</code></pre></div>
</li>
<li>
<p>뮤텍스, 세마포어 차이점 : 뮤텍스는 임계구역 접근 Thread는 한개</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">                                 세마포어 임계구역 접근 Thread 갯수 조절</code></pre></div>
</li>
</ol>
</li>
<li>
<p>CriticalSection(임계영역)</p>
<ul>
<li>
<p>중단해서는 안되는 코드 블록</p>
</li>
<li>
<p>CRITICAL_SECTION 함수</p>
<ol>
<li>
<p>InitializeCriticalSection, DeleteCriticalSection - 초기화 / 파괴</p>
</li>
<li>
<p>EnterCriticalSection, LeaveCriticalSection - 구간의 시작을 명시 / 섹션을 빠져나올 구간</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>뮤텍스</p>
<ul>
<li>
<p>WaitForSingleObject, WaitForMultiIObject</p>
</li>
<li>
<p>CreateMutex, OpenMutex, ReleaseMutex</p>
</li>
</ul>
</li>
<li>
<p>세마포어</p>
</li>
</ol>
<ul>
<li>CreateSemaphore, OpenSemaphore, ReleaseSemaphore
CreateSemaphore 2번째 인자 : 임계영역 갯수, 3번째 인자 : 임계영역 접근 갯수</li>
</ul>
<ol start="4">
<li>이벤트</li>
</ol>
<ul>
<li>CreateEvent, OpenEvent, SetEvent, ResetEvent
<ol>
<li>2번째 인자
TRUE : 수동리셋 이벤트 FALSE 자동리셋 이벤트</li>
<li>3번째 인자
TRUE : 이벤트를 생성함과 동시에 신호상태를 만든다.</li>
</ol>
</li>
</ul>
<h1 id="동적링크라이브러리" style="position:relative;"><a href="#%EB%8F%99%EC%A0%81%EB%A7%81%ED%81%AC%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC" aria-label="동적링크라이브러리 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>동적링크라이브러리</h1>
<ul>
<li>
<p>정적링크 &#x26; 동적링크</p>
</li>
<li>
<p>DLL 사용 장점</p>
</li>
</ul>
<ol>
<li>
<p>여러 프로그램이 동시에 사용하기 때문에 메모리 절약</p>
</li>
<li>
<p>DLL을 사용하는 프로그램은 크기가 작다.(정정링크 실행파일이 커진다.)</p>
</li>
<li>
<p>DLL을 교체하여 프로그램의 성능을 향상시키기 쉽다.(교체시 DLL만 바꾸면됨)</p>
</li>
<li>
<p>리소스 교체가 가능(다국어버전)</p>
</li>
<li>
<p>디버깅 용이(DLL 버그 없다는 것을 가정)</p>
</li>
<li>
<p>혼합 프로그래밍 가능(어떤 개발툴과도 호환가능)</p>
</li>
<li>
<p>프로그래머끼리 분담 작업이 용이하며 재사용도 뛰어나다</p>
</li>
</ol>
<ul>
<li>DLL 사용단점</li>
</ul>
<ol>
<li>
<p>DLL 없다거나 손상된 경우 실행이 불가능</p>
</li>
<li>
<p>DLL 버전 변경 시 프로그램 호환이 안될 경우 발생</p>
</li>
</ol>
<ul>
<li>DLL Export 되는 함수 / DLL Import 하는 함수</li>
</ul>
<ol>
<li>
<p>extern “C” **declspec(dllexport) 함수 원형 -**declspec : 함수에 대한 정보를 제공</p>
<p>extern “C” __declspec(dllimport) 함수 원형</p>
</li>
</ol>
<ul>
<li>임포트 라이브러리 : 실제 코드는 없고 함수에 대한 위치 정보만 저장함.</li>
</ul>
<ul>
<li>
<p>DLL 파일 찾는 순서</p>
<p>=1. 클라이언트 프로그램이 포함된 디렉토리</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"> 2. 프로그램의 현재 디렉토리

 3. 윈도우즈의 시스템 디렉토리

 4. 윈도우즈 디렉토리

 5. PATH 환경 변수가 지정하는 모든 디렉토리</code></pre></div>
</li>
</ul>
<ul>
<li>
<p>임포트 라이브러리 지정 : #pragma comment(lib, “MyDll.lib”)</p>
</li>
<li>
<p>명시적 연결(DLL을 명시적으로 읽고 사용)</p>
<ol>
<li>
<p>HINSTANCE LoadLibrary(LPCTSTR lpLibFileName)</p>
</li>
<li>
<p>FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)</p>
</li>
</ol>
<p>hInst = LoadLibrary(TEXT(“MyDll.dll”));</p>
<p>pFunc = (int (*)(int, int))GetProcAddress(hInst,“AddInteger”);</p>
</li>
<li>
<p>명시적 연결 장/단점</p>
<ol>
<li>
<p>필요할 때만 DLL을 읽어와 사용하기 때문에 메모리와 리소스가 절약된다.</p>
</li>
<li>
<p>사용할 DLL을 교체(DLL 이름만 상황에 맞게 교체)</p>
</li>
<li>
<p>필요한 DLL이 없는 경우에도 프로그램 실행가능</p>
</li>
<li>
<p>클라이언트 프로그램 시작이 빠르다.</p>
</li>
</ol>
<p>단점 : 함수 호출 속도가 느려진다.</p>
</li>
<li>
<p>DllMain 함수</p>
<p>BOOL WINAPI DllMain(HINSTANCE hInst, DWORD fdwReason, LPVOID lpRes);</p>
<p>-DLL이 처음 메모리에 올라오고 제거시에 위 함수가 호출됨.</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">fdwReason : 함수가 호출된 이유

1) DLL_PROCESS_ATTACH / DLL_PROCESS_DETACH

    DLL_THREAD_ATTACH / DLL_THREAD_DETACH</code></pre></div>
</li>
</ul>
<h1 id="메모리" style="position:relative;"><a href="#%EB%A9%94%EB%AA%A8%EB%A6%AC" aria-label="메모리 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>메모리</h1>
<ul>
<li>
<p>C 런타임 함수 ( 물리적인 메모리 소비)</p>
<ul>
<li>
<p>void *malloc(size_t size);</p>
<p>void *calloc(size_t num, size_t size); // 필요한 메모리 양을 논리적으로 표현</p>
<p>void *realloc (void *memblock, size_t size); // 이미 할당한 메모리를 더 크게 할당하고 축소할 때</p>
<p>void free(void* memblock);</p>
</li>
</ul>
</li>
<li>
<p>가상메모리 할당</p>
<ol>
<li>장점</li>
</ol>
<ul>
<li>
<p>메모리 예약 할당 가능( 물리메모리 소비하지 않으면서 할당가능)</p>
</li>
<li>
<p>할당한 메모의 액세스 권한 설정가능</p>
</li>
</ul>
</li>
</ul>
<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">  LPVOID VirtualAlloc(LPVOID lpAdress, DWORD dwSize, DWORD flallocationType, DWORD flProtect);

  BOOL VirtualFree(LPVOID lpAddress, DOWRD dwSize, DWORD dwFreeType);

  ptr = (int*)VirtualAlloc(NULL, sizeof(int)*10, MEM_RESERVE|MEM_COMMT, PAGE_REDWRITE);

  wsprintf(str &quot;%d&quot;, ptr[i]*i*2);

  TextOut(hdc, 10, i\*20, str, lstrlen(str));

  VirtualFree(ptr, sizeof(int)\*10, MEM_DECOMMIT);

  VirtualFree(ptr, 0, MEM_RELEASE);</code></pre></div>
<h1 id="동기화" style="position:relative;"><a href="#%EB%8F%99%EA%B8%B0%ED%99%94" aria-label="동기화 permalink" class="custom-class before"><svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>동기화</h1>
<ol>
<li>동기화 필요성</li>
</ol>
<ul>
<li>단일 프로세서를 이용한 선점형 멀티스레딩 시스템은 여러개의 스레드가 마치 동시에 수행되는 것처럼 보이지만 오직 하나의 스레드만 실행됨 그럴때 공유자원에 대한 스레드의 선점에 문제가 발생하는 것을 해결하기 위해서 동기화가 필요해졌다.</li>
</ul>
<ol start="2">
<li>동기화함수</li>
</ol>
<ol>
<li>
<p>크리티컬 세션 : 유저레벨 동기화(커널 객체x), 동일한 프로세스내에서만 사용, 속도 높음</p>
</li>
<li>
<p>뮤텍스 : 커널객체 사용(CreateMutex, OpenMutex, ReleaseMutex, CloseHandle), 하나의 공유자원 보호</p>
<ul>
<li>포기된 뮤텍스 : 뮤텍스 점유 중 스레드를 죽이는 Terminatethread, ExitThread 사용할 경우 -waitforsingleobject return 값이 WAIT_ABANDONED 리턴함.</li>
</ul>
</li>
<li>
<p>세마포어 : 사용가능한 자원의 갯수를 카운트 하는 동기화 객체( CreateSemaphore, OpenSemaphore, ReleaseSemaphore)</p>
</li>
</ol>
<ol start="3">
<li>이벤트</li>
</ol>
<ol>
<li>
<p>스레드간의 작업순서나 시기조정, 신호를 보냄</p>
</li>
<li>
<p>CreateEvent(. bManualReset,,) bManualReset = True 수동(ResetEvent, SetEvent 사용해야함) False 자동</p>
</li>
</ol></article><section class="PostContent__PostNavigator-sc-9jovib-6 caxlE"><a href="/blog/2020/02/2020-02-17-c-c++/"><h5>이전글</h5><i>← </i>C/C++</a><a href="/blog/2020/02/2020-02-14-mssql/"><h5>다음글</h5>MSSQL<i> →</i></a></section><div></div></div><aside class="PostContent__TocRenderer-sc-9jovib-4 bOdkMk"><ul>
<li><a href="#windows-programming">windows programming</a></li>
<li><a href="#%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C">유니코드</a></li>
<li><a href="#%EC%9C%88%EB%8F%84%EC%9A%B0%EC%A6%88%EC%99%80-%EB%A9%94%EC%8B%9C%EC%A7%80">윈도우즈와 메시지</a></li>
<li><a href="#%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%B6%9C%EB%A0%A5">텍스트 출력</a></li>
<li><a href="#%EA%B7%B8%EB%A6%AC%EA%B8%B0-%EA%B8%B0%EC%B4%88">그리기 기초</a></li>
<li><a href="#%ED%82%A4%EB%B3%B4%EB%93%9C">키보드</a></li>
<li><a href="#%EB%A7%88%EC%9A%B0%EC%8A%A4">마우스</a></li>
<li><a href="#%ED%83%80%EC%9D%B4%EB%A8%B8">타이머</a></li>
<li><a href="#%EC%9E%90%EC%8B%9D-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4">자식 윈도우 컨트롤</a></li>
<li><a href="#%EB%A9%94%EB%89%B4%EC%99%80-%EA%B7%B8%EB%B0%96%EC%97%90-%EB%A6%AC%EC%86%8C%EC%8A%A4">메뉴와 그밖에 리소스</a></li>
<li><a href="#%EB%8C%80%ED%99%94%EC%83%81%EC%9E%90">대화상자</a></li>
<li><a href="#%ED%81%B4%EB%A6%BD%EB%B3%B4%EB%93%9C">클립보드</a></li>
<li><a href="#%ED%94%84%EB%A6%B0%ED%84%B0">프린터</a></li>
<li><a href="#%EB%B9%84%ED%8A%B8%EB%A7%B5%EA%B3%BC-bitblt%ED%95%A8%EC%88%98">비트맵과 Bitblt함수</a></li>
<li><a href="#%EC%9E%A5%EC%B9%98%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%B8%EB%B9%84%ED%8A%B8%EB%A7%B5">장치독립적인비트맵</a></li>
<li><a href="#%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80-%ED%8F%B0%ED%8A%B8">텍스트와 폰트</a></li>
<li><a href="#%EB%8B%A4%EC%A4%91%EB%AC%B8%EC%84%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">다중문서 인터페이스</a></li>
<li><a href="#%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9%EA%B3%BC-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9--%EB%8F%99%EA%B8%B0%ED%99%94">멀티태스킹과 멀티스레딩 &#x26; 동기화</a></li>
<li><a href="#%EB%8F%99%EC%A0%81%EB%A7%81%ED%81%AC%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC">동적링크라이브러리</a></li>
<li><a href="#%EB%A9%94%EB%AA%A8%EB%A6%AC">메모리</a></li>
<li><a href="#%EB%8F%99%EA%B8%B0%ED%99%94">동기화</a></li>
</ul></aside></div><div class="Footer__FooterWrapper-sc-rphy7j-0 hyIhte">Thank You for Visiting My Blog,<br/>© 2021 Developer SeungAh, Powered By Gatsby.</div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blog/2020/02/2020-02-16-winapi/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-22cf0ba388c607f9ddfe.js\"],\"component---src-components-templates-post-template-tsx\":[\"/component---src-components-templates-post-template-tsx-b7af14bd68ed907e6180.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-4d52495227296e18c78a.js\"],\"component---src-pages-about-tsx\":[\"/component---src-pages-about-tsx-ed4d3b150f6b0138dbea.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-95992269d7f74c02239a.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="2b7fe9b38746c3e5ad07";</script><script src="/webpack-runtime-df97f00c49f6fd93e26f.js" async></script><script src="/framework-a96385c61229616bc6a1.js" async></script><script src="/app-22cf0ba388c607f9ddfe.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>