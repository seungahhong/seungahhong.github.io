{"componentChunkName":"component---src-components-templates-post-template-tsx","path":"/blog/2020/02/2020-02-16-winapi/","result":{"data":{"site":{"siteMetadata":{"title":"홍승아 기술 블로그","description":"홍승아 기술 블로그에 오신걸 환영합니다.","author":"홍승아","type":"website","siteUrl":"https://seungahhong.github.io","social":{"facebook":"https://www.facebook.com/people/%ED%99%8D%EC%8A%B9%EC%95%84/100002349562000/","github":"https://github.com/seungahhong","notion":"https://material-debt-c1c.notion.site/daa60481e37840ea9e1b7e1b12269942","linkedin":"https://www.linkedin.com/in/seungahhong/"}}},"allFile":{"edges":[{"node":{"name":"github","publicURL":"/static/4a6687a74051de2b3536e95d0b6c992a/github.svg","childImageSharp":null}},{"node":{"name":"facebook","publicURL":"/static/b185e9b61bb465d92b14ed1c9a9ded61/facebook.svg","childImageSharp":null}},{"node":{"name":"linkedin","publicURL":"/static/3dc9e0d0f748678205218f1c72941cc2/linkedin.svg","childImageSharp":null}},{"node":{"name":"notion","publicURL":"/static/19b0f81386812ed2f2f3a7aea202935f/notion.svg","childImageSharp":null}},{"node":{"name":"background","publicURL":"/static/77f5c833c2343c992fd263c780495905/background.jpg","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAjABQDASIAAhEBAxEB/8QAGwABAAEFAQAAAAAAAAAAAAAAAAcEBggJCgX/xAAXAQEBAQEAAAAAAAAAAAAAAAAHBQYI/9oADAMBAAIQAxAAAAG5fRl7U4Ddg9LblwJg9mPTTxjbDu2KyVVZmqWuNuZyEMin/wD/xAAcEAADAQEBAAMAAAAAAAAAAAADBAUGAgcAARb/2gAIAQEAAQUCocsCqedUserp/wBPHH8jrdcIUUCzly6d9kvsIW5VVVRpQmuEKvdas00RPa7ztxVPfbJZDS1qT9pMnf30lSbAH//EACYRAAIBAgYBBAMAAAAAAAAAAAECAwQRAAUGEiEiURUjJDEyQWH/2gAIAQMBAT8Bzv5dFVU/uOqwNDUzQtZ5I5I5Cw3LwrSlW3MlnQv1Kk3I0npF+3q1dz5y/MOLWG3lr9fxH8Axnea1WXZnSUNRX08GXSVirDBIIxJJU7WXsZS14nXmMohJkSVS0bKRMuvKG3WPLI1+lSSirEkCg2G9UfarW5IH0f0Dxitmmk1PvklkdzqqMl3dmYlaqqRTuJJuqkqPCmw4xFGhjQlEJKgklQST5Jtj/8QAJREAAgEDAwQCAwAAAAAAAAAAAQIDBBESBSEiAAYTMRRRIzJB/9oACAECAQE/Ae1JFnkdPKKaSJ6b42KoyySCQKZGV8hIo2Zl2BV25C11v3Iu2NGP6cVpCtzYkg7fsTf0PfrrQaWOv0RsKKSerpaYg1NN5eNOHGCgxGLGpSzK4Zx+PBhlkTEmga9EiRqlVZERR4a+hMQsq8YzJBmUU8VyubD217mijSPRI0jRY0GjiyIoVReGFjxUAbnc/Z36lVfI/Fff0Ov/xAAnEAACAgIBAwMFAQEAAAAAAAACAwEEBRIRABMhFCIjBhUxMkEzQv/aAAgBAQAGPwK6haou0UFLaxMVvXbjsnEOhRDx/mLSZA8SJLIp0kJiOIN1ux6qp3Jp4744r3LUEJahcOB3aLI+NZiLHCPCzaXtL5N0tbAtaonVAYszGPawGWlkJ6wMz7Y8TE/mZ6mMuEVFgtoMKzPaBkysglEsOQEhktpAIOC4ITVO4dZB5bxMXAq1ZmDBczEtdLmP/bxAQCBDUjOJZ3Q7fBMbcRzZkvlYwmbunWC7xbq2nuc88z+0e7meeeqH1LFmweGysIpWVy9p1aOTAfEwki7SBtpiHrKBHl6nrjzrzSr/AFLinRTy2O9fi6EZ6vVX6w8hX+2NYu/DAxmSTDoKiu8sStLddMlxsA9W7f1JlalDLcJr2KmftprZJA1lClK2AK0gYAoAFbljK3DHcAzgtuk2LnpTwaqbrZ22optGL2MkbaeHXEvTVf2YYyswEy8LSAFJAZj04U/eJydx9Aq966JhaJ+NriijaymQkPZXfdgspkBSveWuawobzwFC5coY7IFm6isusKWU7I48GbUjpPQ+u0q9grNGxfJMTCxC8vQeJ2K4Ny494VnenrqIuEJUGpQK0DqkfdOxFAbmXuMiLz0JTPMzERPMDPjYv5Mcfz+dQAEmY8T8tSo8vKw/7ehh6x+BHbUY8DER1//EABgQAQEBAQEAAAAAAAAAAAAAAAERACEx/9oACAEBAAE/IbjsjUQRDOG9yM8H6LHI1AF3hlR4BZJXKJMAACir473dyInWJOxmpkMQVQyHcnAdNamkCXWEAXfdQjTuahHixtYFU0pQAeZZgBWyPe+FR7akoVqS8vRqyotR0D6hilumzYosaSmxtobuIHifhRG0qHV6ADEvZwQQODoHg26va3vwzkwOFw+G/9oADAMBAAIAAwAAABCXI3JwL//EABgRAQEBAQEAAAAAAAAAAAAAAAERIQBR/9oACAEDAQE/EHVZhUihLRqkO8CCpiJbbqCaOqvbbsrimolDvsLCAEV0QgdoxxETJNt6DzBak1rJJOTOQCBVCVXVVV17/8QAGhEBAQEBAAMAAAAAAAAAAAAAAREhADFhkf/aAAgBAgEBPxCdZEzDipJRYSdhRs8DCKDVDaK1Cpytj88Ix2j+p65EH8wCDqRIkDLkWSkDjoBM4JqrvLRZWqsrmrPR87//xAAYEAEBAQEBAAAAAAAAAAAAAAABEQAhMf/aAAgBAQABPxBCvOwQu7PBe3aLTISCyfpEzgoKtriaxgWDxMzHb6d+Bd6TsASFFvYtFa9FIPaEtI3sbizgSsxk2P2s9d12ptjbwWm2LYGMjAp2NKChKJmGwzNWyYEVqx80qLWAlWnhTgQBmZsmRhBMOyzEJshRGqitlRChJ6SsgOcmYx4ScH8i4H//2Q=="},"images":{"fallback":{"src":"/static/77f5c833c2343c992fd263c780495905/c2a83/background.jpg","srcSet":"/static/77f5c833c2343c992fd263c780495905/9330e/background.jpg 139w,\n/static/77f5c833c2343c992fd263c780495905/53b4d/background.jpg 278w,\n/static/77f5c833c2343c992fd263c780495905/c2a83/background.jpg 555w","sizes":"(min-width: 555px) 555px, 100vw"},"sources":[{"srcSet":"/static/77f5c833c2343c992fd263c780495905/3ee68/background.webp 139w,\n/static/77f5c833c2343c992fd263c780495905/d0ff1/background.webp 278w,\n/static/77f5c833c2343c992fd263c780495905/21b9c/background.webp 555w","type":"image/webp","sizes":"(min-width: 555px) 555px, 100vw"}]},"width":555,"height":961}}}}]},"allMarkdownRemark":{"edges":[{"node":{"html":"<h1 id=\"windows-programming\" style=\"position:relative;\"><a href=\"#windows-programming\" aria-label=\"windows programming permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>windows programming</h1>\n<ul>\n<li>\n<p>윈도우즈의 장점</p>\n<ol>\n<li>그래픽 기반의 운영체제</li>\n</ol>\n<ul>\n<li>화면 처리를 문자 단위가 아닌 디지털 표현의 최소 단위인 픽셀로 처리해서 화면 처리 가능</li>\n</ul>\n<ol start=\"2\">\n<li>멀티 태스킹이 가능하다.</li>\n</ol>\n<ul>\n<li>한번에 여러가지 일을 수행함.</li>\n</ul>\n<ol start=\"3\">\n<li>장치에 영향을 받지 않는다.</li>\n</ol>\n<ul>\n<li>디바이스 드라이버에 의해 주변 장치들을 제어하고 관리한다. 장치가 바뀌면 디바이스 드라이버만 교체해주면 되고 소프트웨어는\n이에 영향을 받지 않는다.</li>\n</ul>\n<ol start=\"4\">\n<li>일관성</li>\n</ol>\n<ul>\n<li>인터페이스 구성이 표준화됨에 따라서 한 번 배우기만 하면 어떤 프로그램이든지 유사한 방법으로 사용 가능함.</li>\n</ul>\n</li>\n<li>\n<p>윈도우즈 프로그램을 링크하여 실행 파일을 생성할 때는 개발 환경에서 제공하는 특별한 ‘임포트 라이브러리’와 링크해야 한다. 임포트</p>\n<p>라이브러리에는 DLL 이름과 더불어 프로그램이 사용하는 모든 윈도우즈 함수 호출을 위한 참조 정보가 들어 있다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>임포트 라이브러리 확인 : Project - Setting - Link Tab에서 확인가능</p>\n</li>\n<li>\n<p>링커는 이 정보를 토대로 실행 파일(.EXE) 안에 테이블을 생성하고, 윈도우즈는 프로그램을 로드할 때 이 테이블 정보를 수정하여 실제</p>\n<p>윈도우즈 함수를 호출 할 수 있다.</p>\n</li>\n</ul>\n<p>#include &#x3C;windows.h></p>\n<p>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,\nPSTR szCmdLine, int iCmdShow)\n{\nMessageBox(NULL, TEXT(“Hello Windows!”), TEXT(“HelloMsg”), 0);</p>\n<p>return 0;\n}</p>\n<ul>\n<li>헤더파일(#include &#x3C;windows.h>)</li>\n</ul>\n<ol>\n<li>\n<p>WINDEF.H : 기본 타입 정의</p>\n</li>\n<li>\n<p>WINNT.H : 유니코드 지원을 위한 타입 정의</p>\n</li>\n<li>\n<p>WINBASE.H : Kernel 함수</p>\n</li>\n<li>\n<p>WINUSER.H : 사용자 인터페이스 함수</p>\n</li>\n<li>\n<p>WINGDI.H : 그래픽 장치 인터페이스 함수</p>\n</li>\n</ol>\n<ul>\n<li>프로그램 진입점</li>\n</ul>\n<p>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,\nPSTR szCmdLine, int iCmdShow)</p>\n<ol>\n<li>#define WINAPI __stdcall</li>\n</ol>\n<ul>\n<li>컴파일, 링크, 실행</li>\n</ul>\n<ol>\n<li>\n<p>컴파일 단계에서 컴파일러는 C소스 코드 파일로부터 .OBJ 파일을 생성한다.</p>\n</li>\n<li>\n<p>링크 단계에 링커는 .OBJ 파일과 .LIB 파일을 겹합하여 .EXE 파일을 만든다.</p>\n</li>\n</ol>\n<p>-KERNEL32.LIB, USER32.LIB, GDI32.LIB 파일은 윈도우즈 서브시스템을 사용하기 위한 ‘임포트 라이브러리’임.</p>\n<ol start=\"3\">\n<li>비주얼 C++에서는 Debug, Release 환경 설정을 이용해서 프로그램을 컴파일 및 링크할 수 있다.</li>\n</ol>\n<h1 id=\"유니코드\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C\" aria-label=\"유니코드 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유니코드</h1>\n<ul>\n<li>유니코드와 DBCS 차이점</li>\n</ul>\n<ul>\n<li>\n<p>유니코드는 와이드 문자(16비트)를 항상 사용한다(8비트 문자는 아무 의미가 없다.)</p>\n</li>\n<li>\n<p>DBCS(Double Byte Character set)는 여전히 8비트 값을 나타낸다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>와이드 문자와 윈도우즈</p>\n<ol>\n<li>윈도우즈 헤더 파일 타입</li>\n</ol>\n<ul>\n<li>\n<p>typedef char CHAR;</p>\n</li>\n<li>\n<p>typedef wchar_t WCHAR;</p>\n</li>\n</ul>\n<ol>\n<li>8비트 문자열</li>\n</ol>\n<p>typedef CHAR *PCHAR;\ntypedef CHAR *LPCH, *PCH;</p>\n<p>typedef CHAR *NPSTR;\ntypedef CHAR *LPSTR, *PSTR;</p>\n<p>typedef CONST CHAR *LPCCH, *PCCH;</p>\n<p>typedef CONST CHAR *LPCSTR, *PCSTR;</p>\n<ol start=\"2\">\n<li>16비트 문자열</li>\n</ol>\n<p>typedef WCHAR *PWCHAR;\ntypedef WCHAR *LPWCH, *PWCH;\ntypedef WCHAR *NWPSTR;\ntypedef WCHAR *LPWSTR, *PWSTR;</p>\n<p>typedef CONST WCHAR *LPCWSTR, *PCWSTR;</p>\n<p>typedef CONST WCHAR *LPCWCH, *PCWCH;</p>\n</li>\n<li>\n<p>윈도우즈 함수 호출 : UNICODE 식별자 정의에 따라 다른 MessageBox 호출됨.</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>int WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT)</p>\n<ul>\n<li>WINUSERAPI int WINAPI MessageBoxA(HWND hWnd , LPCSTR lpText, LPCSTR lpCaption, UINT uType);\nWINUSERAPI int WINAPI MessageBoxW(HWND hWnd , LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);\n#ifdef UNICODE\n#define MessageBox MessageBoxW\n#else\n#define MessageBox MessageBoxA\n#endif // !UNICODE</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>윈도우즈의 문자열: UNICODE 식별자 정의에 따라 다른 문자열 함수가 호출됨.</li>\n</ul>\n<p>WINBASEAPI int WINAPI lstrlenA( LPCSTR lpString );\nWINBASEAPI int WINAPI lstrlenW( LPCWSTR lpString );\n#ifdef UNICODE\n#define lstrlen lstrlenW\n#else\n#define lstrlen lstrlenA\n#endif // !UNICODE</p>\n<ul>\n<li>윈도우즈에서 printf 사용하기</li>\n</ul>\n<h1 id=\"윈도우즈와-메시지\" style=\"position:relative;\"><a href=\"#%EC%9C%88%EB%8F%84%EC%9A%B0%EC%A6%88%EC%99%80-%EB%A9%94%EC%8B%9C%EC%A7%80\" aria-label=\"윈도우즈와 메시지 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>윈도우즈와 메시지</h1>\n<p>// hInstance : 인스턴스 핸들, hPrevInstance : WIN16와 호환성을 위해 남겨둠,</p>\n<p>// lpCmdLine : 프로그램에 전달되는 명령행 인자, nCmdShow : 처음 뜰 때 메인 윈도우 화면에 표시하는 방법(SW_SHOWNOMAL 등)</p>\n<p>#include &#x3C;windows.h></p>\n<p>LRESULT CALLBACK WndProc(HWND,UINT,WPARAM,LPARAM);\nHINSTANCE g_hInst;\nLPCTSTR lpszClass=TEXT(“First”);</p>\n<p>int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance\n,LPSTR lpszCmdParam,int nCmdShow)\n{\nHWND hWnd;\nMSG Message;\nWNDCLASS WndClass;\ng_hInst=hInstance;</p>\n<p>WndClass.cbClsExtra=0;\nWndClass.cbWndExtra=0;\nWndClass.hbrBackground=(HBRUSH)GetStockObject(WHITE_BRUSH);\nWndClass.hCursor=LoadCursor(NULL,IDC_ARROW);\nWndClass.hIcon=LoadIcon(NULL,IDI_APPLICATION);\nWndClass.hInstance=hInstance;\nWndClass.lpfnWndProc=WndProc;\nWndClass.lpszClassName=lpszClass;\nWndClass.lpszMenuName=NULL;\nWndClass.style=CS_HREDRAW | CS_VREDRAW; //윈도우 사이즈 변경시 WM_PAINT 호출\nRegisterClass(&#x26;WndClass);</p>\n<p>hWnd=CreateWindow(lpszClass,lpszClass,WS_OVERLAPPEDWINDOW,\nCW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,\nNULL,(HMENU)NULL,hInstance,NULL);\n1번째 : 윈도우 클래스 이름을 나타내는 포인터</p>\n<p>2번째 : 윈도우 이름을 나타내는 포인터</p>\n<p>3번째 : 윈도우 스타일</p>\n<ul>\n<li>\n<p>WS_OVERLAPPEDWINDOW : WS_OVERLAPPED, WS_CAPTION, WS_SYSMENU,WS_THICKFRAME,WS_MINIMIZEBOX,</p>\n<p>WS_MAXIMIZEBOX 속성을 모두 갖는 윈도우를 생성한다.</p>\n</li>\n<li>\n<p>4번째 : 시스템이 적절한 디폴트 위치에 윈도우를 생성</p>\n</li>\n</ul>\n<p>ShowWindow(hWnd,nCmdShow);</p>\n<p>UpdateWindow(hWnd);</p>\n<p>while (GetMessage(&#x26;Message,NULL,0,0)) {\nTranslateMessage(&#x26;Message);\nDispatchMessage(&#x26;Message);\n}\nreturn (int)Message.wParam;\n}</p>\n<p>LRESULT CALLBACK WndProc(HWND hWnd,UINT iMessage,WPARAM wParam,LPARAM lParam)\n{\nswitch (iMessage) {\ncase WM_DESTROY:\nPostQuitMessage(0);\nreturn 0;\n}\nreturn(DefWindowProc(hWnd,iMessage,wParam,lParam));\n}</p>\n<ul>\n<li>\n<p>윈도우 : 사용자로부터 입력을 받거나 텍스트와 그래픽 형태로 출력하는 하면의 직사각형 영역을 말한다.</p>\n</li>\n<li>\n<p>윈도우 종류</p>\n<ul>\n<li>\n<p>애플리케이션 윈도우 : 툴바, 스크롤바</p>\n</li>\n<li>\n<p>대화상자</p>\n</li>\n<li>\n<p>자식윈도우, 컨트롤윈도우, 자식 윈도우 컨트롤 : push button, radio button, check box, list box, scroll bar</p>\n</li>\n</ul>\n</li>\n<li>\n<p>윈도우 프로시저</p>\n</li>\n</ul>\n<p>while(GetMessage(&#x26;msg, NULL, 0, 0))\n{\nTranslateMessage(&#x26;msg);\nDispatchMessage(&#x26;msg);\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 메시지 처리 함수 : 메시지가 발생할 때 프로그램의 반응을 처리하는 일을 하며 WinMain 함수와는 별도로 WndProc이라는 이름으로\n\n                            존재한다.\n\n- WndProc은 WinMain에서 호출하는 것이 아니라 윈도우즈에 의해 호출된다.\n\n- WinMain내의 메시지 루프는 메시지를 메시지 처리 함수로 보내주기만 할 뿐이며 WndProc은 메시지가 입력되면 윈도우즈에 의해\n\n  호출되어 메시지를 처리한다.\n\n- 운영체제에 의해 호출되는 응용 프로그램내의 함수를 콜백(CallBack) 함수라고 한다.\n\n- 메시지 큐에 쌓이지 않고 곧바로 윈도우 프로시저에 전달되는 것은 ?</code></pre></div>\n<ul>\n<li>\n<p>대기 메시지와 비대기 메시지</p>\n<ul>\n<li>\n<p>대기 메시지는 메시지 큐에 쌓인 메시지를 윈도우 프로시저에 전달하고 비대기 메시지는 윈도우즈가 직접 윈도우 프로시저에 전달함.</p>\n</li>\n<li>\n<p>대기메시지 : 주로 사용자의 행위로 인한 결과(WM_KEYDOWN, WM_LBUTTONDOWN 등)</p>\n</li>\n<li>\n<p>비대기메시지 : 특정 윈도우즈 함수를 호출함으로써 종종 발생한다.</p>\n<ol>\n<li>CreateWindow() 호출하면, 윈도우를 생성하고 그 과정에서 윈도우 프로시저에 WM_CREATE 메시지를 보내다.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>윈도우 함수 호출</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>GetStockObject() 그래픽 객체를 얻는다.</p>\n</li>\n<li>\n<p>RegisterClass() 프로그램의 윈도우를 위한 윈도우 클래스를 등록한다.</p>\n</li>\n<li>\n<p>ShowWindow() 윈도우를 화면에 표시한다.</p>\n</li>\n<li>\n<p>UpdateWinow() 윈도우가 자기 자신을 그리도록 명령한다.</p>\n</li>\n<li>\n<p>GetClientRect() 윈도우의 클라이언트 영역 치수를 얻는다.</p>\n</li>\n<li>\n<p>PostQuitMessage() : 메시지 큐에 종료(quit) 메시지를 삽입한다.</p>\n</li>\n<li>\n<p>DetWindowProc() : 메시지에 대한 디폴트 처리를 담당한다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>새로운 데이터 타입</p>\n<ul>\n<li>\n<p>MSG : 메시지 구조체</p>\n</li>\n<li>\n<p>WNDCLASS : 윈도우 클래스 구조체</p>\n</li>\n<li>\n<p>PAINTSTRUCT : 그리기 구조체</p>\n</li>\n<li>\n<p>RECT : 직사각형 구조체</p>\n</li>\n</ul>\n</li>\n<li>\n<p>핸들( 단순히 숫자(흔히 32비트 크기)로서 객체를 참조한다.</p>\n<ul>\n<li>\n<p>HINSTRANCE : 프로그램 자체 인스턴스 핸들</p>\n</li>\n<li>\n<p>HWND : 위도우 핸들</p>\n</li>\n<li>\n<p>HDC : 디바이스 컨텍스트 핸들.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>헝가리안 표기법</p>\n</li>\n<li>\n<p>윈도우 클래스 등록하기(RegisterClass(&#x26;wndclass) // WNDCLASS wndclass;</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>애플리케이션 윈도우를 생성하려면 우선 RegisterClass()를 호출함으로써 윈도우 클래스를 등록해야한다.</p>\n</li>\n<li>\n<p>WNDCLASS ASCII 버전</p>\n</li>\n</ul>\n<p>typedef struct tagWNDCLASSA {\nUINT style;\nWNDPROC lpfnWndProc;\nint cbClsExtra;\nint cbWndExtra;\nHINSTANCE hInstance;\nHICON hIcon;\nHCURSOR hCursor;\nHBRUSH hbrBackground;\nLPCSTR lpszMenuName;\nLPCSTR lpszClassName;\n} WNDCLASSA, *PWNDCLASSA, NEAR *NPWNDCLASSA, FAR *LPWNDCLASSA;</p>\n<ul>\n<li>10개의 필드를 초기화 한후 RegisterClass()를 호출함.</li>\n</ul>\n<ol>\n<li>\n<p>2번째 필드(lpfnWndProc)</p>\n<ul>\n<li>WndProc을 윈도우 클래스의 윈도우 프로시저로 설정한다.</li>\n</ul>\n<p>예) wndclass.lpfnWndProc = WndProc</p>\n<ul>\n<li>WndProc은 이 윈도우 클래스를 기반으로 생성한 모든 윈도우에 전달되는 메시지를 처리한다.</li>\n</ul>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">if(!RegisterClass(&amp;wndclass))\n{\n  MessageBox(NULL, TEXT(&quot;This program requires Windows NT!&quot;), szAppName, MB_ICONERROR);\n\n  return 0;\n}</code></pre></div>\n<p>//프로그램 컴파일시 UNICODE 식별자를 정의하고 WINDOWS NT계열에서 RegisterClassW() 구현되어 있어서 돌아감.</p>\n<p>// 하지만 Windows 0x 계열에서는 RegisterClassW() 구현안되므로 위에 코드처럼 사용자에게 알려주고 0을 리턴하게 함.</p>\n<ul>\n<li>윈도우 생성하기</li>\n</ul>\n<ul>\n<li>윈도우, 윈도우 클래스의 차이</li>\n</ul>\n<p>예) 푸시 버튼 윈도우 공통된 윈도우 클래스와 연관된 윈도우 프로시저는 윈도우즈 내부에 존재함.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    동일한 동작에 대한 정의 : 윈도우 프로시저/ 문자열, 화면위치 변경 등 이런 특성은 윈도우 정의에 일부분으로 설정</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">hwnd = CreateWindow(szAppName, //생성하고자 하는 윈도우의 클래스를 지정하는 문자열\n  TEXT(&quot;The Hello Program&quot;),\n  WS_OVERLAPPEDWINDOW,\n  CW_USEDEFAULT,\n  CW_USEDEFAULT,\n  CW_USEDEFAULT,\n  CW_USEDEFAULT,\n  NULL,\n  NULL,\n  hInstance,\n  NULL);</code></pre></div>\n<p>-CreateWindow는 HWND 타입에 윈도우 핸들을 리턴하고 프로그램들은 핸들을 이용하여 윈도우를 참조할 수 있다</p>\n<ul>\n<li>윈도우 표시하기</li>\n</ul>\n<p>ShowWindow(hwnd, iCmdShow); : 윈도우가 화면에 드러나게 한다.</p>\n<ol>\n<li>\n<p>hwnd : CreateWindow()로 방금 생성한 윈도우 핸들</p>\n</li>\n<li>\n<p>iCmdShow : 초기에 윈도우가 화면에 떠허게 표시될지를 결정함(정상, 최소화, 최대화 중 하나)</p>\n</li>\n<li>\n<p>윈도우 클래스에 지정한 배경 브러시로 윈도우 클라이언트 영역 지워짐</p>\n</li>\n</ol>\n<ul>\n<li>ShowWindow() ,UpdateWindow() 차이점</li>\n</ul>\n<ol>\n<li>\n<p>같은 점 : WM_PAINT 메시지를 윈도우 프로시저로 보냄</p>\n</li>\n<li>\n<p>다른 점 : UpdateWindow를 메시지 큐에 저장하지 않고 바로 윈도우 프로시저로 보냄으로써 윈도우를 빠르게 화면에 출력하게 함.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">        과거에는 컴퓨터 처리속도가 느려서 ShowWindow 하나만 했을 경우에 느리게 나오는 문제가 있어서 UpdateWindow를 쓰게\n\n        되었지만 현재는 컴퓨터 속도이 빨라져서 안써도 상관은 없다.</code></pre></div>\n</li>\n</ol>\n<ul>\n<li>메시지 루프</li>\n</ul>\n<ol>\n<li>\n<p>윈도우즈는 현재 수행되고 있는 각 윈도우즈 프로그램마다 ‘메시지 큐’를 유지한다.</p>\n<p>-입력 이벤트가 발생시 윈도우즈는 이벤트를 ‘메시지로 바꾸어 프로그램의 메시큐에 저장해 둔다.</p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">typedef struct tagMSG {\nHWND hwnd;\nUINT message;\nWPARAM wParam;\nLPARAM lParam;\nDWORD time; // 메시지가 메시지 큐에 들어간 시간\nPOINT pt; // 메시지가 메시지 큐에 들어갈때 좌표.\n} MSG, *PMSG, NEAR *NPMSG, FAR \\*LPMSG;</code></pre></div>\n<ol start=\"2\">\n<li>\n<p>GetMessage(&#x26;msg, NULL, 0, 0) : 메시지 필드가 WM_QUIT이 아니라면 0이 아닌 값을 리턴함. 맞다면 0을 리턴해서 메시지 수신을</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                            못하게 함.</code></pre></div>\n</li>\n</ol>\n<ul>\n<li>\n<p>MSG 구조체 타입 변수인 msg의 포인터를 윈도우즈에 넘겨준다.</p>\n</li>\n<li>\n<p>윈도우즈는 메시지 큐로부터 메시지를 꺼낼 올 때마다 메시지 구조체의 각 필드를 채운다.</p>\n<p>● hwnd : 메시지가 향할 윈도우를 나타내는 핸들.</p>\n<p>● message : 메시지 식별자로서, 메시지를 나타내는 숫자이다. 예) 마우스 왼쪽을 누를시 WM_LBUTTONDOWN 이 된다.</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>TranslateMessage(&#x26;msg)</li>\n</ol>\n<ul>\n<li>\n<p>msg 구조체를 윈도우즈에 넘겨서 키보드 메시지 변환을 한다.</p>\n</li>\n<li>\n<p>WM_KEYDOWN인지와 눌려진 키가 문자키인지 검사하고 조건이 맞을경우 메시지큐에 WM_CHAR 메시지를 만들어서 붙인다.</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>DispatchMessage(&#x26;msg)</li>\n</ol>\n<ul>\n<li>\n<p>msg 구조체를 윈도우즈에 넘기고 윈도우즈는 이 메시지를 적절한 윈도우 프로시저에 보내서 처리하도록 한다.</p>\n<p>이것은 윈도우즈가 윈도우 프로시저를 호출한다는 것이다.</p>\n</li>\n</ul>\n<p>WndProc가 리턴을 해야지 DispatchMessage도 리턴하게 되고 그 이후에 GetMessage로 넘어가게 됨</p>\n<ul>\n<li>윈도우 프로시저</li>\n</ul>\n<ul>\n<li>\n<p>윈도우가 클라이언트 영역에 표시하는 내용과 사용자의 입력에 대한 반응을 결정하는 것을 말한다.</p>\n</li>\n<li>\n<p>MSG 구조체의 처음 필드 네개와 동일하다.</p>\n</li>\n<li>\n<p>프로그램이 간접적으로 자신의 윈도우 프로시저를 호출하기 위해서 SendMessag를 사용할 수 있다.</p>\n</li>\n</ul>\n<ul>\n<li>메시지 처리하기</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n  switch(message)\n  {\n    case WM_DESTROY:\n    PostQuitMessage(0);\n    return 0;\n  }\n  return DefWindowProc(hwnd, message, wParam, lParam);\n}</code></pre></div>\n<ul>\n<li>\n<p>윈도우 프로시저가 받는 모든 메시지는 숫자로 확인할 수 있는데, 이 숫자는 message 매개변수에 전달된다.</p>\n</li>\n<li>\n<p>윈도우 프로시저가 처리하지 않기로 한 메시지는 윈도우즈 함수인 DefWindowProc에 전달해서 디폴트로 처리되도록 해야한다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>WM_PAINT 메시지</p>\n<ul>\n<li>\n<p>윈도우의 클라이언트 영역 일부 또는 전체가 ‘무효’ or ‘갱신’되어야 함을 프로그램에 알리는 역할을 한다.</p>\n</li>\n<li>\n<p>윈도우가 처음 생성될 때는 프로그램이 화면에 아무것도 그리지 않은 상태이므로 클라이언트 영역 저네가 무효화된다.</p>\n</li>\n<li>\n<p>WinMain() : ShowWindow, UpdateWindow를 호출시 윈도우 프로시저에 지시하여 클라이언트 영역에 무언가를 그리게 한다.</p>\n</li>\n</ul>\n<p>예) hdc = BeginPaint(hwnd, &#x26;ps);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  EndPaint(hwnd, &amp;ps);</code></pre></div>\n<ul>\n<li>\n<p>BeginPaint()를 호출했을 때, 윈도우즈는 클라이언트 영역이 아직 지워지지 않았을 경우, 클라이언트 영역의 배경을 지운다.</p>\n<p>배경을 지울 때는 윈도우 클래스를 등록할 때 WNDCLASS 구조체의 hbrBackground 필드로 지정한 브러시를 사용함.</p>\n<p>현재, wndclass.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH); 이므로 흰색으로 칠하게 된다.</p>\n</li>\n<li>\n<p>BeginPaint() 호출은 전체 클라이언트 영역을 유효화하고, 디바이스 컨텍스트 핸들을 리턴한다.</p>\n</li>\n<li>\n<p>디바이스 컨텍스트 : 물리적 출력 장치와 관련 디바이스 드라이버를 통틀어서 나타내는 개념으로 윈도우의 클라이언트 영역에</p>\n<p>텍스트와 그래픽을 출력하기 위해서 디바이스 컨텍스트 핸들이 필요하다.</p>\n</li>\n<li>\n<p>EndPaint()는 디바이스 컨텍스트 핸들을 해제하여 더 이상 유효하지 않게 한다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>WM_DESTROY 메시지</p>\n<ul>\n<li>\n<p>윈도우즈가 사용자에 명령에 따라 윈도우를 파괴하는 중임을 나타낸다. (종료버튼, 시스템 메뉴 - 닫기)</p>\n</li>\n<li>\n<p>PostQuitMessage(0) -메시지 큐에 WM_QUIT 메시지를 삽입</p>\n</li>\n<li>\n<p>return msg.wParam -PostQuitMessage() 에 넘겨준 값(보통 0)이 그대로 들어 있다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>WM_SYSCOMMAND, WM_CLOSE, WM_DESTROY</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>WM_SYSCOMMAND : 창 사용자 (시스템 또는 컨트롤 메뉴 라고도 함)는 창 메뉴에서 명령을 선택 하는 경우에 메시지를 수신 또는</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                            최대화 단추를 선택 하는 경우 최소화 단추, 복원 단추, 닫기 단추 -매개변수에 SC_CLOSE 호출될 경우</code></pre></div>\n</li>\n<li>\n<p>WM_CLOSE : 윈도우가 닫히기 전에 메시지가 전달 된다. 아직 윈도우가 파괴된 것은 아니므로 윈도우가 파괴되는 것을</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                 중간에 제어 할 수 있다. -DestroyWindow() 호출(윈도우 프로시저 : WM_DESTROY 호출)</code></pre></div>\n</li>\n<li>\n<p>WM_DESTROY : 윈도우가 메모리에서 파괴될 때 발생한다. -PostQuitMessage() 호출함으로써 메시키큐에 WM_QUIT 넣고</p>\n</li>\n<li>\n<p>WM_QUIT : 프로그램을 끝낼 때 발생하는 메시지이다. -WinMain()의 메시지 루프가 종료되고 프로그램이 끝난다.</p>\n</li>\n</ol>\n<h1 id=\"텍스트-출력\" style=\"position:relative;\"><a href=\"#%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%B6%9C%EB%A0%A5\" aria-label=\"텍스트 출력 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>텍스트 출력</h1>\n<ul>\n<li>WM_PAINT()</li>\n</ul>\n<ul>\n<li>UpdateWindow() 메시지는 클라이언트 영역을 다시 그려야 함을 윈도우 프로시저에 알린다.</li>\n</ul>\n<ul>\n<li>\n<p>윈도우 프로시저는 다음과 같은 이벤트 중 하나가 발생하면 WM_PAINT 메시지를 처리한다.</p>\n<ul>\n<li>\n<p>사용자가 윈도우를 이동하거나 드러냄으로써 이전에 가려진 윈도우 영역이 드러날때.</p>\n</li>\n<li>\n<p>사용자가 윈도우의 크기를 조정할 때(윈도우 클래스 스타일에 CS_HREDRAW, CS_VREDRAW 비트 설정했을 때)</p>\n</li>\n<li>\n<p>프로그램에서 ScrollWindow() 또는 ScrollDC()를 사용하여 클라이언트 영역의 일부를 스크롤할 때</p>\n</li>\n<li>\n<p>프로그램에서 InvalidateRect() 또는 InvalidateRgn()을 사용하여 명시적으로 WM_PAINT 메시지를 생성할 때</p>\n</li>\n</ul>\n</li>\n<li>\n<p>WM_PAINT 메시지를 큐에 넣는경우</p>\n<ul>\n<li>\n<p>윈도우 위에 놓여 있는 대화상자나 메시지 상자를 윈도우즈가 제거할 때</p>\n</li>\n<li>\n<p>메뉴가 열렸다가 닫혔을 때</p>\n</li>\n<li>\n<p>툴 팁(tool tip)이 표시될 때</p>\n</li>\n</ul>\n</li>\n<li>\n<p>GDI 개요</p>\n</li>\n</ul>\n<ul>\n<li>윈도우의 클라이언트 영역에 무언가를 그리기 위해서는 윈도우즈의 그래픽 장치 인터페이스(Graphics Device Interface,GDI) 함수사용</li>\n</ul>\n<ul>\n<li>디바이스 컨텍스트</li>\n</ul>\n<ul>\n<li>\n<p>디바이스 컨텍스트 핸들은 윈도우가 GDI 함수를 사용하기 위한 일종의 허가증이라고 할 수 있다.</p>\n</li>\n<li>\n<p>CreateDC() 호출로 생성한 디바이스 컨텍스트를 제외하고는, 메시지 한 개를 처리할 때 얻은 디바이스 컨텍스트 핸들을 저장해</p>\n<p>두었다가 다른 메시지를 처리할 때 사용해서는 안된다.</p>\n</li>\n</ul>\n<ul>\n<li>디바이스 컨텍스트 핸들 얻기: 1번째 방법</li>\n</ul>\n<ul>\n<li>\n<p>BeginPaint(), EndPaint()</p>\n<ol>\n<li>\n<p>BeginPaint는 무효 영역의 배경을 지움으로써, 그리기 위한 준비를 한다. Return 값은 디바이스 컨텍스트 핸들이다.</p>\n</li>\n<li>\n<p>WM_PAINT 메시지를 처리하는 동안 반드시 BeginPaint(), EndPaint()를 쌍으로 호출해야함.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>WM_PAINT(), 메시지를 처리하지 않는 경우 메시지를 DdfWindowProc()에 전달해야함.</p>\n</li>\n</ul>\n<p>case WM_PAINT:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> BeginPaint(hwnd, &amp;ps);\n\n EndPaint(hwnd, &amp;ps);\n\n return 0;</code></pre></div>\n<ul>\n<li>\n<p>InvalidateRect() 호출함으로써 클라이언트 영역의 직사각형을 무효화한다면, 마지막 인자로 배경을 지울지 여부를 지정함.</p>\n<p>TRUE : 배경을 지움 / 배경을 지움, FALSE : 배경을 지우지 않음</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>디바이스 컨텍스트 핸들 얻기 : 2번째 방법</p>\n<ul>\n<li>\n<p>GetDC(), ReleaseDC()</p>\n<ol>\n<li>\n<p>GetDC(), RelaseDC()도 쌍으로 호출해야 한다. 메시지를 처리하는 동안 GetDC() 호출된다면 윈도우 프로시저 탈출하기 전에</p>\n<p>반드시 ReleaseDC()를 호출해야한다.</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>hdc = GetDC(hwnd);</p>\n<p>ReleaseDC(hwnd, hdc);</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>GetDC(), GetWindowDC() 차이점</p>\n<p>● GetDC()는 윈도우 클라이언트 영역에 출력할 수 있는 /GetWindowDC() 윈도우 전체에 출력할 수 있는</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                디바이스 컨텍스트 리턴                               디바이스 컨텍스트 핸들 리턴 - 윈도우타이틀바 출력가능</code></pre></div>\n</li>\n</ul>\n<ul>\n<li>\n<p>BeginPaint(), EndPaint() / GetDC(), ReleaseDC() 차이점</p>\n<ol>\n<li>\n<p>BeginPaint, EndPaint는 WM_Paint 메시지를 처리할 때 사용한다. / GetDC, ReleaseDC는 WM_Paint 메시지 이외의 처리</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                                                                       클라이언트 영역 일부를 그릴 때</code></pre></div>\n</li>\n<li>\n<p>WM_PAINT 메시지 루틴에서만 사용 : BeginPaint, EndPaint / DC핸들 얻기 위한 일반적인 방법 : GetDC, ReleaseDC</p>\n<p>( 메시지 내에서 그림 그리기 위한 전문적인 함수)</p>\n</li>\n<li>\n<p>BeginPaint, EndPaint 호출하면 무효영역-유효화 됨 / GetDC, ReleaseDC는 무효 영역을 유효화하지 않음</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                                                        하려면 ValidateRect(hwnd, NULL) 호출해서 영역전체 유효화</code></pre></div>\n</li>\n<li>\n<p>BeginPaint, EndPaint 얻은 디바이스 컨텍스트 핸들의 / GetDC로 얻은 디바이스 컨텍스트 핸들의 디폴트 클리핑 영역은</p>\n<p>디폴트 클리핑 영역은 무효영역 클라이언트 영역이다.</p>\n</li>\n</ol>\n<ul>\n<li>클리핑 영역 : 화면에 보이는 가시영역</li>\n</ul>\n</li>\n<li>\n<p>TextOut() 세부사항&#x3C;TextOut(hdc, 100, 100, TEXT(“HI”), 2);</p>\n<ol>\n<li>\n<p>첫번째 인자는 GetDC(), BeginPaint()의 호출하여 얻은 리턴값</p>\n</li>\n<li>\n<p>2~3번째는 문자열이 출력될 좌표, 4번째는 문자열, 5번째는 문자열의 길이 -TextOut 함수는 널 종료문자열을 사용하지 않음.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                                                                              아스키제어(\\n, \\0등) 사용시 상자나 채워진 블록모양출력</code></pre></div>\n</li>\n</ol>\n</li>\n<li>\n<p>문자 정렬방법 - SetTextAlign(HDC hdc, UINT fMode) : 예) SetTextAlign(hdc, TA_CENTER);</p>\n</li>\n<li>\n<p>글자크기</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>텍스트의 치수를 알아내려면, 디바이스 컨텍스트 핸들을 얻은 후 GetTextMetrics() 호출한다.</p>\n<p>TEXTMETRIC tm;</p>\n<p>hdc = GetDC(hwnd);</p>\n<p>GetTextMetrics(hdc, &#x26;tm);</p>\n<p>ReleaseDC(hwnd, hdc);</p>\n</li>\n<li>\n<p>TEXTMETRIC 구조체는 디바이스 컨텍스트에 현재 선택된 포트에 관한 다양한 정보를 제공한다.</p>\n</li>\n<li>\n<p>시스템 폰트의 치수는 윈도우즈를 다시 부팅되기 전까지는 변하지 않으므로, GetTextMetrics 사용 위치는 윈도우</p>\n<p>프로시저에서 WM_CREATE 메시지를 처리할 때 사용하는게 가장 좋은 위치이다.</p>\n</li>\n</ul>\n<ul>\n<li>GetSystemMetrics</li>\n</ul>\n<p>Windows 응용 프로그램 프로그래밍 인터페이스 (API) 함수 GetSystemMetrics()를 사용 하 여 너비 및 높이 창 디스플레이의 다양한 요소의 얻을 수 있습니다.</p>\n<p>예) int x = GetSystemMetrics(SM_CXSCREEN); Width of screen\nint y = GetSystemMetrics(SM_CYSCREEN); Height of screen</p>\n<ul>\n<li>클라이언트 영역 크기</li>\n</ul>\n<ul>\n<li>\n<p>GetSystemMetrics(), GetClientRect(), WM_SIZE에 lParam이용</p>\n</li>\n<li>\n<p>WM_SIZE : 윈도우의 크기가 변경될때 윈도우 프로시저에 WM_SIZE 메시지를 보낸다.</p>\n<p>cxClient = LOWORD(lParam);</p>\n<p>cyClient = HIWORD(lParam);</p>\n</li>\n</ul>\n<ul>\n<li>스크롤 바</li>\n</ul>\n<ul>\n<li>\n<p>윈도우 스타일 식별자인 WS_VSCROLL, WS_HSCROLL 을 CreateWindow() 세번째 인자에 포함시키면 생성됨.</p>\n</li>\n<li>\n<p>스크롤바가 차지하는 공간은 클라이언트 영역에 포함안됨</p>\n</li>\n<li>\n<p>수직 스크롤바의 폭, 수평 스크롤바의 높이는 GetSystemMetrics 호출로 가능하다.</p>\n</li>\n<li>\n<p>SetScrollRange : 스크롤 바의 범위, setScrollPos : 스크롤 바의 위치</p>\n</li>\n</ul>\n<h1 id=\"그리기-기초\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A6%AC%EA%B8%B0-%EA%B8%B0%EC%B4%88\" aria-label=\"그리기 기초 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그리기 기초</h1>\n<ul>\n<li>GDI(Graphics Device Interface) : 비디오 디스플레이와 프린터에 그래픽을 표시하는 역할을 하는 서브시스템</li>\n</ul>\n<ul>\n<li>윈도우즈의 그래픽은 GDI32.DLL 이 외부에 공개하는 함수에 의해 주로 처리한다.</li>\n</ul>\n<ul>\n<li>\n<p>GDI 함수 호출</p>\n<ul>\n<li>\n<p>디바이스 컨텍스트 핸들</p>\n<ol>\n<li>WM_PAINT 메시지 처리 : BeginPaint, EndPaint / 그 외는 GetDC,ReleaseDC</li>\n</ol>\n</li>\n<li>\n<p>GetTextMetrics : 현재 선택된 폰트의 치수 정보를 얻기 위해서</p>\n</li>\n<li>\n<p>TextOut : 클라이언트 영역에 텍스트를 표시 / 텍스트 색상 변경 : SetTextColor</p>\n</li>\n<li>\n<p>SetTextAlign : 텍스트 시작 위치 정렬</p>\n</li>\n<li>\n<p>CreatePen, CreatePenIndirect, ExtCreatePen : 펜의 여러 속성 지정함.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>디바이스 컨텍스트</p>\n<ul>\n<li>\n<p>프로그램이 DC를 얻는다는 것은 장치를 사용할 수 있도록 윈도우즈가 허가한다는 뜻이다.</p>\n</li>\n<li>\n<p>디바이스 컨텍스트는 많은 속성들을 포함하고 있어서 TextOut 호출시 속성 관련 세팅을 하지 않아도 DC에 속성을 따르게 되는 것이다.</p>\n<p>변경하고 싶으면 속성 변경하는 함수를 호출하면 된다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>디바이스 컨텍스트 핸들 얻기</p>\n<ol>\n<li>비디오 디스플레이의 특정 윈도우와 연관된 디바이스 컨텍스트를 얻기 위해사용(BeginPaint, GetDC, GetWindowDC)</li>\n</ol>\n<ul>\n<li>\n<p>BeginPaint,EndPant에 PAINTSTRUCT 구조체에 3번째 인자 rcPaint 필드가 있어서 윈도우 클라이언트 영역에서 무효 영역을</p>\n<p>둘러싸는 직사각형을 정의함.</p>\n</li>\n<li>\n<p>GetDC, ReleaseDC() : 윈도우 클라이언트 영역에 적용</p>\n</li>\n<li>\n<p>GetWindowDC, ReleaseDC : 윈도우 전체에 적용되는 디바이스 컨텍스트 핸들을 얻을 수 있다.</p>\n<p>이 디바이스컨텍스는 클라이언트 영역,윈도우 타이틀바, 메뉴, 스크롤바, 프레임을 포함.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>디바이스 컨텍스트 핸들을 얻기 위한 다른 방법</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>\n<p>CreateDC() : 특정 장치에 대 한 장치 컨텍스트를 만듭니다.</p>\n</li>\n<li>\n<p>CreateIC() : 특정 장치에 대한 정보 컨텍스트를 만듭니다.이 디바이스 컨텍스트를 만들지 않고 해당 장치에 대한 정보를 빠르게 제공</p>\n</li>\n<li>\n<p>CreateCompatibleDC(hdc) : 다른 장치 컨텍스트와 호환되는 메모리 디바이스 컨텍스트를 만듭니다. 메모리에 이미지를 준비하기위해</p>\n</li>\n<li>\n<p>CreateMetaFile : GDI 호출은 화면에 표시되지 않지만 메타피일의 일부로 저장된다.</p>\n<p>-메타파일 : 다른 파일을 설명하거나 정의하는 정보를 담고 있는 파일(GDI 함수포함, 벡터방식 : 화면깨짐이 없다.)</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>디바이스 컨텍스트 정보 얻기</p>\n<ul>\n<li>\n<p>GetDeviceCaps : 물리적 디스플레이 장치(비디오 디스플레이, 프린터 등)에 대한 정보를 얻을 때 쓰인다.</p>\n<p>GetDeviceCap(hdc, iIndex) - hdc가 화면 디바이스 컨텍스트 핸들이면, GetSystemMetrics와 정보가 동일하다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iIndex - WINGDI.H 파일에 명시</code></pre></div>\n<ol>\n<li>\n<p>GetDeviceCaps(hdc, HORZRES); GetDeviceCaps(hdc, VERTRES);</p>\n</li>\n<li>\n<p>GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN) 인자 사용시 동일하다.</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>색상에 대해서 알아보기</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>GetDeviceCaps을 사용하면 장치가 다양한 종류의 그래픽을 처리할 수 있는 능력이 있는지 여부를 결정할 수 있다.</p>\n<ul>\n<li>\n<p>GetDeviceCaps(hdc, PLANES) : 색상 편면의 개수 / GetDeviceCaps(hdc, BITSPIXEL) : 픽셀당 색상 비트수</p>\n<p>GetDeviceCaps(hdc, NUMCOLORS) : 비디오 카드에서 동시에 표시할 수 있는 색상 수</p>\n</li>\n</ul>\n</li>\n<li>\n<p>COLORREF : GDI 함수 호출에서는 특정 색상을 참조할 때 사용함. #define DWORD COLORREF</p>\n<p>COLORREF의 원색 값을 추출 할때 GetRValue, GetGValue, GetBValue 매크로를 사용</p>\n</li>\n<li>\n<p>GetNearestColor - 디더링(혼합)을 사용함으로써 실제 장치가 표시할 수 있는 색상보다 많은 색상을 표현함.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>디바이스 컨텍스트 속성</p>\n<ul>\n<li>\n<p>윈도우즈는 디바이스 컨텍스트를 사용하여 ‘속성’을 저장함으로써 GDI 함수가 화면에 작동하는 방식을 좌우한다.</p>\n</li>\n<li>\n<p>프로그램이 디바이스 컨텍스트를 얻으면, 윈도우즈는 모든 속성을 디폴트 값으로 설정함.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>디바이스 컨텍스트 저장하기</p>\n<ul>\n<li>\n<p>GetDC(), BeginPaint() 호출 -모든 속성을 디폴트로 설정한 DC 리턴</p>\n</li>\n<li>\n<p>ReleaseDC(), EndPaint() 호출 -DC해제, 수정한 모든 속성값은 사라짐</p>\n</li>\n<li>\n<p>속성값을 미리 변경 : 윈도우 클래스 등록때 스타일로 포함시킴</p>\n</li>\n<li>\n<p>SaveDC, RestoreDC : DC 속성 변경 후 다시 그전 DC 상태로 변경시 사용함.</p>\n<p>idSaved = SaveDC(hdc); // SaveDC(hdc);</p>\n<p>RestoreDC(hdc, idSaved); // 리턴값 저장 시 // RestoreDC(hdc, -1); // 가장 최근에 SaveDC() 저장한 상태로 DC 복원</p>\n</li>\n</ul>\n</li>\n<li>\n<p>직선</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>Polyline(), PolylineTo() 일련의 연결된 직선을 그린다.</p>\n<p>Polyline, PolylineTo 다른점</p>\n<ol>\n<li>\n<p>Polyline은 현재 위치를 사용하지도 변경하지도 않는다.</p>\n</li>\n<li>\n<p>PolylineTo : 현재 위치를 시작 위치로 사용하고 마지막으로 그린 선의 끝점으로 현재 위치를 이동시킨다.</p>\n</li>\n</ol>\n<p>Polyline, LineTo</p>\n<p>LineTo를 여러번 호출하면 플로터나 혹은 다른 그리기 모드에서 출력 결과가 보기 좋게 안나오고, 또한 Polyline을 이용시 쉽게 선을</p>\n<p>그릴 수 있다.</p>\n</li>\n<li>\n<p>MoveToEx(hdc, xBeg, yBeg, NULL) : DC에 속성 중 현재 위치 값을 설정함. 마지막 인자는 이전의 현재 위치값을 POINT로 담아둔다.</p>\n</li>\n<li>\n<p>LineTo(hdc, xEnd, yEnd); 현재 위치에서 이낮로 지정한 점까지 직선을 그린다.</p>\n</li>\n<li>\n<p>GetCurrnetPositionEx(hdc, &#x26;pt) : 현재 위치 값을 구해줌.(MoveTo로 현재의 위치를 변경가능)</p>\n</li>\n</ul>\n<ul>\n<li>경계 상자 함수 : 직사각형 형태의 “경계 상자”로부터 만들어진다는 점</li>\n</ul>\n<ul>\n<li>\n<p>Rectangle() 직사각형을 그리는 것</p>\n</li>\n<li>\n<p>Ellipse() : 타원을 그리는 함수</p>\n</li>\n<li>\n<p>RoundRect() : 모서리가 둥근 직사각형</p>\n</li>\n<li>\n<p>Arc : 호는 채워진 영역이 아니라 타워 곡선, Pie : 윈도우즈는 호의 양 끝점과 타원의 중심을 선으로 연결한다.</p>\n</li>\n<li>\n<p>Chord, Pie로 그린 그리믜 내부에 현재 브러시로 채워진다.</p>\n</li>\n</ul>\n<ul>\n<li>곡선</li>\n</ul>\n<ul>\n<li>\n<p>Bezier(HDC hdc, CONST POINT* lppt, DWORD cPoints);</p>\n</li>\n<li>\n<p>곡선의 시작점과 끝점 그리고 두 개의 조절점으로 구성된 배열을 두 번째 인수로 넘겨주고 세번째 인수 cPoints에 점의 개수를 주면</p>\n<p>곡선이 그려진다.</p>\n</li>\n<li>\n<p>곡선하나를 그리는데는 4개의 점이 필요하지만 두 개 이상의 곡선을 그릴때는 다음 공식만큼의 점이 필요하다.</p>\n<p>=필요한 점 = 그려질 곡선 수*3 +1</p>\n</li>\n</ul>\n<ul>\n<li>내장 펜 사용하기</li>\n</ul>\n<ul>\n<li>\n<p>내장 펜 중 하나에 대한 핸들을 얻으려면 GetStockObject()를 호출한다.</p>\n<p>hPen = GetStockObject(WHITE_PEN);</p>\n</li>\n<li>\n<p>디바이스 컨텍스트에 펜을 선택해야한다.</p>\n</li>\n</ul>\n<p>hPen(이전 디바이스컨텍스트) = SelectObject(hdc, hPen);</p>\n<p>=한 문자으로 요약가능 SelectObject(hdc, GetStockObject(WHITE_PEN))</p>\n<ul>\n<li>펜 생성, 선택, 삭제</li>\n</ul>\n<ul>\n<li>펜과 같은 GDI 객체를 사용할 때는 세 가지 규칙을 지켜야 한다.</li>\n</ul>\n<ol>\n<li>\n<p>생성한 모든 GDI 객체는 결국 삭제해야한다.</p>\n</li>\n<li>\n<p>유효한 디바이스 컨텍스트에 선택되어 있는 GDI 객체는 삭제해서는 안된다.</p>\n</li>\n</ol>\n<p>CreatePen - // hPen = SelectObject // SelectObject(hdc, hPen) // DeleteObject</p>\n<ol start=\"3\">\n<li>내장 객체는 삭제해서는 안되다.</li>\n</ol>\n<ul>\n<li>\n<p>펜 생성(CreatePen, SelectObject, DeleteObject)</p>\n</li>\n<li>\n<p>CreatePen, CreatePenIndirect (논리펜 생성)</p>\n</li>\n</ul>\n<ol>\n<li>CreatePenIndirect에서 서로 다른 펜을 직접 초기화하여 사용할 경우 더욱 효과적이다.(LOGPEN 구조체를 이용)</li>\n</ol>\n<ul>\n<li>LOGPEN 구조체 값을 얻어올 수 있다.</li>\n</ul>\n<ol>\n<li>GetObject(hPen, sizeof(LOGPEN), (LPVOID)&#x26;logpen);</li>\n</ol>\n<ul>\n<li>현재 선택된 펜 핸들이 필요하다면 다음과 같이 호출하면 된다.</li>\n</ul>\n<ol>\n<li>hPen = GetCurrentObject(hdc, OBJ_PEN);</li>\n</ol>\n<ul>\n<li>틈새 채우기</li>\n</ul>\n<ul>\n<li>\n<p>SetBkColor(hdc, crColor) // GetBKMode : 배경 모드를 얻을때 쓰임</p>\n<p>틈새를 채우기 위해서 배경색상을 바꿀때 사용함. 배경모드를 TRANSPARENT로 변경시 틈색을 채우지 않고 또한 배경색상을 무시한다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>그리기 모드</p>\n<ul>\n<li>\n<p>윈도우즈가 선을 그리기 위해 펜을 사용할 때는 실제로 펜의 픽셀과 목적지 화면의 픽셀 사이에 비트별 Boolean 연산을수행함.</p>\n<p>여기서 픽셀은 펜과 하면의 색상을 결정함. 픽셀에 대해 비트별 부울 연산을 수행하는 것을 ‘래스트 연산’ 혹은 ‘ROP’라 한다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>채워진 영역에 그리기</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>윈도우즈는 여섯개의 내장 브러시를 정의함(WHITE_BRUSH,BLACK_BRUSH,NULL_BRUSH,LTGRAY_BRUSH,DKGRAY_BRUSH,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                                       GRAY_BRUSH)</code></pre></div>\n</li>\n<li>\n<p>윈도우즈 브러시 핸들 : HBRUSH</p>\n<ol>\n<li>\n<p>HBRUSH hBrush = GetStockObject(GRAY_BRUSH); //핸들을 얻을 수 있다.</p>\n</li>\n<li>\n<p>SelectObject(hdc, hBrush) // 디바이스 컨텍스트 선택</p>\n</li>\n<li>\n<p>SelectObject(hdc, GetStockObject(NULL_PEN)) // 경계가 없는 그림</p>\n</li>\n<li>\n<p>SelectObject(hdc, GetStockObject(NULL_BRUSH)) // 그림 경계 or 내부 채우지 않으려면</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>다각형 함수와 다각형 채우기 모드</li>\n</ul>\n<ul>\n<li>\n<p>Polygon(hdc, apt, iCount) : 경계가 있고 내부가 채워진 그림을 그리는 여섯번째 함수</p>\n</li>\n<li>\n<p>PolyPolygon(hdc, apt, aiCounts, iPolycount)은 여러개의 다각형을 그린다.</p>\n<ol>\n<li>내부를 채우는 방식 : SetPolyFillMode(hdc, iMode) : iMode(ALTERNATE, WINDING)</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>\n<p>브러시로 내부 채우기</p>\n<ul>\n<li>\n<p>윈도우즈는 논리 브러시 만들 수 있게 다섯개의 함수 제공</p>\n<ol>\n<li>\n<p>CreateSolidBrush(COLORREF) : 특별한 Solid Color를 가지는 논리 브러시를 만들어준다.</p>\n</li>\n<li>\n<p>CreateHatchBrush(fnStyle, COLORREF) : 특별한 Hatch Pattern과 생상을 가지는 논리 브러시를 만들어준다.</p>\n</li>\n<li>\n<p>CreatePatternBrush(HBITMAP) : 특정 비트맵 패턴을 가지는 논리 브러시를 만들어준다.</p>\n</li>\n<li>\n<p>CreateDIBPatternBrush(HGLOBAL, UINT) : 장치 독립적인 특정 비트맵을 가지는 논리 브러시를 만들어준다.</p>\n</li>\n<li>\n<p>CreateBrushIndirect(LOGBRUSH) : 특별한 Hatch, Stype, Color 가지는 논리 브러시를 만들어준다ㅏ.</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>typedef struct tagLOGBRUSH\n{\nUINT lbStyle;\nCOLORREF lbColor;\nLONG lbHatch;\n} LOGBRUSH, *PLOGBRUSH, NEAR *NPLOGBRUSH, FAR *LPLOGBRUSH;</p>\n</li>\n</ul>\n<ol>\n<li>SelectObject() : 디바이스 컨텍스트 선택</li>\n</ol>\n<ul>\n<li>\n<p>장치 좌표계</p>\n<ul>\n<li>\n<p>모든 장치 좌표계에서 단위는 픽셀로 표현한다.</p>\n</li>\n<li>\n<p>화면 좌표 : 전체 화면을 사용한다면 화면 좌표를 사용함.</p>\n<p>CreateDC() “DISPLAY” 인자를 사용한다면 GDI 함수의 논리 좌표는 디폴트로 화면 좌표에 매핑됨</p>\n</li>\n<li>\n<p>전체윈도우좌표 : 타이틀바, 스크롤바, 테두리 등을 포함한 프로그램의 애플리케이션 윈도우 전체를 나타낸다.</p>\n<p>GetWindowDC() 디바이스 컨텍스트를 얻으면 GDI 함수의 논리 좌표가 전체 윈도우 좌표에 매핑됨</p>\n</li>\n<li>\n<p>장치 좌표계 : 클라이언트 영역 좌표 // GetDC(), BeginPaint() 디바이스 컨텍스트를 얻으면 클라이언트 좌표로 변환됨</p>\n</li>\n<li>\n<p>ClientToScreen() : 클라이언트 영역 좌표 -화면좌표 // ScreenToClient() : 화면좌표 -클라이언트 영역 좌표</p>\n</li>\n</ul>\n</li>\n<li>\n<p>뷰포트와 윈도우</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>매핑모드 : 윈도우(논리좌표)에서 뷰포트(장치좌표)로의 매핑을 정의</p>\n</li>\n<li>\n<p>뷰포트 지정 : 장치 좌표(Pixel) 사용한다.</p>\n</li>\n<li>\n<p>윈도우 지정 : 논리 좌표(피셀, 밀리미터, 인치등) 사용한다.</p>\n</li>\n<li>\n<p>장치점을 논리점으로 변환 - 논리점을 장치점으로 변환</p>\n<p>DPtoLP(hdc, pPoint, iNumber); LPtoDP(hdc, pPoint, iNumber)</p>\n<p>GetClientRect(hwnd, &#x26;rect);</p>\n<p>DPtoLP(hdc, (PPOINT)&#x26;rect, 2);</p>\n</li>\n<li>\n<p>SetViewportOrgEx(hdc, xViewOrg, yViewOrg, NULL) 바꾸면 논리점(0, 0)은 장치점(xViewOrg, yViewOrg)에 매핑된다.</p>\n<p>SetWindowOrgEx(hdc, xWinOrg, yWinOrg, NULL) 바꾸면 논리점(xWinOrg, yWinOrg)는 장치점(0,0) 매핑된다.</p>\n<p>GetViewportOrgEx(hdc, &#x26;pt); / GetWindowOrgEx(hdc, &#x26;pt) // 현재의 뷰포트와 윈도우 원점을 얻을 수 있다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>메트릭 매핑 모드</p>\n<ul>\n<li>\n<p>윈도우는 논리 좌표를 물리적 치수로 표현(다섯개의 매핑모드 제공)</p>\n<ol>\n<li>MM_LOENGLISH/MM_LOMETRIC/MM_HIENGLISH/MM_TWIPS/MM_HIMETRIC</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>사용자 정의 매핑모드</p>\n<ul>\n<li>MM_ISOTROPIC과 MM_ANISOTROPIC은 뷰포트 범위와 윈도우 범위를 변경할 수 있는 유일한 매핑 모드이다.</li>\n</ul>\n</li>\n<li>\n<p>직사각형, 리전, 클리핑</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>직사각형 작업하기</p>\n<ol>\n<li>\n<p>FillRect(hdc, &#x26;rect, hBrush) : 지정한 브러시로 직사각형을 채운다.</p>\n</li>\n<li>\n<p>FrameRect(hdc, &#x26;rect, hBrush) : 브러시를 이용하여 직사각형 프레임을 그리지만, 내부를 채우지 않는다.</p>\n</li>\n<li>\n<p>InvertRect(hdc, &#x26;rect) : 직사각형 내의 모든 픽셀을 반전시킨다.(1->0 , 0->1)</p>\n</li>\n</ol>\n</li>\n<li>\n<p>Rect 구조체 조작할 수 있는 9개의 함수 제공</p>\n<ol>\n<li>\n<p>SetRect(&#x26;rect, xLeft, xTop, xRight, Bottom) : Rect 구조체의 네 개의 필드를 특정 값으로 설정해줌</p>\n</li>\n<li>\n<p>OffsetRect(&#x26;rect, x, y) : x,y축 따라 일정 단위만큼 이동시킨다.</p>\n</li>\n<li>\n<p>InflateRect((&#x26;rect, x, y) : 직사각형의 크기를 증가 혹은 감소시킨다.</p>\n</li>\n<li>\n<p>SetRectEmpty(&#x26;rect) : 직사각형의 모든 필드를 0으로 설정한다.</p>\n</li>\n<li>\n<p>CopyRect(&#x26;DestRect, &#x26;SrcRect) : 한 직사각형을 또다른 직사각형에 복사한다.</p>\n</li>\n<li>\n<p>IntersectRect(&#x26;DestRect, &#x26;SrcRect1, &#x26;SrcRect2) : 두 직사각형의 교집합</p>\n</li>\n<li>\n<p>UnionRect(&#x26;DestRect, &#x26;SrcRect1, &#x26;SrcRect2) : 두 직사각형의 합집합</p>\n</li>\n<li>\n<p>bEmtyp = IsRectEmpty(&#x26;rect) : 직사각형이 비어 있는지 알려줌</p>\n</li>\n<li>\n<p>bInRect = PtInRect(&#x26;rect, point) : 점이 직사각형 내에 있는지 알려줌</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>리전 생성과 그리기</li>\n</ul>\n<ul>\n<li>\n<p>리전 : 사각형, 타원형, 다각형 등의 각종 도형으로 구성된 영역</p>\n</li>\n<li>\n<p>CreateRectRgn(xLeft, yTop, xRight, yBottom) or CreateRectRgnIndirect(&#x26;rect); // 리전은 직사각형을 기술한다.</p>\n</li>\n<li>\n<p>CreateEllipticRgn(xLeft, yTop, xRight, yBottom) or CreateEllipticRgnIndirect(&#x26;rect); // 타워형 리전</p>\n</li>\n<li>\n<p>CreatePolyonRgn(&#x26;point, iCount, iPolyFillMode) iPolyFillMode : ALTERNATE or WINDING</p>\n</li>\n<li>\n<p>CreatePolyPolygonRgn() 사용하면 여러개의 다각형으로 구성된 리전을 만들 수 있다.</p>\n</li>\n<li>\n<p>CombineRgn(hDestRgn, hSrcRgn1, hSrcRgn2, iCombine)</p>\n<p>hSrcRgn1, hSrcRgn2 두 개의 리전을 합쳐 새로운 리전 hDestRgn을 만든다. iCombine은 결합방법을 지정한다.</p>\n<p>리턴값은 4개로 나뉘며(NULLREGION:비어있다/SIMPLEREGION:하나의 사각형으로 구성된 리전</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                            /COMPLEXREGION:복수 개의 사각형 또는 곡선으로 구성된 리전/ERROR : 에러 발생)</code></pre></div>\n</li>\n</ul>\n<ul>\n<li>\n<p>리전 핸들로 FillRgn, FramRgn, InvertRgn, PaintRgn 쓰이게 된다.</p>\n</li>\n<li>\n<p>직사각형과 리전으로 클리핑하기</p>\n<ul>\n<li>\n<p>invalidateRgn(hwnd, hRgn, bErase) : 클라이언트 리전 영역을 무효화시킨다.</p>\n<p>validateRgn(hwnd, hRgn) : 클라이언트 리전 영역을 유효화시킨다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"키보드\" style=\"position:relative;\"><a href=\"#%ED%82%A4%EB%B3%B4%EB%93%9C\" aria-label=\"키보드 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>키보드</h1>\n<ul>\n<li>키보드 기초</li>\n</ul>\n<ul>\n<li>\n<p>키보드 입력은 메시지 형태로 프로그램의 윈도우 프로시저에 전달된다.</p>\n</li>\n<li>\n<p>특정 키보드 이벤트는 입력 포커스를 가진 윈도우를 받는다.(입력 포커스를 가진 윈도우에 키 이벤트가 전달됨)</p>\n</li>\n<li>\n<p>활성윈도우가 자식윈도우(리스트박스, 체크박스등) 가지고 있다면 자식 윈도우가 입력포커스를 가진다.</p>\n<p>자식윈도우가 활성윈도우는 아니라는 사실을 명심해야한다.</p>\n</li>\n</ul>\n<p>* 큐의 동기화</p>\n<p>사용자가 키를 누르고 뗄 경우 -하드웨어 스캔 코드(디바이스드라이버) -시스템 메시지 큐 -애플리케이션 메시지 큐</p>\n<ul>\n<li>\n<p>시스템 메시지 큐 -애플리케이션 메시지 큐</p>\n<p>윈도우의 포커스가 변경될 경우 시스템 메시지큐에 메시지를 다른 윈도우에 전달하기 위해서</p>\n</li>\n</ul>\n<p>* 키누름 메시지</p>\n<ul>\n<li>\n<p>WM_KEYDOWN, WM_KEYUP</p>\n</li>\n<li>\n<p>WM_SYSKEYDOWN, WM_SYSKEYUP : Alt 키와 함께 눌러지는 키보드 메시지, 시스템의 내부적인 용도로 사용할 때 쓰임</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                                    이 메시지를 처리할 경우 반드시 DefWindowProc으로 이 메시지를 보내야 한다.</code></pre></div>\n</li>\n<li>\n<p>GetMessageTime()을 호출하면 키를 누르거나 뗐을 때의 상대적인 시간을 얻을 수 있다.</p>\n</li>\n</ul>\n<ul>\n<li>가상 키 코드(wParam 확인)</li>\n</ul>\n<ul>\n<li>\n<p>가상 키 코드는 wParam 매개변수에 저장되어 있다.</p>\n</li>\n<li>\n<p>WINUSER.H에 VK_로 시작하는 이름으로 정의되어 있음.</p>\n</li>\n</ul>\n<ul>\n<li>lParam 정보(WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, WM_SYSKEYUP)</li>\n</ul>\n<ul>\n<li>키누름을 해석하는데 유용한 부가 정보가 들어감.</li>\n</ul>\n<ol>\n<li>\n<p>반복카운트(0~15 : 16비트) : 키누름 메시지가 나타내는 키누름의 개수다.</p>\n</li>\n<li>\n<p>OEM 스캔코드(16~23 : 8비트) : 키보드 하드웨어가 발생시키는 코드</p>\n</li>\n<li>\n<p>확장키 플래그(24) : IBM 확장 키보드에 있는 추가적인 키에 누름이 발생했을 1로 세팅</p>\n</li>\n<li>\n<p>컨텍스트코드(29) : Alt키가 눌려져 있으면 1로 세팅</p>\n</li>\n<li>\n<p>이전키상태(30) : 키를 이전에 뗀 상태라면 0이고, 키를 이전에 누른 상태라면 1이다.(KeyUp은 항상 1로 세팅됨)</p>\n</li>\n<li>\n<p>전환상태(31) : WM_KEYDOWN : 0, WM_KEYUP : 1(키를 누르면 0, 키를 떼는 중이면 1)</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>시프트상태(시프트키(Shift,Ctrl, Alt), 토클키(Caps Lock, NumLock) 눌렸는지 알기위해서)</p>\n<ol>\n<li>리턴값(GetKeyState, GetAsyncKeyState)</li>\n</ol>\n</li>\n</ul>\n<p>0x8000 은 현재 키가 눌려진 상태를 뜻하고, 0x0001은 지난번 호출과 이번 호출사이에 키가 눌려진 적이 있었다라는 것을 뜻한다.</p>\n<p>예) if( GetAsyncKeyState(VK_RETURN) &#x26; 0x8000 ) // 하는 이유는 정확한 시점에서 키의 상태를 확인하기 위해서</p>\n<ul>\n<li>SHORT GetKeyState(int nVirtKey)</li>\n</ul>\n<ol>\n<li>GetKeyState 함수의 리턴값이 0x8xxx 경우에는 해당키가 눌린 상태이고,0x8xxx가 아닐 경우는 해당키가 눌리지 않은 상태이다.</li>\n</ol>\n<ul>\n<li>GetAsyncKeyState / GetKeyState 다른점</li>\n</ul>\n<ol>\n<li>\n<p>GetAsyncKeyState : 메시지큐와 상관없이 입력되는 순간 즉각적으로 읽어들여서 동작한다.</p>\n<p>GetKeyState: 메시지큐에 저장된 메시지에 따라 반환되는 값이 다르다.</p>\n</li>\n<li>\n<p>GetKeyState는 해당키가 눌렸으면 음수값(0xffffff80, oxffffff82) 아닐 경우 0을 반환, 이전에 누르고 호출시점에 안눌릴경우 1로 남는다.</p>\n</li>\n</ol>\n<ul>\n<li>문자메시지</li>\n</ul>\n<ol>\n<li>\n<p>GetMessage로 문자 메시지 - TranslateMesage : 키누름메시지(WM_KEYDOWN, WM_SYSKEYDOWN),</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                                                   Shift key(Shift, Ctrl, Alt), 토글키(Caps Lock, Num Lock, Scroll Lock)</code></pre></div>\n<p>=메시지 큐에 WM_CHAR( 문자메시지를 넣게 된다)</p>\n</li>\n</ol>\n<ul>\n<li>네 개의 문자 메시지</li>\n</ul>\n<ul>\n<li>\n<p>WM_KEYDOWN -WM_CHAR, WM_DEADCHAR</p>\n</li>\n<li>\n<p>WM_SYSKEYDOWN -WM_SYSCHAR, WM_SYSDEADCHAR</p>\n</li>\n<li>\n<p>WM_CHAR : wParam, lParam 인자 설명</p>\n<ol>\n<li>\n<p>wParam : TCHAR str = (TCHAR)wParam -ANSI or Unicode 문자코드</p>\n</li>\n<li>\n<p>lParam : 키누름메시지(WM_KEYDOWN,WM_SYSKEYDOWN)의 lParam과 동일하다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>fUnicode = IsWindowUnicode(hwnd) -fUnicode 변수가 TRUE(유니코드 메시지)</p>\n</li>\n<li>\n<p>GetKeyNameText() : 키보드 메시지, 키누름 메시지에 대해 가상 키 코드와 키 이름을 보여줄때 사용함.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>메시지순서</p>\n<ul>\n<li>\n<p>문자메시지 : WM_KEYDOWN - WM_CHAR - WM_KEYUP</p>\n<p>WM_KEYDOWN 메시지로부터 TranslateMessage 호출되므로 WM_CHAR 사이에 끼게 된다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>제어 문자 처리</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>WM_KEYDOWN : Insert, Shift, Ctrl, Alt 읽어야 할 경우</p>\n</li>\n<li>\n<p>WM_CHAR : 키보드 문자 입력을 읽어야 할 경우</p>\n<p>Backspace, Tab, Escape, Enter : WM_CHAR 에서 미리 지정된 ANSI C 이스케이프로 구분해서 사용함.</p>\n</li>\n</ul>\n<p>case WM_CHAR:</p>\n<p>if(wParam == ‘\\b’) // if(wParam == ‘\\t’)</p>\n<ul>\n<li>\n<p>데드문자 메시지</p>\n<ul>\n<li>\n<p>데드키란 단독으로 문자를 구성할 수 없는 키이며, 이키에 의해 발생된 데드 문자는 다음에 입력되는 문자와 조합되어 하나의 문자를</p>\n<p>만든다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>WM_KEYDOWN\nWM_DEADCHAR\nWM_KEYUP\nWM_KEYDOWN\nWM_CHAR\nWM_KEYUP</p>\n<ul>\n<li>캐럿</li>\n</ul>\n<ul>\n<li>\n<p>프로그램에 텍스트를 입력할 때 일반적으로 작은 밑줄이나 수직 막대 혹은 상자가 나타나서 다음에 입력한 글자가 화면의 어느 위치에</p>\n<p>나타날지 알려준다.</p>\n<ol>\n<li>커서 : 마우스 위치를 나타내는 작은 비트맵 이미지 - 캐럿과 다른 의미</li>\n</ol>\n</li>\n<li>\n<p>캐럿 관련 함수</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>BOOL CreateCaret(HWND, HBITMAP, nWidth, nHeight)</p>\n</li>\n<li>\n<p>BOOL DestroyCatret(VOID)</p>\n</li>\n<li>\n<p>BOOL ShowCaret(hwnd) // 주기적으로 계속 깜박이며 다음 삽입 위치를 기다린다.</p>\n</li>\n<li>\n<p>BOOL HideCaret(hwnd)</p>\n</li>\n<li>\n<p>BOOL SetCaretPos(int X, int Y) : 캐럿의 위치를 지정(캐럿의 숨겨져 있어도 위치 변경가능)</p>\n</li>\n<li>\n<p>BOOL GetCaretPos(LPPOINT)</p>\n</li>\n</ol>\n<h1 id=\"마우스\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%9A%B0%EC%8A%A4\" aria-label=\"마우스 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마우스</h1>\n<ul>\n<li>마우스 기초</li>\n</ul>\n<ul>\n<li>\n<p>fMouse = GetSystemMetrics(SM_MOUSEPRESENT) : 마우스 존재 여부 검사(TRUE : 설치 O, FALSE : 설치 X)</p>\n</li>\n<li>\n<p>cButtons = GetSystemMetrics(SM_CMOUSEBUTTONS) : 마우스의 버튼 수를 알려줌</p>\n</li>\n<li>\n<p>SystemParametersInfo() : 더블 클릭 속도등 각종 마우스 파라미터를 직접 설정하거나 얻을 때 사용함.</p>\n</li>\n</ul>\n<ul>\n<li>클라이언트 영역 마우스 메시지</li>\n</ul>\n<ol>\n<li>키보드 메시지, 마우스 메시지 다른점</li>\n</ol>\n<ul>\n<li>\n<p>키보드 메시지 : 입력 포커스(EditBox)를 가진 윈도우에게만 키보드 메시지를 보냄</p>\n</li>\n<li>\n<p>마우스 메시지 : 윈도우 위, 활성 x, 입력포커스를 가지고 있지 않은 경우에도 윈도우 프로시저는 마우스 메시지를 받는다.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>마우스 위치값</li>\n</ol>\n<ul>\n<li>x = LOWARD(lParam) / y = HIWARD(lParam)</li>\n</ul>\n<ol start=\"3\">\n<li>wParam : 마우스 버튼, Shift, Ctrl 키의 상태를 나타낸다.</li>\n</ol>\n<p>MK_CONTROL, MK_LBUTTON, MK_RBUTTON, MK_MBUTTON, MK_SHIFT 조합키 상태를 알려줌.</p>\n<ul>\n<li>\n<p>알게된 내용</p>\n<p>int ShowCursor(BOOL bShow);</p>\n<p>리턴값은 내부 카운트값으로서 TRUE일 경우에는 내부 카운트가 증가하고, FALSE일경우에는 내부 카운트가 감소한다.</p>\n<p>내부카운트가 0과 같거나 클 경우 화면에 커서가 보인다.</p>\n</li>\n</ul>\n<p>GetCursorPos(&#x26;point) // point 값은 스크린 좌표값이다. 클라이언트로 영역으로 바꿀경우 ScreenToClient 함수를 써야함.</p>\n<p>SetCursorPos(x, y) //x ,y 값도 클라이언트 좌표가 아닌 스크린 좌표값이다.(클라이언트 좌표값이면ClientToScreent 함수를 이용해야함</p>\n<ul>\n<li>\n<p>마우스 더블클릭</p>\n<ul>\n<li>\n<p>윈도우 프로시저가 더블 클릭 마우스 메시지를 받기 원한다면, RegisterClass()를 호출하기 전에 윈도우 클래스 구조체의 style 필드를</p>\n<p>초기화 할때 CS_DBLCLKS 식별자를 포함한다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>비클라이언트 영역 마우스 메시지</p>\n<ul>\n<li>\n<p>윈도우 비클아이언트 영역 : 타이틀 바, 메뉴, 윈도우 스크롤 바를 포함한다.</p>\n</li>\n<li>\n<p>비클라이언트 영역 마우스 메시지는 DefWindowProc()에 전달하여 윈도우즈가 시스템 기능 수행하게 함.</p>\n<p>wParam : 마우스를 움직이거나 클릭한 곳이 비클라이언트 영역의 어느 부분인지 나타낸다.</p>\n<p>lParam : 하위워드(x) , 상위워드(y) -클라이언트 좌표가 아닌 스크린 좌표이다.</p>\n</li>\n</ul>\n<p>예) xPos = GET_X_LPARAM(lParam);\nyPos = GET_Y_LPARAM(lParam);</p>\n</li>\n</ul>\n<h1 id=\"타이머\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9D%B4%EB%A8%B8\" aria-label=\"타이머 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타이머</h1>\n<p>타이머 CH8.타이머 / Windows 프로그래밍<br>\n2013. 4. 18. 20:33 수정 삭제\n복사<a href=\"https://blog.naver.com/ssinga1030/90171478579\" target=\"_blank\" rel=\"nofollow\">https://blog.naver.com/ssinga1030/90171478579</a>\n통계보기</p>\n<ul>\n<li>\n<p>윈도우즈 타이머의 활용</p>\n<ol>\n<li>\n<p>멀티태스킹 : 많은 프로그램이 많은 양을 처리해야한다면, WM_TIMER 메시지를 받을 때마다 각 조각들을 처리가능</p>\n</li>\n<li>\n<p>실시간 갱신 : 시스템 리소스 표시같은 끊임없이 변하는 정보를 타이머로 갱신한다.</p>\n</li>\n<li>\n<p>자동저장 : 특정 주기에 맞게 사용자 작업을 저장한다.</p>\n</li>\n<li>\n<p>‘데모’버전 프로그램 종료 : 데모버전 전달 후 일정시간이 지나서 종료하도록 설계한다.</p>\n</li>\n<li>\n<p>움직임 속도 조절 : 자동으로 연속된 화면을 보여줄때 속도를 조절할 때.</p>\n</li>\n<li>\n<p>백그라운드에서 작업중인 시각적인 정보를 갱신할 때 타이머를 사용</p>\n</li>\n</ol>\n</li>\n<li>\n<p>시스템과 타이머</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>윈도우는 사용자가 설정한 타이머의 카운트 값을 설정하고 하드웨어 타이머 틱이 발생 될때마다 카운트를 감소 시킨 후 0이 되었을 때</p>\n<p>WM_TIMER 메시지를 전달하고 다시 원래 카운트로 리셋한다.</p>\n</li>\n</ul>\n<ul>\n<li>타이머 메시지는 비동기적이지 않다.</li>\n</ul>\n<ul>\n<li>\n<p>자신의 프로그램이 WM_TIMER 메시지 처리를 위해 비동기적으로 중단되지 않는다.</p>\n</li>\n<li>\n<p>WM_PAINT처럼 메시지 큐에 저장되어서 순차적으로 처리가 된다.</p>\n</li>\n</ul>\n<ul>\n<li>타이머 사용</li>\n</ul>\n<ol>\n<li>첫번째 방법</li>\n</ol>\n<ul>\n<li>\n<p>SetTimer(hwnd, 1, uiMsecInterval, NULL);</p>\n<p>1번째인자 : 윈도우 핸들, 2번째 인자 : 타이머의 번호, 3번째 인자 : 1/1000 타이머의 주기, 4번째 인자 : 콜백함수</p>\n<p>KillTimer(hwnd, 1) : 1번째 인자 : 윈도우 핸들, 2번째 인자 : 타이머의 번호</p>\n</li>\n<li>\n<p>WM_TIMER</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>두번째 방법(콜백함수)</li>\n</ol>\n<ul>\n<li>\n<p>SetTimer(hwnd, 1, uiMsecInterval, TimerProc);</p>\n</li>\n<li>\n<p>윈도우즈가 타이머 발생시 함수를 호출 할 수 있게 해주는 것이다.</p>\n</li>\n<li>\n<p>VOID CALLBACK TimerProc( HWND hwnd, UINT message, UINT iTimerID, DWORD dwTime );</p>\n</li>\n</ul>\n<p>1번째 인자 : 윈도우 핸들/ 2번째 인자 : 항상 WM_TIMER / 3번째 인자 : 타이머 ID/4번째 인자 : 윈도우즈가 시작후 경과된 시간</p>\n<ol start=\"3\">\n<li>세번째 방법</li>\n</ol>\n<ul>\n<li>\n<p>iTimerID = SetTimer(NULL, 0, wMsecInterval, TimerProc);</p>\n<p>1번째 매개변수 : hwnd 를 NULL/ 2번째 매개변수 무시한다(0) -함수의 리턴값이 타이머 ID가 된다.</p>\n</li>\n<li>\n<p>KillTimer(NULL, iTimerID)</p>\n</li>\n</ul>\n<ul>\n<li>현재시각 얻기</li>\n</ul>\n<p>typedef struct _SYSTEMTIME { // st\nWORD wYear;\nWORD wMonth;\nWORD wDayOfWeek;\nWORD wDay;\nWORD wHour;\nWORD wMinute;\nWORD wSecond;\nWORD wMilliseconds;\n} SYSTEMTIME;</p>\n<ul>\n<li>\n<p>GetLocalTime(LPSYSTEMTIME) : 표준시간대를 알려준다.(현재시간)</p>\n</li>\n<li>\n<p>GetSystemTime(LPSYSTEMTIME) : 협정세계시(그리니치 시각)</p>\n</li>\n</ul>\n<h1 id=\"자식-윈도우-컨트롤\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EC%8B%9D-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4\" aria-label=\"자식 윈도우 컨트롤 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자식 윈도우 컨트롤</h1>\n<ul>\n<li>\n<p>자식 윈도우 컨트롤</p>\n<ul>\n<li>\n<p>자식윈도우에서 부모윈도우 핸들을 얻는 방법</p>\n<p>hwndParent = GetParent(hwnd)</p>\n</li>\n<li>\n<p>부모윈도우에 메시지를 보내는 방법</p>\n<p>SendMessage(hwndParent, message, wParam, lParam);</p>\n</li>\n<li>\n<p>자신윈도우 -부모윈도우</p>\n<p>자식윈도우(컨트롤) 자신에게 변화가 있을 경우(Button Click등) 부모 윈도우에게 WM_COMMNAD 통지 메시지를 보냄.</p>\n<p>이 메시지는 자식윈도우(컨트롤)가 기동했음을 알려준다.</p>\n<p>LOWORD(wParam) : 자식 윈도우 ID, HIWORD(wParam) : 알림코드, lParam : 자식윈도우의 핸들</p>\n</li>\n</ul>\n</li>\n<li>\n<p>버튼 클래스</p>\n<ul>\n<li>\n<p>오너드로우(Owner Draw)</p>\n<p>비트맵이나 도형이미지를 가지는 경우에는 컨트롤이 직접 비트맵을 출력하지 못하여 이때 컨트롤을 소유한 부모 윈도우가 비트맵을</p>\n<p>그려주는 방식을 오너드로우라고 말한다. 정리하면 컨트롤을 소유한 부모 윈도우가 내용물을 그려주는 형식을 말한다.</p>\n</li>\n<li>\n<p>CreateWindow의 3번째 인자에 BS_OWNERDRAW 스타일을 추가하면 오너드로우 스타일을 적용하라는 의미이다.</p>\n<ol>\n<li>\n<p>WM_MEASUREITEM : 항목의 높이를 지정</p>\n</li>\n<li>\n<p>WM_DRAWITEM : 자신이 그려야 한다는 사실을 메시지를 통해서 알려준다.</p>\n</li>\n</ol>\n<p>lPamra : DRAWTIEMSTRUCT 구조체의 포인터가 들어 있다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>오너드로우 사용하는 이유</p>\n<ol>\n<li>\n<p>리스트박스 자체는 또한 윈도우이다. 그러므로 문자열 추가시 WM_PAINT 호출되어서 출력이 되지만 그 외에 비트맵과 도형이미지</p>\n<p>가지는 경우에는 직접 비트맵을 출력하지 못하므로 부모윈도우에서 대신 그려줘야하는 경우</p>\n</li>\n<li>\n<p>실시간으로 변경되는 정보를 표시할 때 항목을 수정하는 것보다는 오너 드로우로 구현하는 것이 편리한 경우</p>\n</li>\n</ol>\n</li>\n<li>\n<p>자식윈도우 생성하기</p>\n</li>\n</ul>\n<p>CreateWindow { TEXT(“button), //클래스 이름</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">         TEXT(\"PUSHBUTTON);               // 윈도우 텍스트\n\n                   WS_CHILD|WM_VISIBLE             // 윈도우 스타일\n\n                   cxChar                                      // x위치\n\n                   cyChar                                      // y위치\n\n                   20*cxChar                                 // 폭\n\n                   70*cyChar/4                             // 높이\n\n                   hwnd                                       // 부모윈도우\n\n                   (HMENU) i                                 // 자식윈도우 ID\n\n                   ((LPCTREATESTRUCT) lParam)->hIstance  // 인스턴스 핸들\n\n                   NULL                                        // 여분의 매개변수</code></pre></div>\n<ul>\n<li>\n<p>인스턴스 핸들을 얻는 방법 3가지</p>\n<ul>\n<li>\n<p>WM_CREATE시 :</p>\n<p>lParam에 CREATESTRUCT 형식의 구조체에 대한 포인터가 들어 있다.</p>\n</li>\n<li>\n<p>전역변수를 이용하는 방법</p>\n<p>hInst = hInstance;</p>\n</li>\n<li>\n<p>LONG GetWindowLong(hwnd, GWL_HINSTANCE);</p>\n</li>\n</ul>\n</li>\n<li>\n<p>인스턴스 핸들(HINSTANCE), 윈도우 식별자(핸들 - HWND), 컨트롤 ID</p>\n<ol>\n<li>\n<p>인스턴스 : 실행파일이 메모리상에 올라가 있는 시작주소를 의미한다.</p>\n<p>-실행중인 프로그램들을 구분하기 위한 식별값으로 인스턴스 핸들을 이용한다.</p>\n<p>-GetProcAddress 값이 다른 DLL에서 메모리에 올라간 함수주소를 얻을 경우 나오는 HMODULE과 동일하다.</p>\n</li>\n<li>\n<p>윈도우 식별자 핸들(HWND)</p>\n<p>-해당 프로그램의 윈도우들을 구분하기 위한 식별값을 말한다. (부모윈도우, 컨트롤 윈도우 핸들등)</p>\n</li>\n<li>\n<p>컨트롤 ID</p>\n<p>-컨트롤의 ID는 컨트롤간의 구분을 위해 사용하는 것이므로 한 부모 아래의 컨트롤끼리 중복되지 않는 ID를 가지기만 하면 된다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 내부적인 리소스로 관리됨.</code></pre></div>\n</li>\n</ol>\n</li>\n<li>\n<p>ID값 얻는 방법</p>\n<p>id = GetWindowLong(hwndChild, GWL_ID);</p>\n<p>id = GetDlgCtrlID(hwndChild);</p>\n</li>\n<li>\n<p>윈도우 핸들 얻는방법(ID와 부모윈도우 핸들을 안다면)</p>\n</li>\n</ul>\n<p>hwndChild = GetDlgItem(hwndParent, id);</p>\n<ul>\n<li>자식 윈도우가 부모 윈도우에게 보내는 메시지(자식윈도우 생성시)</li>\n</ul>\n<ul>\n<li>\n<p>BN_CLICKED / BN_PAINT / BN_DISABLE 등</p>\n</li>\n<li>\n<p>자식윈도우에서 부모윈도우에 WM_COMMAND호출(BN_CLICKED) - SendMessage(hwndButton, BM_SETSTATE, TRUE, 0)</p>\n</li>\n</ul>\n<ul>\n<li>부모 윈도우가 자식 윈도우에게 보내는 메시지</li>\n</ul>\n<ol>\n<li>\n<p>BM_GETCHECK, BM_SETCHECK</p>\n<ul>\n<li>체크박스와 라디오 단추의 체크표시를 설정하기 위해서 보낸다.</li>\n</ul>\n</li>\n<li>\n<p>BM_GETSTATE, BM_SETSTATE</p>\n<ul>\n<li>한 윈도우를 마우스로 누르거나 Space Bar를 눌렀을 때의 상태를 의미한다.</li>\n</ul>\n</li>\n<li>\n<p>BM_SETSTYLE</p>\n<ul>\n<li>단추가 만들어진 후 단추의 스타일을 변경할 수 있게 한다.</li>\n</ul>\n</li>\n<li>\n<p>BM_CLICK, BM_GETIMAGE, BM_SETIMAGE</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>푸시버튼</p>\n<ul>\n<li>\n<p>on/off 표시도 하지않고 곧바로 동작을 시작하기 위해서 주로 사용된다.</p>\n</li>\n<li>\n<p>푸시버튼이 누릴경우 BN_CLICKED인 WM_COMMAND 메시지를 부모 윈도우에 보낸다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>체크박스(텍스트가 같이 표시된 정사각형 상자)</p>\n<ul>\n<li>\n<p>체크박스에 체크표시 생성하려면 wParam : 1, 체크표시를 지우려면 wParam : 0</p>\n<p>SendMessage(hwndButton, BM_SETCHECK, 1, 0); - 체크표시 생성</p>\n<p>SendMessage(hwndButton, BM_SETCHECK, 0, 0); - 체크표시 삭제</p>\n<p>iCheck = (int)SendMessage(hwndButton, BM_GETCHECK, 0, 0); 버튼이 체크되면 TRUE, 그렇지 않으면 FALSE</p>\n</li>\n</ul>\n</li>\n<li>\n<p>라디오 버튼</p>\n<p>SendMessage(hwndButton, BM_SETCHECK, 1, 0); - 체크표시 생성</p>\n<p>SendMessage(hwndButton, BM_SETCHECK, 0, 0); - 체크표시 삭제</p>\n</li>\n<li>\n<p>그룹박스</p>\n<ul>\n<li>다른 컨트롤과 달리 키보드, 마우스 입력 처리 x, 부모 윈도우에 WM_COMMAND 메시지도 보내지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>버튼 텍스트 바꾸기</p>\n<ul>\n<li>\n<p>SetWindowText(hwnd, pszString)</p>\n<p>hwnd : 텍스트를 바꿀 대상 윈도우의 핸들, pszString : 널로 끝나는 문자열을 가리키는 포인터</p>\n</li>\n<li>\n<p>iLength = GetWindowText(hwnd, pzxBuffer, iMaxLength); //현재 텍스트를 얻어온다.</p>\n</li>\n<li>\n<p>iLength = GetWindowTextLength(hwnd) : 특정 텍스트 길이에 대비하려면 리턴반은 길이로 텍스트 버퍼를 할당한다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>보이는 버튼과 활성화된 버튼</p>\n<ul>\n<li>\n<p>자식 윈도우가 입력을 받으려면 화면에 표시되고 또한 활성화 되어야 한다.</p>\n<p>자식 윈도우 숨길경우 : ShowWindow(hwndChild, SW_HIDE)</p>\n<p>자식 윈도우 현재 보이는지 확인 : IsWindowVisible(hwndChild)</p>\n<p>자식 윈도우 활성화/비활성화 : EnableWindow(hwndChild, FALSE), EnableWindow(hwndChild, TRUE)</p>\n<p>자식 위도우 활성 여부 : IsWindowEnabled(hwndChild)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>버튼과 입력 포커스</p>\n</li>\n</ul>\n<ol>\n<li>부모윈도우 -자식윈도우 포커스 움직일경우</li>\n</ol>\n<p>case WM_KILLFOCUS : ( 부모에 KILLFOCUS -wParam에 입력포커스를 얻은 자식윈도우 핸들이 들어가 있음</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for( i=0; i&lt; NUM; i++)</code></pre></div>\n<p>{</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    if(hwndChild[i] == (HWND)wParam)\n\n    {</code></pre></div>\n<p>SetFocus(hwnd)</p>\n<p>break;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    }</code></pre></div>\n<p>}</p>\n<ol start=\"2\">\n<li>\n<p>자식 윈도우 -부모 윈도우 포커스 움직일경우</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  case WM_KILLFOCUS:\n\n  if(hwnd == GetParent((HWND)wParam)\n\n  {\n\n              SetFocus(hwnd);\n\n              break;\n\n   }</code></pre></div>\n</li>\n</ol>\n<ul>\n<li>\n<p>시스템 색상</p>\n<ul>\n<li>GetSysColor()와 SetSysColor()를 이용하면 이들 색상을 얻거나 설정할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>WM_CTLCOLORBTN 메시지</p>\n<ul>\n<li>\n<p>버튼 색상을 프로그램에서 우리가 선호하는 색상에 맞추는 방법으로 WM_CTLCOLORBTN 메시지를 처리한다.</p>\n<p>이 메시지는 자식 윈도우가 자신의 클라이언트 영역을 그리려고 할 때 윈도우 프로시저에게 보내는 것이다.</p>\n<p>부모 윈도우는 이 기회를 이용하여, 자식 윈도우 프로시저가 그리기에 사용할 색상을 바꿀 수 있다.</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>wParam : 버튼의 장치 컨텍스트에 대한 핸들</p>\n</li>\n<li>\n<p>lParam : 버튼의 윈도우 핸들</p>\n</li>\n<li>\n<p>SetTextColor를 사용하여 텍스트 색상을 설정함</p>\n</li>\n<li>\n<p>SetBkColor를 사용하여 텍스트 배경을 설정함.</p>\n</li>\n<li>\n<p>자식 윈도우에게 브러쉬 핸들을 반환한다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>WM_CTLCOLORBTN의 문제점</p>\n<p>푸시 버튼과 오너 드로우 버튼만 부모 윈도우에 WM_COTCOLORBTN 메시지를 보낼 수 있고, 부모 윈도우가 이 메시지를 처리하여</p>\n<p>배경을 칠할 브러시를 리턴한 경우, 오너 드로우 버튼만 이에 응답할 수 있다.</p>\n</li>\n</ul>\n<p>LRESULT CALLBACK WinProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">switch (msg) {\n    case WM_CTLCOLORSTATIC: {\n        if ((HWND)lParam == filterNameOff) {\n        static HBRUSH hBrushColor;\n\n            if (!hBrushColor) {\n                hBrushColor = CreateSolidBrush(RGB(0xFF, 0xFF, 0xFF)); // White background is returned\n                SetBkColor((HDC)wParam, RGB(0xFF, 0xFF, 0xFF));          // White background for text\n            }\n\n            // Background color that is used to repaint the control (doesn't affect text background)\n            return (LRESULT)hBrushColor;\n        }\n    }</code></pre></div>\n<ul>\n<li>\n<p>오너드로우 버튼</p>\n<ol>\n<li>\n<p>CreateWindow의 3번째 인자에 BS_OWNERDRAW 스타일 추가</p>\n</li>\n<li>\n<p>BS_OWNERDRAW 스타일로 생성한 버튼은 자신이 다시 그려져야 할 때마다 부모 윈도우에 WM_DRAWITEM 메시지를 보낸다.</p>\n<p>버튼이 처음 생성될 때, 버튼을 누르거나 뗄 때, 입력 포커스를 잃거나 얻을 때, 즉 다시 그려질 때 WM_DRAWITEM 호출된다.</p>\n</li>\n<li>\n<p>lParam은 DRAWITEMSTRUCT 구조체를 가리키는 포인터.(버튼을 그리는데 필요한 정보가 들어있음)</p>\n<ul>\n<li>\n<p>hdc = 버튼의 디바이스 컨텍스트</p>\n</li>\n<li>\n<p>rcItem = 버튼의 크기를 제공하는 Rect 구조체</p>\n</li>\n<li>\n<p>CtlID = 컨트롤 윈도우 ID</p>\n</li>\n<li>\n<p>itemState = 버튼이 눌렸는지 혹은 입력 포커스를 가지고 있는지 나타냄</p>\n<p>만약, 버튼이 눌려있으면 itemState 1로 세팅(ODS_SEELECTED) 상수를 이용하여 검사</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>스태틱 클래스</p>\n<ul>\n<li>\n<p>마우스, 키보드 입력을 받아들이지도 않고, 부모 윈도우에 WM_COMMAND 메시지를 보내지도 않는다.</p>\n</li>\n<li>\n<p>스태틱 자식 윈도우 위로 마우스를 옮기거나 클릭 시 자식 윈도우는 WM_NCHITTEST 메시지를 가로채고,</p>\n<p>HTTRANSPARENT를 윈도우에 반환한다.</p>\n</li>\n<li>\n<p>SS_LEFT, SS_RIGHT, SS_CENTER를 포함하는 문자열 정렬</p>\n</li>\n</ul>\n</li>\n<li>\n<p>스크롤바 클래스</p>\n<ul>\n<li>\n<p>스크롤바는 부모 윈도우에 WM_COMMAND를 보내지 않는대신, WM_VSCROLL, WM_HSCROLL 메시지를 보낸다.</p>\n</li>\n<li>\n<p>lParam 값 : 윈도우 핸들</p>\n<p>i = GetWindowLong((HWND)lParam, GWL_ID)</p>\n</li>\n<li>\n<p>wParam</p>\n<p>nScrollCold = (int)LOWORD(wParam) // SB_PAGEDOWN, SB_LINEDOWN등</p>\n<p>nPos = (Short int)HIWORD(wParam) // SB_THUMPOSION, SB_THUMTRACK 발생시 Postion값을 변경할 수 있다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>윈도우 서브클래싱</p>\n<ul>\n<li>\n<p>현존하는 윈도우 프로시저에 끼어들어서 프로그램내에서 일부 메시지를 처리하고 나머지는 원래 윈도우 프로시저에 전달하기</p>\n<p>위해서 쓰인다.</p>\n</li>\n<li>\n<p>이유 : 몇개의 기능만 구현한 프로그램을 실행하고 나머지는 원래 프로시저로 넘기기 위해서 사용된다.</p>\n</li>\n</ul>\n<p>예) OldScroll = (WNDPROC)SetWindowLong(hwnd, GWL_WNDPROC, (LONG)ScrollProc);</p>\n<ul>\n<li>그 이후 CallWindowsProc()를 사용하여 이전의 스크롤 바 윈도우 프로시저를 호출하게 된다.</li>\n</ul>\n</li>\n<li>\n<p>배경 색칠하기</p>\n<ul>\n<li>DWORD SetClassLong(HWND, int nIndex, LONG INewVal);</li>\n</ul>\n<p>=윈도우의 배경색 뿐만이 아니라 커서, 아이콘등을 윈도우 클래스에 등록한 것을 전부바꿀때 사용됨.</p>\n<ul>\n<li>반환값 : 성공시 - 이전 값이 지정된 32비트 정수, 실패시 : 0 이 리턴됨</li>\n</ul>\n</li>\n</ul>\n<p>예) SetClassLong(hwnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(color[0], color[1], color[2]));</p>\n<ul>\n<li>\n<p>에디트 클래스</p>\n<ol>\n<li>에디트 클래스 스타일</li>\n</ol>\n<p>hwndEdit = CreateWindow(TEXT(“edit”), NULL, WS_CHILD|WS_VISIBLE|WS_HSCROLL|WS_VSCROLL|</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                    WS_BORDER|ES_LEFT|ES_MULTILINE|ES_AUTOHSCROLL|ES_AUTOVSCROLL,\n\n                                    0, 0, 0, 0, hwnd, (HMENU) 1, ((LPCTREAESTRUCT)lParam)->hInstance, NULL);</code></pre></div>\n<ol>\n<li>\n<p>정렬 : ES_LEFT, ES_RIGHT, ES_CENTER</p>\n</li>\n<li>\n<p>행 : 디폴트는 단일행 / 다중 행 MULTILINE</p>\n</li>\n<li>\n<p>자동 수평/수직 스크롤 : ES_AUTOHSCROLL, ES_AUTOVSCROLL =끝까지 문자가 입력되었을 때 자동으로 수평/수직 스크롤이됨</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>에디트 컨트롤 통지</li>\n</ol>\n<ol>\n<li>\n<p>LOWORD(wParam) : 자식 윈도우 ID</p>\n</li>\n<li>\n<p>HIWORD(wParam) : 통지코드</p>\n</li>\n<li>\n<p>lParam : 자식 윈도우 핸들</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>통지코드</p>\n<p>● EN_ERRSPACE : 에디트 컨트롤이 메모리 할당 할 수 없을 경우</p>\n<p>● EM_MAXTEXT : 에디트 컨트롤에 텍스트를 삽입할 공간이 부족할 경우</p>\n<p>=위의 두개의 통지코드에 대한 처리를 해줘야 한다.</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>에디트 컨트롤에 보낼 수 있는 메시지</li>\n</ol>\n<ol>\n<li>\n<p>선택된 내용을 잘라내기 : SendMessage(hwndEdit, WM_CUT, 0, 0);</p>\n</li>\n<li>\n<p>선택된 내용을 복사하기 : SendMessage(hwndEdit, WM_COPY, 0, 0); //삽입하기 WM_PASTE</p>\n</li>\n<li>\n<p>선택된 내용을 삭제하기 : SendMessage(hwndEdit, WM_CLEAR, 0, 0);</p>\n</li>\n</ol>\n</li>\n<li>\n<p>리스트박스 클래스</p>\n<ol>\n<li>리스트 박스 스타일</li>\n</ol>\n<p>hwndList = CreateWindow (TEXT (“listbox”), NULL,\nWS_CHILD | WS_VISIBLE | WS_BORDER| WS_VSCROLL | LBS_NOTIFY,\n10, 20, 200, 300,\nhwnd, (HMENU) 2,\n(HINSTANCE) GetWindowLong (hwnd, GWL_HINSTANCE), NULL) ;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1) LBS_NOTIFY : 리스트 박스는 어떠한 일이 일어나도 통지 메시지를 보내지 않으므로 통지메시지 사용시 꼭 추가해야함.\n\n                        쓰인이유 - 과거 컴퓨터 느릴 시 조금이라도 속도를 빠르게 하기 위해서 사용됨(WM_COMMAND로 받음)\n\n2) ﻿LBS_SORT : 리스트 박스내의 항목들을 정렬\n\n3) LBS_MULTIPLESEL, LBS_EXTENDEDSEL : 리스트 박스 디폴트 선택 타입은 단일 선택 타입이다 하지만 2개의 타입을\n\n                                                                 추가해주면 다중 or 확장 선택 리스트 박스를 추가할 수 있다.﻿﻿﻿﻿\n\n4) LBS_STANDARD -LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER</code></pre></div>\n<ol start=\"2\">\n<li>리스트 박스 문자열</li>\n</ol>\n<ol>\n<li>\n<p>리스트 박스 리턴값</p>\n<ul>\n<li>\n<p>LB_ERRSPACE : SendMessage() 리턴이 LB_ERRSPACE는 내용을 저장할 메모리 공간이 부족할 때 리턴됨.</p>\n</li>\n<li>\n<p>LB_ERROR : 다른 이유로 오류가 발생할 경우</p>\n</li>\n<li>\n<p>성공시 문자열이 추가된 위치의 인덱스 값을 리턴함.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>리스트 박스 문자열 삽입</p>\n<ul>\n<li>\n<p>SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)szString);</p>\n<p>=4번째 인자는 널을 끝나는 문자열에 포인터값</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  LBS_SORT 사용시 3번째 인자 0으로 세팅, 안할 경우 Index 값을 지정해줘야한다.</code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>리스트 박스 문자열 삭제</p>\n<ul>\n<li>\n<p>SendMessage(hwndList, LB_DELETESTRING, index, 0)</p>\n<p>SendMessage(hwndList, LB_RESETCONTENT, 0, 0);</p>\n<p>차이점 : LB_DELETESTRING은 인덱스에 있는 문자열 삭제, LB_RESETCONTENT는 모든 항목을 제거하는 것이다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>리스트 박스 갱신</p>\n<ul>\n<li>\n<p>SendMessage(hwnd, WM_SETREDRAW, FALSE, 0);</p>\n<p>SendMessage(hwnd, WM_SETREDRAW, TRUE, 0);</p>\n</li>\n</ul>\n<p>=리스트 박스 윈도우 프로시저는 항목이 추가되거나 삭제될 때 화면을 갱신한다. 막약 추가하거나 삭제할 문자열이 많은 경우</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 컨트롤의 다시 그리기 플래그를 끔으로써 갱신 동작을 일시 금지 시키고 이후에 다시 동작시키게 할 수 있다.\n\n 또한 스타일에 LBS_NOREDRAW 스타일을 추가할 경우 화면 갱신 플래그를 꺼진 상태로 시작할 수 있다.</code></pre></div>\n</li>\n<li>\n<p>리스트 박스 항목 선택, 빼기</p>\n<ul>\n<li>\n<p>리스트박스 항목의 개수 : iCount = SendMessage(hwndList, LB_GETCOUNT, 0, 0);</p>\n</li>\n<li>\n<p>항복 선택 : SendMessage(hwndList, LB_SETCURSEL, iIndex, 0);</p>\n</li>\n<li>\n<p>시작 글자에 기반한 항목 선택 : iIndex = SendMessage(hwndList, LB_SELECTSTRING, iIndex, (LPARAM)szSearchString);</p>\n</li>\n<li>\n<p>현재 선택된 항목을 알고 싶을 경우 : iIndex = SendMessage(hwndList, LB_GETCURSEL, 0, 0);</p>\n</li>\n<li>\n<p>문자열의 길이 알기 위해서 : ILength = SendMessage(hwndList, LB_GETTEXTLEN, iIndex, 0);</p>\n</li>\n<li>\n<p>텍스트 버퍼에 저장 : iLength = SendMessage(hwndList, LB_GETTEXT, iIndex, (LPARAM)szBuffer);</p>\n</li>\n<li>\n<p>특정 항목의 선택 상태 설정 : SendMessage(hwndList, LB_SETSEL, wParam, iIndex);</p>\n</li>\n<li>\n<p>턱정 항목의 선택 상태 알기 위해 : iSelect = SendMessage(hwndList, LB_GETSEL, iIndex, 0);</p>\n</li>\n</ul>\n</li>\n<li>\n<p>리스트 박스로부터 메시지 받기</p>\n<ul>\n<li>\n<p>자식윈도우 : LOWORD(wParam)</p>\n</li>\n<li>\n<p>통지코드 : HIWORD(wParam)</p>\n</li>\n<li>\n<p>lParam : 자식 윈도우 핸들</p>\n</li>\n<li>\n<p>WM_COMMAND 통지코드</p>\n<p>LBN_SELCHANGE : 현재 리스트 박스 선택이 변경됨을 알려줌.</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>\n<p>알게된 API</p>\n<p>GetEnvironmentVariable(lpName, lpBuffer, nSize) : 환경변수 이름 반환하기.</p>\n<p>=lpName : 환경변수 이름 / lpBuffer : 환경변수가 가지고 있는 정보를 반환하여 저장될 버퍼, nSize : 버퍼에 들어갈 최대 크기</p>\n</li>\n</ul>\n<h1 id=\"메뉴와-그밖에-리소스\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%89%B4%EC%99%80-%EA%B7%B8%EB%B0%96%EC%97%90-%EB%A6%AC%EC%86%8C%EC%8A%A4\" aria-label=\"메뉴와 그밖에 리소스 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메뉴와 그밖에 리소스</h1>\n<ul>\n<li>아이콘, 커서, 문자열, 커스텀 리소스</li>\n</ul>\n<ol>\n<li>리소스의 분리</li>\n</ol>\n<ul>\n<li>\n<p>일반적으로 프로그램은 코드와 데이터로 구분됨</p>\n</li>\n<li>\n<p>코드 : 데이터를 처리하는 수단 / 데이터 : 코드가 아닌 모든 것을 데이터라고 지칭할 수 있음(비트맵, 메뉴, 아이콘 등)</p>\n</li>\n<li>\n<p>리소스란 : 코드의 논리와 무관한 데이터의 집합</p>\n</li>\n<li>\n<p>리소스와 코딩 과정이 분리시 장점</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>디자이너와 프로그래머가 분담하여 작업을 하기가 편리하다. 프로그래머는 열심히 프로그램의 논리를 만들고 디자이너는 리소스만</p>\n<p>예쁘게 만들어 결합시키면 되기 때문이다.</p>\n</li>\n<li>\n<p>리소스를 수정하더라도 프로그램을 일일이 다시 컴파일하지 않아도 되므로 컴파일 속도가 현저히 빨라진다.</p>\n</li>\n<li>\n<p>한번 만들어 놓은 리소스를 다른 프로젝트에 쉽게 가져다 쓸 수 있어 리소스의 재사용에 유리하다.</p>\n</li>\n<li>\n<p>리소스는 교체가 가능한 모듈이므로 상황에 따라 다른 형태의 리소스를 사용할 수 있다.(다국어 버전, 스킨기능 등)</p>\n</li>\n<li>\n<p>RC파일 : 사용하고자 하는 리소스의 종류, 모양 등을 작성한 파일</p>\n</li>\n<li>\n<p>RES : RC파일을 리소스 컴파일러(RC.exe)로 컴파일 하면 RES라는 이진 파일이 생성됨.</p>\n</li>\n</ol>\n<p>-링크과정에서 obj, res 파일이 합쳐져서 .exe 실행파일이 생성됨.</p>\n<ol start=\"3\">\n<li>\n<p>Resource.h : RC파일에서 지정한 Define된 값을 이용하여서 Resource.h파일을 그 리소스에 ID값을 부여함.</p>\n<p>예) *.rc : MENUITEM “&#x26;New”, ID_MENUITEM40020</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  Resource.h  : #define ID_MENUITEM40020                40020</code></pre></div>\n</li>\n</ol>\n<p>● 알게된 내용 - DISCARDABLE(윈도우즈가 (필요하다면) 추가적인 공간을 얻기 위해 리소스를 메모리에서 제거할 수 있음을 나타낸다.)</p>\n<ol start=\"3\">\n<li>\n<p>리소스를 만들고 프로젝트에 포함시키는 과정을 정리</p>\n</li>\n<li>\n<p>프로그램에 아이콘 추가하기</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>아이콘을 추가하기 위해서 insert/Resource 선택해서 Icon을 추가한다.</p>\n</li>\n<li>\n<p>리소스 폅집기에서 FileName과 ID값을 지정함. &#x3C; *.rc파일과 resource.h 파일에 추가됨.></p>\n</li>\n</ul>\n<p>-*.rc : IDI_ICON&#x3C;IDICON DISCARDABLE “icondemo.ico”<FileName></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  *.h :  #define IDI_ICON                        101</code></pre></div>\n<ul>\n<li>\n<p>아이콘 핸들 얻는 방법</p>\n<p>hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON));</p>\n<p>HICON LoadIcon( HINSTANCE, LPCTSTR);</p>\n</li>\n</ul>\n<p>#define MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))</p>\n<p>-정수타입의 리소스ID를 문자열 포인터에 대입할 수 없으므로 캐스팅을 할 때 쓰이는 매크로가 MAKEINTRESOURCE 이다.</p>\n<ul>\n<li>\n<p>아이콘의 크기 얻는 방법(32 x 32 : Visual C++ 생성한 아이콘 크기)</p>\n<p>cxIcon = GetSystemMetrics(SM_CXICON);</p>\n<p>cyIcon = GetSystemMetrics(SM_CYICON);</p>\n<p>좀 더 작은 16x16 픽셀의 사이즈를 얻을 경우 XM_CXSMSIZE, SM_CYSMSIZE 쓰인다.</p>\n</li>\n<li>\n<p>아이콘을 그릴 때 : DrawIcon(HDC, x, y, HICON)</p>\n</li>\n</ul>\n<p>● LoadIcon(NULL, IDI_APPLICATION) - hInstance가 NULL 이므로 윈도우즈가 미리 정의된 아이콘임을 알려준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                                      IDI_APPLICATION은 WINUSER.H 미리 정의되어 있다.\n\n                                                      #define IDI_APPLICAION MAKEINTRESOURCE(32512)</code></pre></div>\n<ul>\n<li>\n<p>프로그램 실행중에 아이콘을 전환할 경우</p>\n<p>SetClassLong(hwnd, GCL_HICON, LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ALTICON))</p>\n</li>\n<li>\n<p>LoadIcon은 핸들을 얻지만 핸들을 파괴할 필요가 없다.</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li>사용자 맞춤 커서 추가하기</li>\n</ol>\n<ul>\n<li>\n<p>윈도우 클래스를 정의</p>\n<p>wndclass.hCursor = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CURSOR));</p>\n<p>wndclass.hCursor = LoadCursor(hInstance, szCursor); - 커서를 텍스트 이름으로 정의</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li>문자열 리소스</li>\n</ol>\n<ul>\n<li>\n<p>문자열 리소스는 주로 프로그램을 다른 언어로 변환하는 것을 쉽게 하기 위해서 사용된다.</p>\n</li>\n<li>\n<p>문자열 테이블 생성</p>\n<p>insert/Resource - String Table 추가</p>\n</li>\n<li>\n<p>LoadString(hInstance, id, szBuffer, iMaxLength)</p>\n<p>2번째 인자 : 각 문자열 앞쪽에 있는 ID값</p>\n<p>3번째 인자 : 문자열을 받을 버퍼의 주소, 4번째는 szBuffer로 옮길 문자의 최대 개수</p>\n<p>리턴 : 문자열에 들어 있는 문자의 개수를 리턴함.</p>\n</li>\n<li>\n<p>문자열 리소스는 최대 4K까지의 길이를 가질 수 있다.</p>\n</li>\n<li>\n<p>문자열 리소스 장점</p>\n</li>\n</ul>\n<ol>\n<li>우선 첫째로 문자열 자체가 코드와 분리됨으로써 문자열만 따로 관리할 수 있으며 프로젝트를 유지하는데도 큰 도움을 준다.</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>문자열 리소스를 사용하는 두번째 이점은 다국어 버전을 쉽게 만들 수 있다는 점이다</p>\n<p>3)﻿ 문자열이 소스와 분리되어 있으면 문자열을 고쳐도 소스를 다시 컴파일할 필요가 없어 개발 기간도 빨라진다.</p>\n</li>\n</ol>\n<ol start=\"7\">\n<li>\n<p>메뉴</p>\n<ul>\n<li>\n<p>메뉴 추가</p>\n<p>Insert/Resource - Menu 항목 추가</p>\n</li>\n<li>\n<p>메뉴 속성 변경</p>\n<p>Caption : 사용자에게 보여질 메뉴의 이름 / ID : 프로그램에서 이 메뉴 항목을 지칭하는 이름이다.</p>\n</li>\n<li>\n<p>메뉴항목의 속성 : ID<em>상위메뉴</em>캡션 : ID_FILE_MENU</p>\n</li>\n<li>\n<p>윈도우 클래스를 정의</p>\n<p>wndclass.lpszMenuName = MAKEINTRESOURCE(IDR_MENU1)</p>\n</li>\n<li>\n<p>메뉴의 특성</p>\n<ol>\n<li>\n<p>1번째 특성은 메뉴에 보이는 것 : 텍스트 문자열 or 비트맵</p>\n</li>\n<li>\n<p>2번째 특성은 WM_COMMAND에 wParam 하위비트에 각 메뉴의 ID값을 전달해서 메뉴의 선택을 윈도우 프로시저에게 알려줌</p>\n</li>\n<li>\n<p>3번째 특성은 메뉴 항목의 속성(비활성, 활성, 체크등을 표시해줌)</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<p>● 알게 된 내용</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  - HMENU GetMenu(hwnd) - 메뉴의 핸들얻음\n\n  - CheckMenuItem(hMenu, menuID, uCheck)\n\n    예) CheckMenuItem(hMenu, LOWORD (wParam) - ID, MF_CHECKED) ;\n\n  - EnableMenuItem(hMenu, menuID, nEnable)\n\n    예) EnableMenuItem(hMenu, LOWORD (wParam), MF_GRAYED/MF_ENABLED)</code></pre></div>\n<ol start=\"8\">\n<li>키보드 가속기</li>\n</ol>\n<ul>\n<li>\n<p>키보드 가속기 장점</p>\n<ol>\n<li>\n<p>메뉴와 키보드 가속기 로직을 프로그래머가 중복 구현할 필요가 없다.</p>\n<p>TranslateAccelerator()에서 지정한 윈도우의 윈도우 프로시저에 윈도우즈가 WM_COMMAND 메시지를 보낸다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>단축키와 키보드 가속기에 다른점</p>\n<ol>\n<li>\n<p>단축키 : 반드시 Alt키와 함께 사용해야 하며 메뉴에 있는 항목을 키보드로 선택하는 빠른 방법</p>\n</li>\n<li>\n<p>키보드 가속기 : 메뉴와 상관없이 언제든지 사용가능하다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>가속기 추가</p>\n<p>Insert/Resource - Accelerator 추가</p>\n</li>\n<li>\n<p>키보드 가속기의 속성 - ID : 액셀레이터의 ID, KEY : 액셀레이터가 사용할 키, Modifiers : Key와 함께 눌러질 조합키</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                             Type :  아스키코드, 가상키코드</code></pre></div>\n</li>\n<li>\n<p>가속시 테이블 로드</p>\n<p>hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1));</p>\n<p>1번째 인자 : 프로그램의 인스턴스, 2번째 인자 : 액셀러레이터 테이블의 이름 문자열 포인터</p>\n</li>\n<li>\n<p>키누름 변환</p>\n<p>TranslateAccelator(HWND, HACCEL, LPMSG)</p>\n<ol>\n<li>\n<p>키보드 메시지가 WM_COMMAND 메시지로 변경하여 액셀러레이터가 동작할 수 있도록 함.</p>\n</li>\n<li>\n<p>동작방식</p>\n</li>\n</ol>\n<p>KEYDOWN(Ctrl) - TranslateAccelator(FALSE) - TranslateMessage - DispatchMessage - WndProc - 처리완료</p>\n<p>KEYDOWN(A) - TranslateAccelator(TRUE) - WndProc - WM_COMMAND 호출되서 처리되게 함.</p>\n</li>\n</ul>\n<p>HACCEL hAccel;</p>\n<p>hAccel=LoadAccelerators(hInstance,MAKEINTRESOURCE(IDR_ACCELERATOR1));\nwhile(GetMessage(&#x26;Message,0,0,0)) {\nif (!TranslateAccelerator(hWnd,hAccel,&#x26;Message)) {\nTranslateMessage(&#x26;Message);\nDispatchMessage(&#x26;Message);\n}\n}</p>\n<h1 id=\"대화상자\" style=\"position:relative;\"><a href=\"#%EB%8C%80%ED%99%94%EC%83%81%EC%9E%90\" aria-label=\"대화상자 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대화상자</h1>\n<blockquote>\n<p>WndClass.cbClsExtra=0;\nWndClass.cbWndExtra=0;\nWndClass.hbrBackground=(HBRUSH)(COLOR_WINDOW+1);\nWndClass.hCursor=LoadCursor(NULL,IDC_ARROW);\nWndClass.hIcon=LoadIcon(NULL,IDI_APPLICATION);\nWndClass.hInstance=hInstance;\nWndClass.lpfnWndProc=WndProc;\nWndClass.lpszClassName=lpszClass;\nWndClass.lpszMenuName=NULL;\nWndClass.style=CS_HREDRAW | CS_VREDRAW;\nRegisterClass(&#x26;WndClass);</p>\n</blockquote>\n<p>BOOL CALLBACK AboutDlgProc(HWND hDlg,UINT iMessage,WPARAM wParam,LPARAM lParam)\n{\nswitch (iMessage) {\ncase WM_INITDIALOG:\nreturn TRUE;\ncase WM_COMMAND:\nswitch (LOWORD(wParam)) {\ncase IDOK:\nEndDialog(hDlg,IDOK);\nreturn TRUE;\ncase IDCANCEL:\nEndDialog(hDlg,IDCANCEL);\nreturn TRUE;\n}\nbreak;\n}\nreturn FALSE;\n}</p>\n<p>LRESULT CALLBACK WndProc(HWND hWnd,UINT iMessage,WPARAM wParam,LPARAM lParam)\n{\nswitch (iMessage) {\ncase WM_LBUTTONDOWN:\nDialogBox(g_hInst,MAKEINTRESOURCE(IDD_DIALOG1),hWnd,AboutDlgProc);\nreturn 0;\ncase WM_DESTROY:\nPostQuitMessage(0);\nreturn 0;\n}\nreturn(DefWindowProc(hWnd,iMessage,wParam,lParam));\n}</p>\n<ul>\n<li>\n<p>대화상자</p>\n<ul>\n<li>프로그램과 사용자간의 대화, 곧 명령 및 정보 전달을 위한 특별한 윈도우</li>\n</ul>\n</li>\n<li>\n<p>대화상자 템플릿</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>대화상자의 모양을 정의하는 이진 데이터</p>\n</li>\n<li>\n<p>대화상자 자체의 속성은 물론이고 대화상자 내에 생성되는 컨트롤의 위치, 크기 , 속성등도 정의되어 있음.</p>\n</li>\n<li>\n<p>DialogBoxIndirect(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc);</p>\n</li>\n<li>\n<p>LPCDLGTEMPLATE 구조체에 위치, 크기 속성( pdt->style = WS_POPUP, pdt->x = 10, pdt->y = 20; )</p>\n</li>\n</ul>\n<ul>\n<li>모드형 대화상자</li>\n</ul>\n<ul>\n<li>프로그램이 모드형 대화상자를 표시, 사용자는 대화상자와 프로그램 내의 다른 윈도우 사이에 전환할 수 없다.</li>\n</ul>\n<ul>\n<li>대화상자 프로시저</li>\n</ul>\n<ol>\n<li>\n<p>대화상자 프로시저 정의</p>\n<ul>\n<li>\n<p>윈도우 프로시저가 윈도우에서 발생하는 메시지를 처리하는 것과 마찬가지로 대화상자 프로시저는 대화상자에서 발생하는 메시지를</p>\n<p>처리함.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>대화상자 프로시저 역할</p>\n<ul>\n<li>\n<p>대화상자 생성 시 자식 윈도우 컨트롤 초기화, 자식 윈도우 컨트롤이 발생시킨 메시지 처리, 대화상자의 종료 처리</p>\n</li>\n<li>\n<p>WM_PAINT, 키보드와 마우스 메시지 처리하지 않음</p>\n</li>\n</ul>\n</li>\n<li>\n<p>대화상자, 윈도우 프로시저 다른점</p>\n</li>\n<li>\n<p>윈도우 : LRESULT / 대화상자 : BOOL형 리턴 ( 대화상자가 FALSE를 리턴할 경우 그 메시지 나머지는 운영체제가 처리함)</p>\n</li>\n<li>\n<p>윈도우 : 특정 메시지 처리하지 않을 경우(DefWindowProc()호출) / 대화상자 : 메시지 처리하면 TRUE, 그렇지 않으면 FALSE</p>\n</li>\n<li>\n<p>윈도우 : WM_CREATE / 대화상자 : WM_INITDIALOG 호출됨&#x3C; 초기화 ></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                               -WM_PAINT, WM_DESTROY 메시지 처리 안함.</code></pre></div>\n</li>\n<li>\n<p>WM_COMMAND 호출</p>\n<ul>\n<li>\n<p>대화상자 프로시저에서 주로 처리하는 메시지</p>\n</li>\n<li>\n<p>LOWORD(wParam)에 메시지를 보낸 컨트롤의 ID가 전달, HIWORD(wParam) 통지코드가 전달됨.</p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>대화상자 호출/ 종료</li>\n</ul>\n<p>int DialogBox(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc)</p>\n<ul>\n<li>\n<p>1번째 인수 : 리소스를 가진 인스턴스 핸들 / 2번째 인수 : 대화상자 템플릿의 리소스 ID</p>\n<p>3번째 인수 : 대화상자를 소유할 부모 윈도우, 네번째 인수는 대화상자 프로시저의 이름</p>\n<p>예) DialogBox (hInstance, TEXT (“AboutBox”), hwnd, AboutDlgProc) ;</p>\n</li>\n</ul>\n<p>BOOL EndDialog(HWND hDlg, int nResult)</p>\n<ul>\n<li>1번째 인수 : 대화상자 프로시저로 전달된 핸들 / 2번째 인수 : 대화상자를 호출한 DialogBox 함수의 리턴값으로 전달됨.</li>\n</ul>\n<ul>\n<li>컨트롤과의 통신</li>\n</ul>\n<ol>\n<li>핸들과 ID</li>\n</ol>\n<ol>\n<li>윈도우 핸들 얻는 방법(차일드 ID 알경우)</li>\n</ol>\n<p>HWND GetDlgItem(HWND hDlg, int nIDDlgItem) : 1번째 인수는 대화상자의 핸들, 두번째 인수로 컨트롤의 ID주면 핸들값을 얻을 수 있다.</p>\n<p>=컨트롤을 이동시키거나 숨길 때 핸들값이 사용됨(ShowWindow, MoveWindow)</p>\n<ol start=\"2\">\n<li>컨트롤의 윈도우 핸들로부터 ID를 구하는데 사용</li>\n</ol>\n<p>int GetDlgCtrlID(HWND hwndCtl)</p>\n<p>id = GetWindowLong(HWND, GWL_ID);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">= 윈도우 핸들로부터 ID값을 구하는데 사용함.</code></pre></div>\n<p>SendDlgItemMessage(HWND, hDlg, int nID, UNIT MSG, WPARAM wParam, LPARAM lPrame)</p>\n<p>=SendMessage(GetDlgItem(hDlg, ID) ~ 2개의 함수를 합쳐놓은 API 제공</p>\n<p>=SendDlgItemMessage(hdlg, id, BM_SETCHECK, 1,0);</p>\n<ul>\n<li>컨트롤의 값 읽기</li>\n</ul>\n<ol>\n<li>문자열을 읽고 출력하는함수</li>\n</ol>\n<ul>\n<li>UINT GetDlgItemText( HWND hDlg, int nIDDlgItem, LPTSTR lpString, int nMaxCount );</li>\n<li>BOOL SetDlgItemText( HWND hDlg, int nIDDlgItem, LPCTSTR lpString );</li>\n</ul>\n<ol start=\"2\">\n<li>정수를 읽고 출력하는 함수</li>\n</ol>\n<ul>\n<li>\n<p>UINT GetDlgItemInt( HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned );</p>\n</li>\n<li>\n<p>BOOL SetDlgItemInt( HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned );\n=네번째 인수 bSigned가 TRUE일 경우는 부호있는 정수값을 읽어주며 FALSE일 경우는 부호를 무시하고 무조건 양수로 읽어준다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">세번째 인수는 지정된 BOOL형 포인터에 에러가 있는지 없는지 대입(에러검사가 필요없는 경우 NULL 전달함)</code></pre></div>\n</li>\n</ul>\n<ul>\n<li>Radio Button 컨트롤 사용법(3개의 기능이 모두 같다) - wParam 1이여야지 체크가 됨.</li>\n</ul>\n<ol>\n<li>SendMessage(GetDlgItem(hDlg, id), BM_SETCHECK, i == LOWORD(wParam), 0);</li>\n</ol>\n<p>for(int I=IDC_BLACK; I&#x3C;=IDC_WHITE; I++)</p>\n<p>SendMessage(GetDlgItem(hDlg, I), BM_SETCHECK, I==LOWORD(wParam), 0);</p>\n<ol start=\"2\">\n<li>SendDlgItemMessage(hDlg, id, BM_SETCHECK, i == LOWORD(wParam), 0);</li>\n</ol>\n<p>for(int I=IDC_BLACK; I&#x3C;=IDC_WHITE; I++)</p>\n<p>SendDlgItemMessage(hDlg, I, BM_SETCHECK, I==LOWORD(wParam), 0);</p>\n<ol start=\"3\">\n<li>\n<p>CheckRadioButton(hDlg, idFirst, idLast, idCheck)</p>\n<p>-idFirst부터 idLast 끼지 모든 라이오 버튼 컨트롤의 체크 표시를 끄되, 예외적으로 ID가 idCheck인 라디오 버튼만 체크표시한다.</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>체크박스 컨트롤 사용법</p>\n<p>1.CheckDlgButton(hDlg, idCheckbox, iCheck);</p>\n<p>-iCheck가 1이면 버튼을 체크, 0이면 체크가 제거됨.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>iCheck = IsDlgButtonChecked(hDlg, idCheckBox) : 체크 박스의 상태를 얻을 수 있다.</li>\n</ol>\n<ul>\n<li>대화상자 프로시저 인자전달</li>\n</ul>\n<ol>\n<li>DialogBoxParam(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam)</li>\n</ol>\n<p>예)</p>\n<p>typedef struct</p>\n<p>{</p>\n<p>int iColor, iFigure;</p>\n<p>} ABOUTBOX_DATA</p>\n<p>static ABOUTBOX_DATA ad = { IDC_BLACK, IDC_RECT };</p>\n<p>if(DialogBoxParam(hInstance, TEXT(“AboutBox”), hwnd, AboutDlgProc, &#x26;ad))</p>\n<p>-WM_INITDIALOG 메시지를 받을 때 lParam으로 전달된다.</p>\n<p>pad = (ABOUTBOX_DATA*) lParam;</p>\n<p>ad = *pad;</p>\n<ul>\n<li>\n<p>모달리스 / 모달 대화상자</p>\n<ol>\n<li>차이점</li>\n</ol>\n<ol>\n<li>\n<p>모달 : DialogBox() 함수를 이용, 대화상자가 파괴된 후에야 값을 리턴한다</p>\n<p>모달리스 : CreateDialog() 함수를 이용, 윈도우 핸들을 즉시 리턴해준다.</p>\n</li>\n<li>\n<p>모달리스형은 흔히 캡션바와 시스템 메뉴를 포함 /모달형은 캡션바와 시스템메뉴 제공하지않음(다른영역 이동X)</p>\n</li>\n<li>\n<p>모달리스형은 WS_VISIBLE을 생략한다면 CreateDialog 호출 후 ShowWindow()를 반드시 호출</p>\n</li>\n</ol>\n<p>예) hDlgModaless = CreateDialog(…);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   ShowWindow(hDlgModaless, SW_SHOW);</code></pre></div>\n<ol start=\"2\">\n<li>모달리스 구현사항</li>\n</ol>\n<p>hDlgModaless = CreateDialog(hInstance, lpTemplate, hWndParent, lpDialogFunc);</p>\n<p>-DialogBox에 인자와 같다.</p>\n<p>while(GetMessage(&#x26;msg, NULL, 0, 0)){</p>\n<p>if(!IsWindow(hDlgModaless) || !IsDialogMessage(hDlgModaless, &#x26;msg)) // 모달리스 대화상자 사용시</p>\n<p>{</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   if(!TranslateAccelerator(hwnd, hAccel, &amp;msg)) //키보드 가속기 사용시\n\n   {\n\n TranslateMessage (&amp;msg) ;\n DispatchMessage  (&amp;msg);</code></pre></div>\n</li>\n</ul>\n<p>}</p>\n<p>}</p>\n<p>BOOL IsWindow(HWND) -유효한 윈도우 핸들인지 조사</p>\n<ul>\n<li>하는 이유 : 대화상자를 두번 만들지 않게 하기 위해서 사용된다.</li>\n</ul>\n<p>BOOL IsDialogMessage(hDlg, lpMsg)</p>\n<ul>\n<li>하는 이유 : 메시지를 점검 한 후 대화상자와 관련된 메시지이면 이 메시지를 처리하고 TRUE를 리턴함. 아니라면 FALSE리턴</li>\n</ul>\n<p>DestroyWindow(hDlg) -모달은 EndDialog지만 모달리스는 DestroyWindow를 호출하게 된다.</p>\n<p>CreateDialog에서 리턴한 핸들을 NULL로 초기화해줘야함.</p>\n<ul>\n<li>\n<p>알게된 내용 : CreateWindow에서 Style중 WS_CLIPCHILDREN 사용하는 이유?</p>\n<p>-프로그램이 대화상자를 지우지 않고도 메인 윈도우를 다시 그릴 수 있게 해주는 Style이다.</p>\n</li>\n<li>\n<p>공통 대화상자</p>\n<ul>\n<li>하나의 표준화된 사용자 인테페이스를 장려하기 위해서 개발되었다.</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>\n<p>파일열기 대화상자</p>\n</li>\n<li>\n<p>색상 대화상자</p>\n</li>\n<li>\n<p>폰트 선택 대화상자</p>\n</li>\n<li>\n<p>찾기 대화상자</p>\n</li>\n</ol>\n<h1 id=\"클립보드\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A6%BD%EB%B3%B4%EB%93%9C\" aria-label=\"클립보드 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클립보드</h1>\n<ul>\n<li>\n<p>클립보드 : 프로그램간에 또는 내부적으로 교환할 데이터를 잠시 저장해 두는 곳</p>\n</li>\n<li>\n<p>힙 할당(TEXT -클립보드)</p>\n<ul>\n<li>\n<p>HGLOBAL GlobalAlloc(UNIT uFlags, DWORD dwByte) : 힙에 메모리를 할당하는 함수</p>\n</li>\n<li>\n<p>LPVOID GlobalLock(HGLOBAL hMem) : 메모리의 실제 위치의 포인터 리턴</p>\n</li>\n<li>\n<p>BOOL GlobalUnLock(HGLOBAL hMem)</p>\n</li>\n<li>\n<p>HGLOVAL GlobalFree(HBLOBAL hMem)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>비트맵 -클립보드</p>\n<p>hBlt = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP));</p>\n<p>CF_BITMAP 세팅 후 클립보드에 복사하고 읽을 수 있다.</p>\n</li>\n</ul>\n<p>HGLOBAL hmem;</p>\n<p>TCHAR *ptr;</p>\n<p>hmem=GlobalAlloc(GHND, lstrlen(str)+1);\nptr=(TCHAR *)GlobalLock(hmem);\nmemcpy(ptr,str,lstrlen(str)+1);\nGlobalUnlock(hmem);</p>\n<p>if (OpenClipboard(hWnd)) { // 클립보드 독점\nEmptyClipboard();\nSetClipboardData(CF_TEXT,hmem);\nCloseClipboard();</p>\n<p>}</p>\n<ul>\n<li>\n<p>클립보드 함수</p>\n<p>BOOL OpenClipboard(HWND hWndNewOwner) // 인수 : 윈도우 핸들</p>\n<p>BOOL EmptyClipboard(); // 클립보드 지움</p>\n<p>HANDLE SetClipboardData(UINT uFormat, HANDLE hMem) // uFormat : CF_BITMAP, CF_TEXT등</p>\n<p>-hMem 데이터가 uFormat으로 클립보드에 복사된다. 호출이후부터는 사용자가 hMem 메모리 변경불가능(시스템관리:클립보드)</p>\n<p>-SetClipboardData(CF_TEXT, hmem);</p>\n<p>BOOL CloseClipBoard(); // 클립보드 닫음(생략시 다른사용자가 클립보드 사용X)</p>\n<p>BOOL IsClipboardFormatAvailable(UINT format) // uFormat : CF_BITMAT, CF_TEXT등 클립보드에 있는지 검사</p>\n<p>HANDLE GetClipBoardData(UINT format)</p>\n<p>-hmem = GetClipBoardData(CF_TEXT);</p>\n<p>-HBITMAP hBit = (HBITMAP)GetClipBoardData(CF_BITMAP)</p>\n</li>\n<li>\n<p>새로운 클립보드 포멧을 등록</p>\n<p>UINT RegisterClipboardFormat(LPCTSTR lpszFormat)</p>\n<p>예)</p>\n<p>MyFormat = RegisterClipboardFormat(“MOVIE”);</p>\n<p>SetClipboardData(MyFormat, hmem);</p>\n</li>\n<li>\n<p>클립보드 포맷을 관리하는 함수</p>\n</li>\n</ul>\n<p>int CountClipboardFormats(void) // 등록된 포멧의 개수</p>\n<p>UINT EnumClipboardFormats(UINT format); // 각 포멧 열거함</p>\n<p>int GetClipboardFormatName(UINT format, LPTSTR lpszFomatName, int cchMaxCount); // 포멧의 등록 이름을 구함.</p>\n<ul>\n<li>\n<p>클립보드 뷰어</p>\n<ul>\n<li>\n<p>클립보드 내용의 변화를 통지받는 프로그램</p>\n</li>\n<li>\n<p>뷰어끼리 체인으로 연결되어 있어, 최근에 설치된 뷰어가 맨앞에 위치하고 체인을 통해서 뒤에 뷰어에게 변화나 상태를 전달함.</p>\n</li>\n<li>\n<p>클립보드의 내용 변경 : SetClipboardViewer(CF_TEXT, hmem) -윈도우 WM_DRAWCLIPBOARD 호출 ->모든 뷰어에게 추가를 알림</p>\n</li>\n<li>\n<p>클립보드 뷰어 삭제 : ChangeClipboadChain(hWnd, hNext) -WM_CHANGECBCHAIN -모든 뷰어에게 삭제를 알림</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"프린터\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A6%B0%ED%84%B0\" aria-label=\"프린터 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프린터</h1>\n<ul>\n<li>인쇄과정</li>\n</ul>\n<p>프로그램 - GDI - 스풀러 - 디바이스드라이버 - 프린터</p>\n<ol>\n<li>\n<p>스풀러 : 적절한 프린터 디바이스 드라이버를 메모리 로딩 - 고수준 출력 명령을 저널 레코드로 변환 - 디스크에 파일로 저장</p>\n<ul>\n<li>저장된 출력 명령을 바탕으로 백그라운드에서 인쇄 - 저널레코드 (디바이스드라이버 알수있도록 DDI(Device Driver Interface) 변환</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>\n<p>프린터 DC</p>\n<ol>\n<li>\n<p>인쇄대화상자 호출하는 함수</p>\n<ul>\n<li>BOOL PrintDlg(LPPRINTDLG lppd);</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p>pd.lStructSize = sizeof(PRINTDLG); //구조체 크기\npd.Flags = PD_RETURNDC; // 프린터 DC 구함\npd.hwndOwner = hWndMain; // 윈도우 핸들\npd.nFromPage = 1;\npd.nToPage = 1;\npd.nMinPage = 1;\npd.nMaxPage = 1;\npd.nCopies = 1;\nPrintDlg(&#x26;pd);\nhPrtdc = pd.hDC; // 프린트 DC 사용을 위해 HDC 대입</p>\n<ol start=\"2\">\n<li>\n<p>HDC CreateDC(LPCTSRT lpszDriver, LPCTSTR lpszDevice, LPCTSTR lpszOutput, CONST DEVMODE *lpInitData)</p>\n<ul>\n<li>\n<ol>\n<li>driver name, 2. device name, 3. NULL 4. 디바이스 드라이버에 특정 초기화 데이터</li>\n</ol>\n</li>\n<li>\n<p>특정 이름의 디바이스의 DC를 구할 때 사용함.</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>PRINTER_INFO_4 *pi4;</p>\n<p>EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &#x26;cbNeed, &#x26;cbReturn);\npi4=(PRINTER_INFO_4 *)malloc(cbNeed);\nEnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, (PBYTE)pi4, cbNeed, &#x26;cbNeed, &#x26;cbReturn);</p>\n<p>hdc = CreateDC(NULL, pi4->pPrinterName, NULL, NULL);</p>\n<ol start=\"3\">\n<li>\n<p>인쇄의 시작</p>\n<ul>\n<li>int StartDoc(HDC hdc, Const DOCINFO *lpdi);</li>\n</ul>\n</li>\n</ol>\n<p>doc.cbSize = sizeof(DOCINFO);\ndoc.lpszDocName = TEXT(“TEST Document”);\ndoc.lpszOutput = NULL; // 출력파일 이름, NULL 일 경우 프린터 DC로 출력\ndoc.lpszDatatype = NULL;\nStartDoc(hPrtdc, &#x26;doc);</p>\n<ol start=\"4\">\n<li>프린터 드라이버에게 데이터를 받아들이도록 준비시킴(새로운 페이지 시작)</li>\n</ol>\n<ul>\n<li>\n<p>int StartPage(HDC hdc)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> StartPage(hPrtdc);</code></pre></div>\n</li>\n</ul>\n<ol start=\"5\">\n<li>한 페이지 출력을 완료 후 새 용지를 로드</li>\n</ol>\n<ul>\n<li>int EndPage(HDC hdc);</li>\n</ul>\n<p>EndPage(hPrtdc);</p>\n<ol start=\"6\">\n<li>인쇄가 마무리</li>\n</ol>\n<ul>\n<li>int EndDoc(HDC hdc)</li>\n</ul>\n<p>EndDoc(hPrtdc);</p>\n<p>DeleteDC(hPrtdc);</p>\n<ul>\n<li>폰트의 변경</li>\n</ul>\n<p>xpage = GetDeviceCaps(hPrtdc, HORZRES); // 장치크기의 픽셀수\nypage = GetDeviceCaps(hPrtdc, VERTRES);\nRectangle(hPrtdc,0,0,xpage,ypage);</p>\n<p>dpiY = GetDeviceCaps(hPrtdc, LOGPIXELSY); // 인치당 픽셀수</p>\n<p>// 화면 해상도와 프린터의 해상도가 높기 때문에 아래와 같은 계산식이 필요함.</p>\n<p>// 1 inch = 72 point = 인치당 픽셀수 구한값(pixel)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> point = n*1/72*dpiY</code></pre></div>\n<p>MyFont = CreateFont(20*dpiY/72, 0,0,0,FW_NORMAL, FALSE,FALSE,FALSE,HANGEUL_CHARSET,3,2,1,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                           VARIABLE_PITCH|FF_ROMAN,TEXT(\"궁서\"));</code></pre></div>\n<ul>\n<li>비트맵 출력</li>\n</ul>\n<p>Result=GetDeviceCaps(hPrtdc, RASTERCAPS) &#x26; RC_BITBLT;\nif (!Result) goto end;\nhbit=(HBITMAP)LoadImage(g_hInst, MAKEINTRESOURCE(IDB_BITMAP1),\nIMAGE_BITMAP,0,0,LR_CREATEDIBSECTION);\n..\nMemDC=CreateCompatibleDC(hPrtdc);\nOldBitmap=(HBITMAP)SelectObject(MemDC, hbit);\nStretchBlt(hPrtdc,dpiX,dpiY,4<em>dpiX,4</em>by/bx*dpiY,MemDC,0,0,bx,by,SRCCOPY);</p>\n<ul>\n<li>\n<p>주의사항</p>\n<ol>\n<li>\n<p>프린터로 비트맵 출력 시 StretchBlt 함수로 출력해야함(Bitblt를 그대로 출력시 프린터에 화면에 나온거보다 작게 출력됨)</p>\n</li>\n<li>\n<p>비트맵 출력이 가느한지 조사해야함.</p>\n<p>GetDeviceCaps(hPrtdc, RASTERCAPS) -래스터 출력이 가능한지 확인</p>\n<p>RC_BITBLT -비트맵 전송지원 지원</p>\n</li>\n<li>\n<p>LoadImage 함수로 읽어야 한다. - 화면색상포맷과 프린터의 색상 포맷이 맞지 않기 때문에(DDB로 불러드리기때문에)</p>\n</li>\n</ol>\n<p>LR_CREATEDIBSECTION - DIB 섹션으로 읽은 후 출력할 때 비트맵 포맷이 프린터에 맞게 변환된다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>여러 페이지 출력</p>\n<ol>\n<li>\n<p>문서의 길이 계산</p>\n<ul>\n<li>\n<p>사용자가 선택한 문서의 길이 알아내야함.</p>\n<p>PD_ALLPAGES, PD_PAGENUMS, PD_SELECTION</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p>if (pd.Flags &#x26; PD_PAGENUMS) {\nnFirstPage=pd.nFromPage;\nnFinalPage=pd.nToPage;\n} else {\nnFirstPage=pd.nMinPage;\nnFinalPage=pd.nMaxPage;\n}</p>\n<ol start=\"2\">\n<li>시작페이지와 끝페이지 인쇄(for문으로 돌면서 인쇄해야함)</li>\n</ol>\n<p>for(nPage = nFirstPage; nPage &#x3C;= nFinalPage; nPage++)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> {\n\n      StartPage()\n\n      EndPage()\n\n  }\n\n  EndDoc();</code></pre></div>\n<ul>\n<li>취소 프로시저(인쇄 취소시)</li>\n</ul>\n<ol>\n<li>취소 프로시저와 취소 대화상자 필요함.</li>\n</ol>\n<p>// 취소대화상자</p>\n<p>g_hDlgCancel=CreateDialog(g_hInst, MAKEINTRESOURCE(IDD_DIALOG1),\nhWndMain, (DLGPROC)AbortDlgProc); // 모달리스로 대화상자 만듦</p>\n<p>LRESULT CALLBACK AbortDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\nswitch (message) {\ncase WM_INITDIALOG:\nreturn TRUE;\ncase WM_COMMAND:\ng_bPrint=FALSE; // 취소 버튼 누를시 FALSE 세팅\nEnableWindow(hWndMain, TRUE);\nDestroyWindow(g_hDlgCancel);\ng_hDlgCancel=NULL;\nreturn TRUE;\n}\nreturn FALSE;\n}</p>\n<p>// 최소 프로시저. 이 함수에서 TRUE를 리턴하면 인쇄를 계속하고 FALSE를 리턴하면 인쇄를 취소한다.</p>\n<p>SetAbortProc(hPrtdc, (ABORTPROC)AbortProc); // 취소 프로시저 추가</p>\n<p>EnableWindow(hWndMain, FALSE); // 인쇄하려는 동안 프로그램을 종료, 다른 작업을 못하게 하기위해서</p>\n<p>BOOL CALLBACK AbortProc(HDC hPrtdc, int iError)\n{\nMSG msg;\nwhile (g_bPrint &#x26;&#x26; PeekMessage(&#x26;msg, NULL,0,0,PM_REMOVE)) { // g_bPrint 가 FALSE 가 될시 인쇄가 취소된다.\nif (!IsDialogMessage(g_hDlgCancel, &#x26;msg)) {\nTranslateMessage(&#x26;msg);\nDispatchMessage(&#x26;msg);\n}</p>\n<p>return g_bPrint;</p>\n<p>}</p>\n<ul>\n<li>프린터 열거</li>\n</ul>\n<ol>\n<li>프린터 열거</li>\n</ol>\n<ul>\n<li>\n<p>시스템에 설치된 프린터와 프린터서버 등을 열거한다.</p>\n</li>\n<li>\n<p>BOOL EnumPrint(DWORD Flags, LPTSTR Name, DWORD Level, LPBYTE pPrinterEnum, DWORD cbBuf, LPDWORD pcbNeeded,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                   LPDWORD pcReturnd);</code></pre></div>\n<ol>\n<li>\n<p>Flags : 조사할 오브젝트 종류를 지정함(PRINTER_ENUM_LOCAL,, PRINTER_ENUM_SHARED)</p>\n</li>\n<li>\n<p>Name : 조사할 대상의 추가정보(대부분 NULL 세팅) - 특정도메인내 프린터목록 조사시 도메인명을 적을 수는 있음.</p>\n</li>\n<li>\n<p>Level, pPrinterEnum : Level 2 -PRINTER_INFO_2 // 프린터의 원하는 정보를 얻을 때 쓰이며 1~5까지 구성되어 있음</p>\n</li>\n<li>\n<p>cbBuf : 배열의 크기</p>\n</li>\n<li>\n<p>pcbNeeded : 필요한 메모리양</p>\n</li>\n<li>\n<p>pcReturned : 구조체 배열의 크기를 리턴</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>typedef struct _PRINTER_INFO_4A {\nLPSTR pPrinterName;\nLPSTR pServerName;\nDWORD Attributes;\n} PRINTER_INFO_4A, *PPRINTER_INFO_4A, *LPPRINTER_INFO_4A;</p>\n<p>PRINTER_INFO_4 *pi4;</p>\n<p>EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &#x26;cbNeed, &#x26;cbReturn);\npi4=(PRINTER_INFO_4 *)malloc(cbNeed);\nEnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, (PBYTE)pi4, cbNeed, &#x26;cbNeed, &#x26;cbReturn);\nfor (i=0;i&#x3C;cbReturn;i++) {\nwsprintf(Mes,“프린터 이름: %s, 종류:%s ”, pi4[i].pPrinterName,\npi4[i].Attributes==PRINTER_ATTRIBUTE_LOCAL ? “로컬”:“네트워크”);\nTextOut(hdc,10,y++*20,Mes,lstrlen(Mes));\n}\nfree(pi4);</p>\n<ul>\n<li>\n<p>속성조사</p>\n<ol>\n<li>\n<p>해상도, 크기(픽셀), 크기(사이즈)</p>\n<p>GetDeviceCaps(HDC, HORZRES/HORZSIZE/LOGPIXELSX);</p>\n</li>\n<li>\n<p>프린터 이름을 토대로 속성 확인(한 부씩 인쇄, 양면인쇄)</p>\n<p>DeviceCapabilities(szPrinter, szPrinter, DC_COLLATE/DC_DUPLEX, NULL, NULL); //한부씩 인쇄, 양면인쇄</p>\n</li>\n<li>\n<p>OpenPrinter, GetPrinter, ClosePrinter : 프린터 이름으로 핸들값을 얻어서 PRINTER_INFO값을 얻고 세팅가능</p>\n<p>GetPrinter, EnumPrinters PRINTER_INFO의 크기를 같은 방법으로 얻을 수 있음.</p>\n</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"비트맵과-bitblt함수\" style=\"position:relative;\"><a href=\"#%EB%B9%84%ED%8A%B8%EB%A7%B5%EA%B3%BC-bitblt%ED%95%A8%EC%88%98\" aria-label=\"비트맵과 bitblt함수 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비트맵과 Bitblt함수</h1>\n<ul>\n<li>\n<p>메모리 DC 쓰는 이유(비트맵)</p>\n<ul>\n<li>\n<p>비트맵과 같은 경우 대용량 데이터 이므로 곧바로 출력할 경우 출력속도가 느리게 되는 단점이 발생함.</p>\n<p>(비트맵 곧바로 화면 출력못하게 되어 있음)</p>\n</li>\n</ul>\n<p>-메모리 DC에 그려두고 화면 DC에 고속복사해서 보여주게 하기 위해서 사용됨.</p>\n</li>\n<li>\n<p>메모리 DC -화면 DC에 고속복사 함수</p>\n<ol>\n<li>BOOL BitBlt(hdcDest, xDest, xDest, nWidth, nHeight, hdcSrc, nXsrc, nYSrc, dwRop) - 래스터 연산 : 256가지</li>\n</ol>\n<p>dwRop : 래스터 연산 방법을 지정</p>\n<p>-SRCCOPY : 소스 영역을 대상 영역에 복사한다.</p>\n<ol start=\"2\">\n<li>\n<p>비트맵 전송시 확대 및 축소 가능</p>\n<p>BOOL StretchBlt(hdcDest, xOriginDest, YOriginDest, nWidthDest, nHeightDest, hdcSrc, nXOriginSrc, nYOriginSrc, nWidthSrc,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                   nHeightSrc, dwRop) - 래스터 연산 : 256가지</code></pre></div>\n<ul>\n<li>\n<p>StretchBlt(hdc, 0,0,246,320,MemDc,0,0,123,160,SRCCOPY)</p>\n</li>\n<li>\n<p>SetStretchBltMode 모드 변경가능.</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>BOOL PatBlt(HDC hdc, int nXLeft, int nYLeft, int nWidth, int nHeight, DWORD dwRop) - 래스터 연산 : 16가지</p>\n<ul>\n<li>\n<p>지정한 사각영역을 현재 DC에 선택된 브러시로 채움</p>\n</li>\n<li>\n<p>FillRect는 사각영역으로 브러시로 채우지만 PatBlt는 dwRop에 따라서 바뀔 수가 있다.(검정, 흰색으로 채울 경우)</p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>GDI 비트맵 객체</li>\n</ul>\n<ol>\n<li>DDB 비트맵 생성함수</li>\n</ol>\n<ul>\n<li>\n<p>CreateBitmap(cx, cy, cPlanes, cBitsPixel, bits);</p>\n</li>\n<li>\n<p>CreateCompatibleBitmap(hdc, cx, cy) -hdc이용해서 GetDeviceCaps(PLANES(색상면의수), BITPIXEL(픽셀당비트수)) 정보를</p>\n<p>얻음 -내부적으로 CreateBitmap 호출함.</p>\n</li>\n<li>\n<p>CreateCompatibleBitmap(&#x26;bitmap) -BITMAP 구조체에 주소를 설정</p>\n<p>● GetObject(hBitmap, sizeof (BITMAP), &#x26;bitmap) -구조체의 값 얻을 수 있음</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>메모리 디바이스 컨텍스트</p>\n<p>hdcMem = CreateCompatibleDC(hdc);</p>\n<ol>\n<li>\n<p>인자로 NULL 지정 시 비디오 디스플레이와 호환되는 메모리 디바이스 컨텍스트 생성</p>\n</li>\n<li>\n<p>DeleteDC 호출 후 파괴</p>\n</li>\n</ol>\n</li>\n<li>\n<p>비트맵 리소스 로드</p>\n<p>hBitmap = LoadBitmap(hInstance, szBitmapName);</p>\n<ol>\n<li>\n<p>시스템 비트맵 로딩 : hinstance =NULL</p>\n</li>\n<li>\n<p>DeleteObject 삭제</p>\n</li>\n</ol>\n</li>\n<li>\n<p>흑백 비트맵 포멧(리소스 생성없이 color array로 흑백비트맵생성)</p>\n<p>static BYTE bits[] = {0x51, ~~};</p>\n<ol>\n<li>\n<p>bitmap.bmBits = (PSTR)bits;</p>\n<p>hBitmap = CreateBitmapIndirect(&#x26;bitmap);</p>\n</li>\n<li>\n<p>hBitmap = CreateBitmapIndirect(&#x26;bitmap);</p>\n<p>SetBitmapBits(hBitmap, sizeof(bits), bits);</p>\n</li>\n<li>\n<p>hBitmap = CreateBitmap(20, 5, 1, 1, bits); //width, height,planes,bitsPixel,color data array</p>\n<p>-DeleteObject 함수 호출해서 해제시켜줘야 한다.</p>\n</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"장치독립적인비트맵\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%B9%98%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%B8%EB%B9%84%ED%8A%B8%EB%A7%B5\" aria-label=\"장치독립적인비트맵 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장치독립적인비트맵</h1>\n<ul>\n<li>DIB &#x26; DDB 차이점</li>\n</ul>\n<ul>\n<li>\n<p>DDB(Device Dependent Bitmap) : 장치 설정대로 출력되는 비트맵(32bit -32bit, 흑백 -흑백)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                            장점 : 정보가 일치하므로 빠른 속도로 이미지를 출력\n\n                                            단점 : 장치의 의존하므로 다른 장치에선 정확히 출력이 안된다.</code></pre></div>\n</li>\n<li>\n<p>DIB(Device Independent Bitmap) : 장치와 상관없이 헤더에 나온 세팅대로 출력하는 비트맵</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                             장점 : 어떤한 설정을 가진 장치에서도 동일한 이미지정보를 출력\n\n                                             단점 : 비트맵 출력 속도가 떨어질 수 있음( 비트맵 구성이 다르다면 변환작업이 필요)</code></pre></div>\n</li>\n</ul>\n<ul>\n<li>DIB 구조</li>\n</ul>\n<ol>\n<li>\n<p>BITMAPFILEHEADER 구조체</p>\n<ul>\n<li>비트맵 파일 자체에 관한 정보를 가진다.</li>\n</ul>\n</li>\n</ol>\n<p>typedef struct tagBITMAPFILEHEADER {\nWORD bfType;\nDWORD bfSize;\nWORD bfReserved1;\nWORD bfReserved2;\nDWORD bfOffBits;\n} BITMAPFILEHEADER, FAR *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;</p>\n<ol start=\"2\">\n<li>\n<p>BITMAPINFOHEADER 구조체</p>\n<ul>\n<li>BITMAPFILEHEADER 구조체 바로 뒤에 위치하면서 DIB의 크기(가로 폭, 세로 높이)와 색상 포멧에 관한 정보등을 가진 구조체이다.</li>\n</ul>\n</li>\n</ol>\n<p>typedef struct tagBITMAPINFOHEADER{\nDWORD biSize;\nLONG biWidth;\nLONG biHeight;\nWORD biPlanes;\nWORD biBitCount;\nDWORD biCompression;\nDWORD biSizeImage;\nLONG biXPelsPerMeter;\nLONG biYPelsPerMeter;\nDWORD biClrUsed;\nDWORD biClrImportant;\n} BITMAPINFOHEADER, FAR *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;</p>\n<ol start=\"3\">\n<li>RGBQUAD 구조체</li>\n</ol>\n<ul>\n<li>비트맵에서 사용되는 색상 테이블 정의</li>\n</ul>\n<p>typedef struct tagRGBQUAD {\nBYTE rgbBlue;\nBYTE rgbGreen;\nBYTE rgbRed;\nBYTE rgbReserved;\n} RGBQUAD;</p>\n<ol start=\"4\">\n<li>\n<p>DIB 출력</p>\n<ol>\n<li>SetDIBitsToDevice</li>\n</ol>\n</li>\n</ol>\n<p>BYTE* pRaster;</p>\n<p>int SetDIBitsToDevice(HDC hdc,int xDest,int yDest,DWORD dwWidth,DWORD dwHeight,int xSrc,int ySrc,UINT uStartScan</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                           UINT cScanLines,CONST VOID *lpvBits,CONST BITMAPINFO *lpbmi,UINT fuColorUse);</code></pre></div>\n<ul>\n<li>\n<p>Return : 스캔 라인의 갯수</p>\n</li>\n<li>\n<p>9번째 인자(cScanLines) : 스캔 라인수 = 비트맵의 높이</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">               &lt; 비트맵 ></code></pre></div>\n<p>BITMAPFILEHEADER *fh = NULL;</p>\n<p>fh = (BITMAPFILEHEADER*)malloc(GetFileSize(hFile, NULL));</p>\n<p>BYTE* lpvBits = (PBYTE)fh+fh->bfOffBits;</p>\n</li>\n<li>\n<p>lpvBits : 비트맵의 실제 모양인 래스터 데이터 포인터(BITMAPFILEHEADER+BITMAPINFOHEADER == bfOffBits(FILEHEADER))</p>\n</li>\n<li>\n<p>fuColorUse : DIB_RGB_COLORS - 색상값 / DIB_PAL_COLORS - 팔레트의 인덱스</p>\n<ol start=\"2\">\n<li>StretchDIBits( 확대 출력시 )</li>\n</ol>\n</li>\n</ul>\n<p>int StretchDIBits(HDC hdc,int XDest,int YDest,int nDestWidth,int nDestHeight,int XSrc, int YSrc,int nSrcWidth,int nSrcHeight</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                   CONST VOID *lpvBits,CONST BITMAPINFO *lpbmi,UINT iUsage,DWORD dwRop);</code></pre></div>\n<ul>\n<li>\n<p>Return : 스캔 라인의 갯수</p>\n</li>\n<li>\n<p>iUsage : DIB_RGB_COLOR(색상테이블 색상값), DIB_PAL_COLORS(팔레트의 인덱스)</p>\n</li>\n<li>\n<p>dwRop : 래스터 연산</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li>DDB 변환</li>\n</ol>\n<p>HBITMAP CreateBitmap(HDC hdc, CONST BITMAPINFOHEADER *lpbmih, DWORD fdwInit, CONST VOID *lpbInit</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                               CONST BITMAPINFO* lpbmi, UINT fuUsage)'</code></pre></div>\n<p>{</p>\n<p>if(hdc)</p>\n<p>hBitmap = CreateCompatibleBitmap(hdc, cx, cy);</p>\n<p>else</p>\n<p>hBitmap = CreateBitmap(cx,cy,1,1,NULL);</p>\n<p>if(fdwInit)</p>\n<p>{</p>\n<p>hdcMem = CreateCompatibleDC(hdc);</p>\n<p>SelectObject(hdcMem, hBitmap);</p>\n<p>SetDIBitsToDevice(hdcMem,0,0,cx,cy,0,0,0,cy,lpbInit,lpbmi,fuUsage);</p>\n<p>DeleteDC(hdcMem);</p>\n<p>}</p>\n<p>return hBitmap;</p>\n<p>}</p>\n<ul>\n<li>내부적으로 메모리 DC를 만들고 호환 비트맵에 DIB를 출력하는 일을 한다.(BitBlt로 출력)</li>\n</ul>\n<ol start=\"6\">\n<li>DIB 섹션</li>\n</ol>\n<ul>\n<li>\n<p>이점 : 래스터 데이터를 직접 조작, 크기가 큰 파일을 다루기가 편리(파일 매핑 오브젝트)</p>\n</li>\n<li>\n<p>HBITMAP CreateDIBSection(HDC hdc, CONST BITMAPINFO *pbmi, UINT iUsage, VOID **ppvBits,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                    HANDLE hSection, DWORD dwOffset);</code></pre></div>\n</li>\n</ul>\n<ol start=\"7\">\n<li>DIB로 변환</li>\n</ol>\n<ul>\n<li>\n<p>CreateBitmap, CreateCompatibleBitmap 장치에 의존하므로 속도가 빠르지만 DIB로 저장시에는 아래 API가 호출되어야한다.</p>\n</li>\n<li>\n<p>int GetDIbits(HDC hdc,HBITMAP hBitmap,UINT uStartScan,UINT uScanLines,LPVOID lpvBits,LPBITMAPINFO lpbi, UINT uUsage);</p>\n</li>\n</ul>\n<h1 id=\"텍스트와-폰트\" style=\"position:relative;\"><a href=\"#%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80-%ED%8F%B0%ED%8A%B8\" aria-label=\"텍스트와 폰트 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>텍스트와 폰트</h1>\n<ul>\n<li>\n<p>텍스트 그리기 함수</p>\n<ol>\n<li>\n<p>SetTextAlign(HDC hdc, UINT fMode)</p>\n<p>● fMode : 지정하는 정렬 Mode를 세팅함.</p>\n<p>TA_UPDATECP : TextOut에서 지정한 x, y 좌표를 무시하고 현재 CP(current position)를 이용한다.</p>\n<p>TA_NOUPDATECP : CP를 사용하지 않고 지정한 좌표를 사용하며 CP를 변경하지 않는다.</p>\n</li>\n<li>\n<p>TabbedTextOut(hdc, xStart, yStart, pString, iCount, iNumTabs, piTabStops, xTabOrigin)</p>\n<ul>\n<li>텍스트 문자열이 탭 문자(‘\\t’, 0x09)를 포함한다면,TabbedTextOut()은 인자로 전달된 정수 배열에 기초하여 탭을 공백으로 확장함.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p>예) int tabstop[4] = {8,16,24,32}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  wsprintf(temp, \"tabbedTextOut\\t를\\t이용한\\t출력\");\n\n  1) TabbedTextOut(hdc,0,20,temp,strlen(temp),4,tabstop,0);\n\n  =iNumTabs : 탭의 개수,  piTabStops : 탭 위치를 가지는 배열\n\n  =첫 번째 탭에서는 설정된 문자열의 평균 가로크기의 8배, 두번째 탭에서는 16배 공백으로 띄워줌.\n\n  2) TabbedTextOut(hdc,0,20,temp,strlen(temp),1,tabstop,0);\n\n  =탭키를 만날 때마다 tabstop의 첫 번째 값 즉 8값만큼 균일적으로 공백으로 띄어 주게 된다.</code></pre></div>\n<ol start=\"3\">\n<li>\n<p>ExtTextOut(hdc, x, y,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">             fuOptions, - 텍스트 출력 옵션\n\n             &amp;rect  - 사각영역</code></pre></div>\n</li>\n</ol>\n<p>lpString,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                   cbCount,\n\n                   lpDx ) - 문자사이 공백값 배열 포인터(int pDx[]={5,6~~} pDx[i] 문자와 오른쪽문자 자간\n\n - 현재 선택된 글꼴, 배경색, 글자색을 이용하여 문자열을 그린다.\n\n - &amp;rect, lpDx 둘다 NULL인 경우 TextOut과 같은 기능이다.(TextOut을 내부적으로 보믄 ExtTextOut 호출함.)\n\n1) fuOptions : 어플리케이션이 정의한 사각형을 사용하는 방법을 지정한다.\n\n  ● ETO_CLIPPED : 텍스트가 주어진 사각형으로 클리핑 된다. 영역 안쪽에만 문자열이 출력된다.\n\n  ● ETO_OPAQUE : 현재의 배경 색상으로 채워질 배경 직사각형</code></pre></div>\n<ol start=\"4\">\n<li>\n<p>DrawText(hdc, pString, iCount, &#x26;rect, iFormat);</p>\n<ul>\n<li>\n<p>iFormat을 0으로 설정 : 윈도우즈는 텍스트를 캐리지 리턴문자(‘\\r’), 라인피드(‘\\n’)로 분리된 일련의 행으로 해석함</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                            DT_WORDBREAK : 사각영역의 오른쪽 끝에서 자동 개행되도록 한다.\n\n                            DT_NOCLIP : 사각영역의 경계를 벗어나도 문자열을 자르지 않고 그대로 출력</code></pre></div>\n</li>\n<li>\n<p>DrawTextEx(hdc, pString, iCount, &#x26;rect, iFormat, &#x26;drawtextparams)</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>typedef struct tagDRAWTEXTPARAMS\n{\nUINT cbSize; // 구조체의 크기\nint iTabLength; // 각 탭 정지점의 크기\nint iLeftMargin; //왼쪽 여백\nint iRightMargin; //오른쪽 여백\nUINT uiLengthDrawn; // 처리된 문자들의 개수를 받는다.\n} DRAWTEXTPARAMS, FAR *LPDRAWTEXTPARAMS;</p>\n<ul>\n<li>\n<p>DWORD GetSysColor(nIndex) : nIndex - 지정된 시스템 칼라를 취득함.(COLOR_MENU, COLOR_WINDOW)</p>\n</li>\n<li>\n<p>현재글자간의 간격</p>\n<ul>\n<li>\n<p>SetTextCharacterExtra(hdc, iExtra) - iExtra 논리단위로서 윈도우는 Pixel로 변환(글자간의 간격을 변경)</p>\n</li>\n<li>\n<p>GetTextCharacterExtra(hdc)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>폰트만들기</p>\n</li>\n</ul>\n<p>typedef struct tagLOGFONTW\n{\nLONG lfHeight;\nLONG lfWidth;\nLONG lfEscapement; // 문자열 각도\nLONG lfOrientation; // 개별 문자의 각도\nLONG lfWeight; // 문자의 굵기\nBYTE lfItalic; // 기울기\nBYTE lfUnderline; // 밑줄\nBYTE lfStrikeOut; // 취소선\nBYTE lfCharSet; // 문자셋\nBYTE lfOutPrecision; // 출력정확도(폰트의 높이, 폭, 피치등에 근접한 폰트를 찾을지 지정함)\nBYTE lfClipPrecision; //클리핑 영역을 벗어날 때의 처리방법\nBYTE lfQuality; // 출력품질(글꼴, 폰트의 외형을 중시)\nBYTE lfPitchAndFamily; // 피치 : 개별 글자의 폭, 폰트의 패밀리\nWCHAR lfFaceName[LF_FACESIZE]; //타입페이스 : 폰트의 이름\n} LOGFONTW, *PLOGFONTW, NEAR *NPLOGFONTW, FAR *LPLOGFONTW;</p>\n<p>-CreateFont의 인자값과 같다. LOGFONT 구조체는 CreateFontIndirect의 인자로 쓰이게 된다.</p>\n<ul>\n<li>\n<p>논리 폰트 : CreateFont 함수에 의해 만들어지는 폰트</p>\n<p>물리 폰트 : 운영체제나 장치에 실제로 존재하는 폰트</p>\n<p>스톡 폰트 : 운영체제에 의해 제공되는 폰트(GetStockObject)</p>\n</li>\n<li>\n<p>폰트열거</p>\n</li>\n</ul>\n<ol>\n<li>폰트 열거 함수</li>\n</ol>\n<ol>\n<li>\n<p>int EnumFontFamilies(HDC hdc, LPCTSTR lpszFamily, FONTENUMPROC lpEnumFontFamProc, LPARAM lParam)</p>\n<p>lpszFamily : 조사하고자 하는 폰트 패밀리 지정함(값이 NULL이면 모든 패밀리를 조사한다.)</p>\n<p>lpEnumFontFamProc : 발견된 폰트의 특성을 알려줌</p>\n</li>\n<li>\n<p>int CALLBACK EnumFontFamProc(ENUMLOGFONT FAR *lpelf, NEWTEXTMETRIC FAR *lpntm, int FontType, LPARAM lParam)</p>\n<p>ENUMLOGFONT - LOGFONT 구조체, ElFullName - 폰트타입 문자열,</p>\n<p>NEWTEXTMETRIC : 폰트의 여러가지 특성값을 가지고 있음.</p>\n<p>FontType : 폰트의 종류(장치, 래스터, 트루타입)</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>물리폰트</p>\n<ol>\n<li>\n<p>BOOL GetTextMetrics(HDC hdc, LPTEXTMETRIC lptm) : 개별 문자의 폭이나 높이에 대한 정보를 구한 후 간격을 적당히 띄우고자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                                                            할 때 사용함.( hdc에 현재 선택된 물리 폰트의 여러 가지 정보)</code></pre></div>\n<ul>\n<li>\n<p>예) GetTextMetrics(hdc, &#x26;tm)</p>\n<p>TextOut(hdc, 0, i*(tm.tmHeight), str, lstrlen(str));</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>BOOL GetTextExtentPoint32(HDC hdc, LPCTSTR lpString, int cbString, LPSIZE lpSize) : 문자열이 크기 구하기 위해서 사용됨.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> - \"ijl\", \"BMW\" 같은 세문자지만 전체 폭은 다르다. 이때 쓰이게 된다.\n\n - 예) GetTextExtentPoint32(hdc, str, lstrlen(str), &amp;sz)\n\n         x += sz.cx;\n\n         TextOut(hdc, x,0, str, lstrlen(str));</code></pre></div>\n</li>\n<li>\n<p>폰트의 설치</p>\n<ul>\n<li>\n<p>lpszFilename : 추가/삭제할 폰트의 경로를 전달해준다. (Windows\\Font)</p>\n</li>\n<li>\n<p>int AddFontRsource( LPCTSTR lpszFilename)</p>\n<p>● 설치과정</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. 폰트파일을 Font 폴더로 복사\n\n2. 폰트등록:AddFontResource\n\n3. WM_FONTCHANGE 방송\n\n   SendMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);\n\n4. 레지스트리에 폰트 이름 기록</code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>폰트의 삭제</p>\n<ul>\n<li>\n<p>BOOL RemoveFontResource(LPCTSTR lpFileName)</p>\n<p>● 설치과정</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">등록된 폰트를 취소:RemoveFontResource - WM_FONTCHANGE 방송 - 레지스트리에 폰트 이름 삭제 - 폰트파일을 삭제</code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>BOOL GetVersionEx(LPOSVERSIONINFO lpVersionInformation)</p>\n<ul>\n<li>현재 작동하고 있는 OS의 버전 정보를 제공하는 API</li>\n</ul>\n<ol>\n<li>\n<p>OSVERSIONINFO</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> typedef struct _OSVERSIONINFOW {\nDWORD dwOSVersionInfoSize; //Version Info 사이즈\nDWORD dwMajorVersion;        // OS Version 2.1 -2\nDWORD dwMinorVersion;        //OS Version 2.1 -1\nDWORD dwBuildNumber;\nDWORD dwPlatformId;            // OS platformID -VER_PLATFORM_NT, VER_PLATFORM_WIN32_C3 등\nWCHAR  szCSDVersion[ 128 ];     // OS에 추가적인 정보</code></pre></div>\n<p>} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW;</p>\n</li>\n</ol>\n</li>\n<li>\n<p>패스</p>\n<ul>\n<li>\n<p>GDI 함수들에 의해 그려진 도형의 모양</p>\n</li>\n<li>\n<p>패스는 핸들을 가지지 않고 그려지는데 그것은 여러 개의 패스를 만들어 놓고 교체해 가며 사용할 수 없다는 뜻이다.</p>\n</li>\n<li>\n<p>BeginPath(HDC) 와 EndPath(hWnd) 사이를 패스괄호라고 칭하였고, 이때 GDI함수는 출력을 내보내지 않고 패스에 기록하게 된다.</p>\n</li>\n</ul>\n<p>StrokePath(HDC): 외곽선, FillPath(HDC) : 패스의 내부, StrokeAndFillPath(HDC) : 외곽선과 패스 내부</p>\n<ul>\n<li>클립패스</li>\n</ul>\n<ol>\n<li>SelectClipPath(HDC, iMode)</li>\n</ol>\n<ul>\n<li>SelectClipPath(hdc, RGN_COPY); //RGN_COPY : 핸재 패스가 새 클리핑 영역으로 선택됨</li>\n</ul>\n<ol start=\"2\">\n<li>PathToRegion(hdc) - 패스를 리전으로 바꿀 때 사용함(&#x3C;예hRgn = PathToRegion(hdc) )</li>\n</ol>\n</li>\n<li>\n<p>확장펜</p>\n</li>\n</ul>\n<ul>\n<li>ExtCreatePen(dwPenStyle, dwWidth, LOGBRUSH, dwStyleCount, lpStyle)</li>\n</ul>\n<ol>\n<li>\n<p>PenStyle : PS_SOLID, PS_JOIN_ROUND등 스타일 지정</p>\n</li>\n<li>\n<p>dwWidth : 선의 굵기</p>\n</li>\n<li>\n<p>LOGBRUSH : 구조체안에서 선의 무늬, 스타일 지정</p>\n</li>\n<li>\n<p>dwStyleCount, lpStyle : PS_USERSTYLE 지정(사용자 정의 선을 그을 때 사용 - 안쓸경우 : 인수 두개는 0, NULL로 처리)</p>\n<ul>\n<li>\n<p>dwStyleCount : lpStyle 배열의 크기</p>\n</li>\n<li>\n<p>lpStyle : 5픽셀 찍고 다음 5픽셀 찍지말고.</p>\n</li>\n</ul>\n<p>예) DWORD Style[] = {5,5,4,4,3,3,2,2,1,1};</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> hGeo = ExtCreatePen(PS_USERSTYLE|PS_GEOMETRIC, 1, &amp;logBrush, 10, Style)</code></pre></div>\n</li>\n</ol>\n<h1 id=\"다중문서-인터페이스\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%A4%91%EB%AC%B8%EC%84%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"다중문서 인터페이스 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다중문서 인터페이스</h1>\n<ul>\n<li>\n<p>다중문서 인터페이스(Multiple-Document Interface : MDI)</p>\n<ul>\n<li>\n<p>클라이언트 윈도우와 일반 윈도우 차이점</p>\n<ol>\n<li>\n<p>클라이언트 윈도우는 MDICLIENT로 고정되어 있다.</p>\n<p>CreateWindow(“MDICLIENT”~~), 운영체제에서 미리 정의되어 있으므로 윈도우 클래스 등록할 필요가 없다.</p>\n</li>\n<li>\n<p>클라이언트 윈도우는 CreateWindow 마지막 인자 lParam에 CLIENTCREATESTRUCT 구조체에 포인터를 넘겨야함.</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>TranslateMDISysAccel(hWndClient, lpMsg)</p>\n<ul>\n<li>WM_KEYDOWN, WM_SYSCOMMAND 메시지를 MDI 자식 윈도우에 보내는 역할을 한다.</li>\n</ul>\n</li>\n<li>\n<p>프레임 윈도우 메시지 처리 / 윈도우 메시지 처리</p>\n<ol>\n<li>인수차이</li>\n</ol>\n<ul>\n<li>\n<p>DefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)</p>\n</li>\n<li>\n<p>DefFrameProc(HWND hWnd,HWND hWndMDIClient,UINT Msg, WPARAM wParam, LPARAM lParam)</p>\n<p>=클라이언트 윈도우 핸들이 추가됨.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>메시지 처리</p>\n<ul>\n<li>프레임 윈도우 메시지 처리 후 return 0 대신 break문을 사용해서 처리해야함.(포커스 오류)</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>클라이언트 윈도우</p>\n<ol>\n<li>\n<p>GetSubMenu(GetMenu(), 1)</p>\n<p>메뉴 -기준으로</p>\n<p>서브메뉴 0 (File)</p>\n<p>서브메뉴 1 (Window)</p>\n</li>\n<li>\n<p>CLIENTCREATESTRUCT 설명</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>hWindowMenu : 차일드 목록 관리에 사용될 메뉴 ID</p>\n</li>\n<li>\n<p>idFirstChild : 첫번째 차일드 윈도우의 목록이 출력될 메뉴 항목(최대 9개까지 출력가능함)</p>\n</li>\n</ul>\n<p>ccs.hWindowMenu = GetSubMenu(GetMenu(hwnd), WINDOWMENU)\nccs.idFirstChild = IDM_WINDOWCHILD; // 메뉴에서 첫 차일드 항목 이후 9개의 id가 연속적으로 비어 있어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                                          그래서 따로 연속 될 수 있는 값으로 #define 해야한다.</code></pre></div>\n</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>CreateWindow에 스타일</p>\n<ul>\n<li>WS_CLIPCHILDREN 클라이언트 윈도우가 다시 그려질 시 자식 윈도우에 WM_PAINT 메시지를 보내지 못하게 하기 위해 세팅함.</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>클라이언트 윈도우, MDI 관련 구조체</li>\n</ul>\n<ul>\n<li>\n<p>응용프로그램이 MDI 클라이언트 윈도우를 생성하면 CLIENTCREATESTRUCT 구조체를 지정해줘야 합니다.</p>\n</li>\n<li>\n<p>MDI 클라이언트 윈도우가 MDI 자식 윈도우를 생성하면 MDICREATESTRUCT 구조체를 지정해야 합니다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>차일드(자식) 윈도우</p>\n<ol>\n<li>\n<p>차일드 윈도우 주의사항</p>\n<ul>\n<li>\n<p>차일드 윈도우는 메뉴를 가질 수 없으므로 lpszMenuName은 NULL이어야 한다.</p>\n</li>\n<li>\n<p>별도의 아이콘을 지정하는 것이 좋다.(최소화, 시스템 메뉴 구분)</p>\n</li>\n<li>\n<p>여분의 메모리를 남겨두어야 한다. (차일드 윈도우 파일이름이나 일련번호가 저장됨)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>자식윈도우 생성</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>MDICREATESTRUCT 속성 채우기</p>\n<ol>\n<li>\n<p>mcs.style = MDIS_ALLCHIDSTYLES</p>\n<p>=MDIS_ALLCHILDSTYLES : WS_MINIMIZE | WS_MAXMIZE | WS_HSCROLL | WS_VSCROLL</p>\n</li>\n<li>\n<p>WM_MDICREATE 를 SendMessage에 보내면 자식 윈도우 생성(lParam에 MDICREATESTRUCT 구조체 포인터전달)</p>\n</li>\n</ol>\n<p>typedef struct tagMDICREATESTRUCT {\nLPCTSTR szClass;\nLPCTSTR szTitle;\nHANDLE hOwner;\nint x;\nint y;\nint cx;\nint cy;\nDWORD style;\nLPARAM lParam;</p>\n</li>\n</ul>\n<p>} MDICREATESTRUCT, *LPMDICREATESTRUCT;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 3) HWND CreateMDIWindow(LPTSTR lpClassName, LPTSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth,\n\n     int nHeight, HWND hWndParent, HINSTANCE hInstacne, LPARAM lParam);</code></pre></div>\n</li>\n</ul>\n<ol start=\"3\">\n<li>자식 윈도우 바둑판식 정렬</li>\n</ol>\n<ul>\n<li>\n<p>WM_MDITILE 를 SendMessage에 보내면 자식 윈도우 생성</p>\n</li>\n<li>\n<p>MDITILE_HORIZONTAL 수평정렬, MDITILE_VERTICAL 수직정렬</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>자식 윈도우 계단식 정렬</li>\n</ol>\n<ul>\n<li>\n<p>WM_MDICASCADE 를 SendMessage에 보내면 자식 윈도우 생성</p>\n</li>\n<li>\n<p>wParam에 MDITILE_SKIPDISABLED 플래그를 주면 사용금지 된 차일드는 정렬대상에서 제외한다.</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li>자식 윈도우 아이콘 정렬</li>\n</ol>\n<ul>\n<li>\n<p>WM_MDIICONARRANGE 를 SendMessage에 보내면 자식 윈도우 생성</p>\n</li>\n<li>\n<p>최소화된 아이콘을 정렬함.</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li>마지막은 DefMDIChildProc를 불러서 처리해야함(DefWindowProc에 인수와 동일함.)</li>\n</ol>\n<ul>\n<li>\n<p>WndClass에서 cbWndExtra = sizeof(int) -여분의 메모리 지정가능.</p>\n</li>\n<li>\n<p>SetWindowLong(hWnd, 0, ChildNum) - 메모리 블록을 참조하는 포인터를 통해서 값들을 저장한다.</p>\n</li>\n</ul>\n<p>index : 윈도우에 여분 메모리가 있을 경우 여분 메모리의 오프셋을 지정할 수도 있다. 이 값은 반드시 양수여야 하며 cbWndExtra-4보다는 작아야 한다. 예를 들어 여분 메모리가 32바이트 지정되어 있으면 nIndex는 0~28까지 지정할 수 있다.</p>\n<p>=GetWindowLong(hWnd, 0)을 통해서 저장된 값을 확인할 수 있다.</p>\n<h1 id=\"멀티태스킹과-멀티스레딩--동기화\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9%EA%B3%BC-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9--%EB%8F%99%EA%B8%B0%ED%99%94\" aria-label=\"멀티태스킹과 멀티스레딩  동기화 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티태스킹과 멀티스레딩 &#x26; 동기화</h1>\n<ul>\n<li>\n<p>멀티태스킹 : 하나의 운영체제에 여러 개의 프로세스가 동시에 실행되는 환경</p>\n</li>\n<li>\n<p>멀티스레드 : 하나의 프로세스에서 여러 개의 스레드가 동시에 실행되는 환경</p>\n</li>\n<li>\n<p>스레드 : 프로세스 내의 명령어를 실행시켜주는 경로, 일련의 실행코드</p>\n<ol>\n<li>스레드 생성</li>\n</ol>\n<ul>\n<li>HANDLE CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreateFlags, lpThreadID)</li>\n</ul>\n</li>\n</ul>\n<p>1번째 인수 : 스레드 보안속성 지정(핸들끼리 상관하지 않는 한 NULL로 지정됨)</p>\n<p>2번째 인수 : 스레드의 스택의 크기(기본 1M 잡힘)</p>\n<p>3번째 인수 : 스레드의 시작주소</p>\n<p>4번째 인수 : 스레드로 전달하는 작업 내용</p>\n<p>5번째 인수 : 스레드 특성 지정(CREATE_SUSPENDED 플래그 지정시 스레드 만들고 실행X - ResumeThread 함수를 호출해야함)</p>\n<p>6번째 인수 : 스레드 ID</p>\n<p>2 스레드 특성</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 같은 프로세스 내의 스레드끼리는 주소공간, 전역변수, 코드를 공유함.</code></pre></div>\n<ol start=\"3\">\n<li>\n<p>스레드 상태 확인</p>\n<ul>\n<li>\n<p>BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)</p>\n<p>1번째 인수 : 대상 스레드 핸들</p>\n<p>2번째 인수 : 스레드의 종료 코드 조사해 리턴</p>\n</li>\n</ul>\n</li>\n<li>\n<p>스레드 종료</p>\n<ol>\n<li>\n<p>Return &#x26; ExitThread 차이점과 ExitThread 문제점</p>\n<ul>\n<li>차이점 :</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>문제점 : A,B 함수에 C++객체가 존재할 경우 C함수에서 ExitThread 함수로 종료시 A,B 함수의 소멸자가 호출되지 않아서\n메모리 유출현상이 발생되므로 가급적이면 쓰지 않고 Return 되도록 해야한다.</p>\n</li>\n<li>\n<p>ExitThread &#x26; TerminateThread 차이점</p>\n<ul>\n<li>\n<p>VOID ExitThread(DWORD dwExitCode) / BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)</p>\n<ol>\n<li>\n<p>ExitThread : 실행중인 스레드의 특정 위치에서 스레드를 종료</p>\n<p>TerminateThread 는 인수로 전달받은 스레드를 강제로 종료시킬 때 사용된다.</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>\n<p>스레드 중지/재실행</p>\n<ul>\n<li>\n<p>SuspendThread(HANDLE hThread) : 중지카운트 증가</p>\n</li>\n<li>\n<p>ResumeThread(HANDLE hThread) : 중지카운트 감소(0이 될 경우 재실행됨)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>UI 스레드</p>\n<ul>\n<li>\n<p>작업스레드 : 사용자 눈에 보이지 않고 내부적인 계산만 하고 사라지는 스레드</p>\n</li>\n<li>\n<p>UI 스레드 : 윈도우를 만들고, 메시지 큐와 메시지 루프를 가지는 스레드</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>예)</p>\n<p>RegisterClass(~)</p>\n<p>DWORD WINAPI ThreadFunc(LPVOID temp)</p>\n<p>{</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  CreateWindow(~);</code></pre></div>\n<p>while(GetMessage(~))</p>\n<p>{</p>\n<p>TranslateMessage</p>\n<p>DispatchMessage</p>\n<p>}</p>\n<p>}</p>\n<p>LRESULT CALLBACK DeCompProc(~)</p>\n<p>{</p>\n<p>…</p>\n<p>}</p>\n<ul>\n<li>\n<p>스레드 우선순위</p>\n<ul>\n<li>스레디의 우선 순위는 우선 순위 클래스, 우선 순위 레벨 두가지 값의 조합으로 결정함.</li>\n</ul>\n<ol>\n<li>\n<p>우선순위 클래스(프로세스) CreateProcess(6번째 인자 세팅)</p>\n<p>DWORD GetPriorityClass(HANDLE hProcess);</p>\n<p>BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass);</p>\n</li>\n<li>\n<p>우선순위 스레드(스레드)</p>\n<p>int GetThreadPriority(HANDLE hThread);</p>\n<p>BOOL SeThreadPriority(HAND hThread, int nPriority)</p>\n</li>\n</ol>\n</li>\n<li>\n<p>C런타임 라이브러리</p>\n</li>\n</ul>\n<ul>\n<li>C,C++ 코드로 작성하는 경우 WINAPI 제공하는 CreateThread 사용은 문제가 생길 수 있으므로 _beginThreadex, _endthreadex 써야함.</li>\n</ul>\n<ol>\n<li>\n<p>_beginthread, _beginthreadex 차이점</p>\n<p>_beingthread는 새로운 스레드 생성하고 난 후 내부적으로 CloseHandle 함수 호출되서 생성된 스레드 핸들러 제거시킴</p>\n<p>_beingthreadex 핸들을 리턴(형변환 해야함), CloseHandle 함수가 내부호출을 안하므로 명시적으로 함수를 호출해 줘야한다.</p>\n</li>\n</ol>\n<p>예)</p>\n<p>unsigned __stdcall SecondThreadFunc(void *pArg)</p>\n<p>{</p>\n<p>~</p>\n<p>_endthreadex(0);</p>\n<p>}</p>\n<p>void main()</p>\n<p>{</p>\n<p>HANDLE hThread;</p>\n<p>hThread = (HANDLE)_beginthreadex(NULL, 0, SecondThreadFunc, null, 0, &#x26;threadID);</p>\n<p>CloseHandle(hThread);</p>\n<p>}</p>\n<ul>\n<li>TLS(스레드 지역 저장소)</li>\n</ul>\n<ol>\n<li>TLS(Thread Local Storage)</li>\n</ol>\n<ul>\n<li>전역변수나 정적변수에 스레드가 공유하는 문제점을 해결하기 위해서 나오게 되었음</li>\n</ul>\n<ol start=\"2\">\n<li>TLS 함수</li>\n</ol>\n<ul>\n<li>\n<p>인덱스 값 얻어오기(슬롯 할당) / 슬롯 해제하기</p>\n<p>TlsIndex= TlsAlloc(); TlsFree(TlsIndex);</p>\n</li>\n<li>\n<p>슬롯에 값 세팅 / 슬롯 값 얻어오기</p>\n<p>TlsSetValue(TlsIndex, (LPVOID)0); tcount=(int)TlsGetValue(TlsIndex)+1;</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>동기화</p>\n<ul>\n<li>복수 개의 스레드가 보조를 맞추어 실행하도록 함으로써 경쟁 상태나 교착상태를 해소하는 것</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>DeadLock(교착상태) - 대기 상태가 종료되지 않아 무한정 대기만 하는 비정상적인 상태</li>\n</ol>\n<p>ThreadFunc1</p>\n<p>EnterCriticalSection(&#x26;crit1); - 1</p>\n<p>EnterCriticalSection(&#x26;crit2); - 3</p>\n<p>LeaveCriticalSection(&#x26;crit2);</p>\n<p>LeaveCriticalSection(&#x26;crit1);</p>\n<p>ThreadFunc2</p>\n<p>EnterCriticalSection(&#x26;crit2);</p>\n<p>EnterCriticalSection(&#x26;crit1); - 2</p>\n<p>LeaveCriticalSection(&#x26;crit1);</p>\n<p>LeaveCriticalSection(&#x26;crit2);</p>\n<ol start=\"2\">\n<li>\n<p>크리티컬 섹션/ 뮤텍스/ 세마포어 차이점</p>\n<ol>\n<li>\n<p>크리티컬 섹션 : 유저모드 객체, 가볍고 빠르다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                   같은 Process 내의 Thread 동기화 지원</code></pre></div>\n</li>\n<li>\n<p>뮤텍스, 세마포어 : 커널모드 객체, 상대적으로 무겁고 느린편</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                       여러 Process의 Thread간의 동기화를 지원</code></pre></div>\n</li>\n<li>\n<p>뮤텍스, 세마포어 차이점 : 뮤텍스는 임계구역 접근 Thread는 한개</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                                 세마포어 임계구역 접근 Thread 갯수 조절</code></pre></div>\n</li>\n</ol>\n</li>\n<li>\n<p>CriticalSection(임계영역)</p>\n<ul>\n<li>\n<p>중단해서는 안되는 코드 블록</p>\n</li>\n<li>\n<p>CRITICAL_SECTION 함수</p>\n<ol>\n<li>\n<p>InitializeCriticalSection, DeleteCriticalSection - 초기화 / 파괴</p>\n</li>\n<li>\n<p>EnterCriticalSection, LeaveCriticalSection - 구간의 시작을 명시 / 섹션을 빠져나올 구간</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>뮤텍스</p>\n<ul>\n<li>\n<p>WaitForSingleObject, WaitForMultiIObject</p>\n</li>\n<li>\n<p>CreateMutex, OpenMutex, ReleaseMutex</p>\n</li>\n</ul>\n</li>\n<li>\n<p>세마포어</p>\n</li>\n</ol>\n<ul>\n<li>CreateSemaphore, OpenSemaphore, ReleaseSemaphore\nCreateSemaphore 2번째 인자 : 임계영역 갯수, 3번째 인자 : 임계영역 접근 갯수</li>\n</ul>\n<ol start=\"4\">\n<li>이벤트</li>\n</ol>\n<ul>\n<li>CreateEvent, OpenEvent, SetEvent, ResetEvent\n<ol>\n<li>2번째 인자\nTRUE : 수동리셋 이벤트 FALSE 자동리셋 이벤트</li>\n<li>3번째 인자\nTRUE : 이벤트를 생성함과 동시에 신호상태를 만든다.</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"동적링크라이브러리\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%A0%81%EB%A7%81%ED%81%AC%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC\" aria-label=\"동적링크라이브러리 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동적링크라이브러리</h1>\n<ul>\n<li>\n<p>정적링크 &#x26; 동적링크</p>\n</li>\n<li>\n<p>DLL 사용 장점</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>여러 프로그램이 동시에 사용하기 때문에 메모리 절약</p>\n</li>\n<li>\n<p>DLL을 사용하는 프로그램은 크기가 작다.(정정링크 실행파일이 커진다.)</p>\n</li>\n<li>\n<p>DLL을 교체하여 프로그램의 성능을 향상시키기 쉽다.(교체시 DLL만 바꾸면됨)</p>\n</li>\n<li>\n<p>리소스 교체가 가능(다국어버전)</p>\n</li>\n<li>\n<p>디버깅 용이(DLL 버그 없다는 것을 가정)</p>\n</li>\n<li>\n<p>혼합 프로그래밍 가능(어떤 개발툴과도 호환가능)</p>\n</li>\n<li>\n<p>프로그래머끼리 분담 작업이 용이하며 재사용도 뛰어나다</p>\n</li>\n</ol>\n<ul>\n<li>DLL 사용단점</li>\n</ul>\n<ol>\n<li>\n<p>DLL 없다거나 손상된 경우 실행이 불가능</p>\n</li>\n<li>\n<p>DLL 버전 변경 시 프로그램 호환이 안될 경우 발생</p>\n</li>\n</ol>\n<ul>\n<li>DLL Export 되는 함수 / DLL Import 하는 함수</li>\n</ul>\n<ol>\n<li>\n<p>extern “C” **declspec(dllexport) 함수 원형 -**declspec : 함수에 대한 정보를 제공</p>\n<p>extern “C” __declspec(dllimport) 함수 원형</p>\n</li>\n</ol>\n<ul>\n<li>임포트 라이브러리 : 실제 코드는 없고 함수에 대한 위치 정보만 저장함.</li>\n</ul>\n<ul>\n<li>\n<p>DLL 파일 찾는 순서</p>\n<p>=1. 클라이언트 프로그램이 포함된 디렉토리</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 2. 프로그램의 현재 디렉토리\n\n 3. 윈도우즈의 시스템 디렉토리\n\n 4. 윈도우즈 디렉토리\n\n 5. PATH 환경 변수가 지정하는 모든 디렉토리</code></pre></div>\n</li>\n</ul>\n<ul>\n<li>\n<p>임포트 라이브러리 지정 : #pragma comment(lib, “MyDll.lib”)</p>\n</li>\n<li>\n<p>명시적 연결(DLL을 명시적으로 읽고 사용)</p>\n<ol>\n<li>\n<p>HINSTANCE LoadLibrary(LPCTSTR lpLibFileName)</p>\n</li>\n<li>\n<p>FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)</p>\n</li>\n</ol>\n<p>hInst = LoadLibrary(TEXT(“MyDll.dll”));</p>\n<p>pFunc = (int (*)(int, int))GetProcAddress(hInst,“AddInteger”);</p>\n</li>\n<li>\n<p>명시적 연결 장/단점</p>\n<ol>\n<li>\n<p>필요할 때만 DLL을 읽어와 사용하기 때문에 메모리와 리소스가 절약된다.</p>\n</li>\n<li>\n<p>사용할 DLL을 교체(DLL 이름만 상황에 맞게 교체)</p>\n</li>\n<li>\n<p>필요한 DLL이 없는 경우에도 프로그램 실행가능</p>\n</li>\n<li>\n<p>클라이언트 프로그램 시작이 빠르다.</p>\n</li>\n</ol>\n<p>단점 : 함수 호출 속도가 느려진다.</p>\n</li>\n<li>\n<p>DllMain 함수</p>\n<p>BOOL WINAPI DllMain(HINSTANCE hInst, DWORD fdwReason, LPVOID lpRes);</p>\n<p>-DLL이 처음 메모리에 올라오고 제거시에 위 함수가 호출됨.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fdwReason : 함수가 호출된 이유\n\n1) DLL_PROCESS_ATTACH / DLL_PROCESS_DETACH\n\n    DLL_THREAD_ATTACH / DLL_THREAD_DETACH</code></pre></div>\n</li>\n</ul>\n<h1 id=\"메모리\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"메모리 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리</h1>\n<ul>\n<li>\n<p>C 런타임 함수 ( 물리적인 메모리 소비)</p>\n<ul>\n<li>\n<p>void *malloc(size_t size);</p>\n<p>void *calloc(size_t num, size_t size); // 필요한 메모리 양을 논리적으로 표현</p>\n<p>void *realloc (void *memblock, size_t size); // 이미 할당한 메모리를 더 크게 할당하고 축소할 때</p>\n<p>void free(void* memblock);</p>\n</li>\n</ul>\n</li>\n<li>\n<p>가상메모리 할당</p>\n<ol>\n<li>장점</li>\n</ol>\n<ul>\n<li>\n<p>메모리 예약 할당 가능( 물리메모리 소비하지 않으면서 할당가능)</p>\n</li>\n<li>\n<p>할당한 메모의 액세스 권한 설정가능</p>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">  LPVOID VirtualAlloc(LPVOID lpAdress, DWORD dwSize, DWORD flallocationType, DWORD flProtect);\n\n  BOOL VirtualFree(LPVOID lpAddress, DOWRD dwSize, DWORD dwFreeType);\n\n  ptr = (int*)VirtualAlloc(NULL, sizeof(int)*10, MEM_RESERVE|MEM_COMMT, PAGE_REDWRITE);\n\n  wsprintf(str &quot;%d&quot;, ptr[i]*i*2);\n\n  TextOut(hdc, 10, i\\*20, str, lstrlen(str));\n\n  VirtualFree(ptr, sizeof(int)\\*10, MEM_DECOMMIT);\n\n  VirtualFree(ptr, 0, MEM_RELEASE);</code></pre></div>\n<h1 id=\"동기화\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EA%B8%B0%ED%99%94\" aria-label=\"동기화 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동기화</h1>\n<ol>\n<li>동기화 필요성</li>\n</ol>\n<ul>\n<li>단일 프로세서를 이용한 선점형 멀티스레딩 시스템은 여러개의 스레드가 마치 동시에 수행되는 것처럼 보이지만 오직 하나의 스레드만 실행됨 그럴때 공유자원에 대한 스레드의 선점에 문제가 발생하는 것을 해결하기 위해서 동기화가 필요해졌다.</li>\n</ul>\n<ol start=\"2\">\n<li>동기화함수</li>\n</ol>\n<ol>\n<li>\n<p>크리티컬 세션 : 유저레벨 동기화(커널 객체x), 동일한 프로세스내에서만 사용, 속도 높음</p>\n</li>\n<li>\n<p>뮤텍스 : 커널객체 사용(CreateMutex, OpenMutex, ReleaseMutex, CloseHandle), 하나의 공유자원 보호</p>\n<ul>\n<li>포기된 뮤텍스 : 뮤텍스 점유 중 스레드를 죽이는 Terminatethread, ExitThread 사용할 경우 -waitforsingleobject return 값이 WAIT_ABANDONED 리턴함.</li>\n</ul>\n</li>\n<li>\n<p>세마포어 : 사용가능한 자원의 갯수를 카운트 하는 동기화 객체( CreateSemaphore, OpenSemaphore, ReleaseSemaphore)</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>이벤트</li>\n</ol>\n<ol>\n<li>\n<p>스레드간의 작업순서나 시기조정, 신호를 보냄</p>\n</li>\n<li>\n<p>CreateEvent(. bManualReset,,) bManualReset = True 수동(ResetEvent, SetEvent 사용해야함) False 자동</p>\n</li>\n</ol>","frontmatter":{"title":"Windows API","date":"2020.02.16","category":"개발","tags":["windows"]},"tableOfContents":"<ul>\n<li><a href=\"#windows-programming\">windows programming</a></li>\n<li><a href=\"#%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C\">유니코드</a></li>\n<li><a href=\"#%EC%9C%88%EB%8F%84%EC%9A%B0%EC%A6%88%EC%99%80-%EB%A9%94%EC%8B%9C%EC%A7%80\">윈도우즈와 메시지</a></li>\n<li><a href=\"#%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%B6%9C%EB%A0%A5\">텍스트 출력</a></li>\n<li><a href=\"#%EA%B7%B8%EB%A6%AC%EA%B8%B0-%EA%B8%B0%EC%B4%88\">그리기 기초</a></li>\n<li><a href=\"#%ED%82%A4%EB%B3%B4%EB%93%9C\">키보드</a></li>\n<li><a href=\"#%EB%A7%88%EC%9A%B0%EC%8A%A4\">마우스</a></li>\n<li><a href=\"#%ED%83%80%EC%9D%B4%EB%A8%B8\">타이머</a></li>\n<li><a href=\"#%EC%9E%90%EC%8B%9D-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4\">자식 윈도우 컨트롤</a></li>\n<li><a href=\"#%EB%A9%94%EB%89%B4%EC%99%80-%EA%B7%B8%EB%B0%96%EC%97%90-%EB%A6%AC%EC%86%8C%EC%8A%A4\">메뉴와 그밖에 리소스</a></li>\n<li><a href=\"#%EB%8C%80%ED%99%94%EC%83%81%EC%9E%90\">대화상자</a></li>\n<li><a href=\"#%ED%81%B4%EB%A6%BD%EB%B3%B4%EB%93%9C\">클립보드</a></li>\n<li><a href=\"#%ED%94%84%EB%A6%B0%ED%84%B0\">프린터</a></li>\n<li><a href=\"#%EB%B9%84%ED%8A%B8%EB%A7%B5%EA%B3%BC-bitblt%ED%95%A8%EC%88%98\">비트맵과 Bitblt함수</a></li>\n<li><a href=\"#%EC%9E%A5%EC%B9%98%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%B8%EB%B9%84%ED%8A%B8%EB%A7%B5\">장치독립적인비트맵</a></li>\n<li><a href=\"#%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80-%ED%8F%B0%ED%8A%B8\">텍스트와 폰트</a></li>\n<li><a href=\"#%EB%8B%A4%EC%A4%91%EB%AC%B8%EC%84%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">다중문서 인터페이스</a></li>\n<li><a href=\"#%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9%EA%B3%BC-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9--%EB%8F%99%EA%B8%B0%ED%99%94\">멀티태스킹과 멀티스레딩 &#x26; 동기화</a></li>\n<li><a href=\"#%EB%8F%99%EC%A0%81%EB%A7%81%ED%81%AC%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC\">동적링크라이브러리</a></li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC\">메모리</a></li>\n<li><a href=\"#%EB%8F%99%EA%B8%B0%ED%99%94\">동기화</a></li>\n</ul>"}}]}},"pageContext":{"slug":"/blog/2020/02/2020-02-16-winapi/","previous":{"fields":{"slug":"/blog/2020/02/2020-02-17-c-c++/"},"frontmatter":{"title":"C/C++"}},"next":{"fields":{"slug":"/blog/2020/02/2020-02-14-mssql/"},"frontmatter":{"title":"MSSQL"}}}},"staticQueryHashes":["3940312266","4157816502"],"slicesMap":{}}