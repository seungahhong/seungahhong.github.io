{"componentChunkName":"component---src-components-templates-post-template-tsx","path":"/blog/2020/02/2020-02-14-mssql/","result":{"data":{"site":{"siteMetadata":{"title":"홍승아 기술 블로그","description":"홍승아 기술 블로그에 오신걸 환영합니다.","author":"홍승아","type":"website","siteUrl":"https://seungahhong.github.io","social":{"facebook":"https://www.facebook.com/people/%ED%99%8D%EC%8A%B9%EC%95%84/100002349562000/","github":"https://github.com/seungahhong","notion":"https://material-debt-c1c.notion.site/daa60481e37840ea9e1b7e1b12269942","linkedin":"https://www.linkedin.com/in/seungahhong/"}}},"allFile":{"edges":[{"node":{"name":"facebook","publicURL":"/static/b185e9b61bb465d92b14ed1c9a9ded61/facebook.svg","childImageSharp":null}},{"node":{"name":"github","publicURL":"/static/4a6687a74051de2b3536e95d0b6c992a/github.svg","childImageSharp":null}},{"node":{"name":"linkedin","publicURL":"/static/3dc9e0d0f748678205218f1c72941cc2/linkedin.svg","childImageSharp":null}},{"node":{"name":"notion","publicURL":"/static/19b0f81386812ed2f2f3a7aea202935f/notion.svg","childImageSharp":null}},{"node":{"name":"background","publicURL":"/static/77f5c833c2343c992fd263c780495905/background.jpg","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,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"},"images":{"fallback":{"src":"/static/77f5c833c2343c992fd263c780495905/c2a83/background.jpg","srcSet":"/static/77f5c833c2343c992fd263c780495905/9330e/background.jpg 139w,\n/static/77f5c833c2343c992fd263c780495905/53b4d/background.jpg 278w,\n/static/77f5c833c2343c992fd263c780495905/c2a83/background.jpg 555w","sizes":"(min-width: 555px) 555px, 100vw"},"sources":[{"srcSet":"/static/77f5c833c2343c992fd263c780495905/3ee68/background.webp 139w,\n/static/77f5c833c2343c992fd263c780495905/d0ff1/background.webp 278w,\n/static/77f5c833c2343c992fd263c780495905/21b9c/background.webp 555w","type":"image/webp","sizes":"(min-width: 555px) 555px, 100vw"}]},"width":555,"height":961}}}}]},"allMarkdownRemark":{"edges":[{"node":{"html":"<h1 id=\"용어정리\" style=\"position:relative;\"><a href=\"#%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC\" aria-label=\"용어정리 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>용어정리</h1>\n<ul>\n<li>\n<p>트랜잭션 : 여러 데이터 변경에 대해 하나의 논리적 작업 단위로 취급하여 전체가 완료되거나 롤백되어 데이터의 무결성을 유지</p>\n</li>\n<li>\n<p>COMMIT : 모든 트랜잭션 수정이 영구적으로 데이터베이스 일부로 적용, 트랜잭션에 의해 사용된 리소스 해제</p>\n</li>\n<li>\n<p>ROLLBACK : 시작 상태로 되돌려서 트랜잭션 중 만드러진 모든 수정 내용을 취소</p>\n</li>\n<li>\n<p>트리거 : 특정 테이블에 자료가 수정될 때 내부적으로 관련된 다른 테이블 또는 컬럼에 자동으로 연동하여 갱신하거나 무결성 유지</p>\n</li>\n<li>\n<p>커서 : 메모리상에서 SQL문이 실행되는 위치\n메모리에 존재하는 SQL문 실행결과를 바로 접근하여 fetch 가능(SELECT * FROM A)\n현재 처리하고 있는 row</p>\n</li>\n</ul>\n<h1 id=\"sql-server-개요\" style=\"position:relative;\"><a href=\"#sql-server-%EA%B0%9C%EC%9A%94\" aria-label=\"sql server 개요 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL Server 개요</h1>\n<ul>\n<li>\n<p>데이터베이스 : 사용자에게 필요한 데이터와 정보를 효율적으로 저장 관리하고 통합적으로 조직하고 관리 할 수 있도록 구성된 데이터</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                  집합체</code></pre></div>\n</li>\n<li>\n<p>관계형 데이터베이스</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>연관된 데이터가 하나의 테이블에 모두 들어 있는 것이 아니라 여러 개의 서로 다른 테이블로 관리하고 데이터 사이에 어떠한 관계를</p>\n<p>부여함으로 데이터를 조직화하는 데이터베이스</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>SQL Server 서비스</p>\n<ul>\n<li>데이터베이스 엔진으로서 Transact-SQL 문을 처리하고, 서버 상의 데이터베이스를 구성하는 모든 파일을 관리한다.</li>\n</ul>\n</li>\n<li>\n<p>SQL Sever Agent</p>\n<ul>\n<li>\n<p>자동화 관리와 관련된 서비스로 작업,경고,오퍼레이터 등을 생성하여 관리를 자동화한다.</p>\n</li>\n<li>\n<p>예를들면, 로그가 90% 이상이면 경고를 발생시키고 경고가 발생하면 데이터베이스 로그를 백업한다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>MS DTC(Microsoft Distributd Transaction Coordinator)</p>\n<ul>\n<li>분산된 데이터를 하나의 트랜잭션으로 처리하기 위해서 일련의 작업</li>\n</ul>\n</li>\n<li>\n<p>전체 텍스트 검색(Full-Text Search)</p>\n<ul>\n<li>\n<p>마이크로소프트 검색 서비스로 텍스트와 문자열에 대한 조회를 다양한 조건으로 쿼리를 수행</p>\n</li>\n<li>\n<p>기능을 사용하기 위해서는 전체 텍스트 인덱스를 만들고 유지보수 해야한다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>분석서버</p>\n<ul>\n<li>\n<p>Microsoft SQL Server 2000 Analysis Services의 서버 구성 요소로서 데이터웨어하우스 및 데이터마트에 대한 신속한 분석 액세스를</p>\n<p>제공</p>\n</li>\n</ul>\n</li>\n<li>\n<p>데이터베이스 개체</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>인덱스 : 데이터 검색에 빠른 처리를 할 수 있게 하거나 데이터 무결성을 강화하기 위해서 사용되는 개체</p>\n<p>데이터무결성 : 데이터의 정확성과 일관성을 유지하고 보증하는 것</p>\n</li>\n<li>\n<p>뷰 : 자주 사용되는 쿼리나 복잡한 쿼리를 재사용하기 위해 정의해 놓은 가상 테이블</p>\n</li>\n<li>\n<p>트리거 : 데이트가 변경될 때 자동적으로 실행되는 특별한 형태의 저장 프로시저</p>\n</li>\n<li>\n<p>룰 : CHECK 제약 조건과 같은 역할을 수행하며, 테이블의 컬럼이나 사용자 정의 데이터형과 바인딩하여 사용된다.</p>\n<p>EXEC sp_bindrule ‘ZipCode_rule’, ‘ZipCode’</p>\n</li>\n</ol>\n<ul>\n<li>시스템 데이터베이스 목적</li>\n</ul>\n<ol>\n<li>\n<p>Master : 서버와 관련된 모든 자료를 저장한다.</p>\n</li>\n<li>\n<p>TempDB : 임시테이블을 만들거나 ORDER BY, DISTINCT 등의 구문을 동반시 임시 작업 공간으로 사용</p>\n</li>\n<li>\n<p>Model : 새로운 데이터베이스 생성시 모델이 되는 데이터베이스</p>\n</li>\n<li>\n<p>MSDB : 자동화 관리와 관련된 내용을 기록한다.</p>\n</li>\n<li>\n<p>Distribution : 복제를 설정하였을 때 로그 분배를 위해 사용한다.</p>\n</li>\n</ol>\n<h1 id=\"transact-sql-기초\" style=\"position:relative;\"><a href=\"#transact-sql-%EA%B8%B0%EC%B4%88\" aria-label=\"transact sql 기초 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Transact-SQL 기초</h1>\n<ul>\n<li>SQL 구문의 종류</li>\n</ul>\n<ul>\n<li>\n<p>데이터 관리언어(DML) : 데이터입력, 조회, 수정, 삭제(INSERT, SELECT, UPDATE, DELETE)</p>\n</li>\n<li>\n<p>데이터 정의언어(DDL) : 데이터 베이스의 특성과 속성을 정의, 테이블, 인덱스,뷰 등 생성과 수정,삭제(CREATE, ALTER, DROP)</p>\n</li>\n<li>\n<p>데이터 조작언어(DCL) : 데이터베이스 개체에 대한 사용권한을 제어(GRANT,REVOKE,DENY)</p>\n</li>\n</ul>\n<ul>\n<li>컬럼 별칭 세가지 방법</li>\n</ul>\n<p>SELECT GETDATE() AS 일시, 2 수량, 단가=450</p>\n<ul>\n<li>식별자</li>\n</ul>\n<ul>\n<li>\n<p>데이터 베이스 개체 이름</p>\n</li>\n<li>\n<p>예약어나 특수문자가 포함된 경우 식별자 구분을 위해서 구분자 사용함.</p>\n</li>\n<li>\n<p>구분자는 [] , \"\"(SET QUOTED_IDENTIFIER ON 세션 옵션 설정, OFF일 경우 문자열로 사용)</p>\n</li>\n</ul>\n<p>SELECT *</p>\n<p>FROM [MY TABLE] // 공백 문자 포함의 경우 구분</p>\n<p>WHERE [ORDER] = 10 // 일부예약어의 경우 구분</p>\n<ul>\n<li>\n<p>논리연산자 : 우선순위 -NOT, AND, OR</p>\n</li>\n<li>\n<p>ORDER BY( 조회자료 정렬)</p>\n</li>\n</ul>\n<ul>\n<li>제약사항 : ntext, text, image ORDER BY 절 사용못함.</li>\n</ul>\n<p>SELECT type, AVG(price) AS avgPrice</p>\n<p>FROM titles</p>\n<p>WHERE royalty = 10</p>\n<p>GROUP BY type</p>\n<p>HAVING AVG(price) &#x3C; 80</p>\n<ul>\n<li>DISTINCT와 GROUP BY절</li>\n</ul>\n<ul>\n<li>\n<p>DISTINCT는 주로 UNIQUE(중복을 제거)한 컬럼이나 레코드를 조회</p>\n</li>\n<li>\n<p>GROUP BY는 데이터를 그룹핑해서 그 결과를 가져옴.</p>\n</li>\n</ul>\n<p>예)</p>\n<p>– DISTINCT를 사용한 중복 데이터 제거\nSELECT DISTINCT deptno FROM emp;</p>\n<p>– GROUP BY를 사용한 중복 데이터 제거\nSELECT deptno FROM emp GROUP BY deptno;</p>\n<h2 id=\"deptno\" style=\"position:relative;\"><a href=\"#deptno\" aria-label=\"deptno permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DEPTNO</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">30\n20\n10</code></pre></div>\n<ol>\n<li>\n<p>언제 사용되나?</p>\n<p>GROUP BY : 집계함수를 사용하여 특정 그룹으로 구분 할 때는 절을 사용</p>\n<p>DISTINCT : 특정 그룹 구분없이 중복된 데이터를 제거할 경우에 사용</p>\n</li>\n</ol>\n<p>예)\nSELECT COUNT(DISTINCT d.deptno) “중복제거 수”,\nCOUNT(d.deptno) “전체 수”\nFROM emp e, dept d\nWHERE e.deptno = d.deptno;</p>\n<p>– 집계 함수가 필요한 경우는 GROUP BY를 사용해야 한다.\nSELECT deptno, MIN(sal)\nFROM emp\nGROUP BY deptno;</p>\n<ul>\n<li>SELECT INTO / INSERT INTO 차이점</li>\n</ul>\n<ul>\n<li>SELECT INTO : 원본이 있고, 대상 테이블을 새롭게 생성하려는 경우 사용(원본 테이블만 있으면 됨 - 복사되므로)</li>\n<li>INSERT INTO : 원본테이블과 복사하는 테이블 둘다 있을 때 사용해야함</li>\n</ul>\n<ol>\n<li>언제 사용되나?</li>\n</ol>\n<ul>\n<li>\n<p>SELECT INTO : 복잡한 작업을 하는 경우에 원본 테이블을 그대로 두면서 임시 테이블을 만들어서 하위작업을 하는데 주로 사용됨.</p>\n</li>\n<li>\n<p>INSERT INTO : 원본 테이블의 자료를 복사하기 위해서 사용됨</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>SELECT INTO 사용법</p>\n<p>-원본 있고, 대상 테이블을 새롭게 생성하려는 경우 사용</p>\n<p>-SELECT * INTO AA FROM A</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  -A테이블과 같은 컬럼과 데이터를 가지는 AA라는 테이블 생성</code></pre></div>\n<p>1-1 A테이블의 특정 컬럼만 가져오고 싶다면,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">      SELECT * INTO AA\n\n         FROM ( SELECT COL1, COL2, COL3.....\n\n                           FROM AA\n\n                     ) AS TEMP\n\n -A테이블의 특정 컬럼만 가져와서 AA라는 테이블을 생성하여 데이터를 INSERT한다.</code></pre></div>\n</li>\n<li>\n<p>INSERT INTO 사용법</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>INSERT INTO B SELECT * FROM A</p>\n<p>-위에서 테이블A와 테이블B는 스키마가 동일해야 한다. ( 데이터 구조, 같은 포맷을 가진 테이블)</p>\n</li>\n<li>\n<p>INSERT INTO B SELECT COL1,COL2,COL3 FROM A</p>\n<p>-만일 A보다 컬럼수가 적으면 SELECT뒤에 컬럼을 명시해준다</p>\n</li>\n</ul>\n<ul>\n<li>조인 : 두 개 이상의 테이블로부터 쿼리하여 하나의 결과물을 만드는 연산</li>\n</ul>\n<ol>\n<li>내부 조인(INNER JOIN) / 외부(OUTER JOIN)</li>\n</ol>\n<p>● INNER JOIN</p>\n<ul>\n<li>\n<p>ANSI 표준 : SELECT a.id, a.val aval, b.val bval FROM A a INNER JOIN B b ON a.id = b.id;</p>\n</li>\n<li>\n<p>Transact-SQL : SELECT a.id, a.val aval, b.val bval FROM A a ,B b WHERE a.id = b.id;</p>\n</li>\n</ul>\n<p>● LEFT OUTER JOIN</p>\n<ul>\n<li>\n<p>ANSI 표준 : SELECT a.id, a.val aval, b.val bval FROM A a LEFT OUTER JOIN B b ON a.id = b.id;</p>\n</li>\n<li>\n<p>Transact-SQL : SELECT a.id, a.val aval, b.val bval FROM A a , B b WHERE a.id *= b.id;</p>\n</li>\n</ul>\n<p>● RIGHT OUTER JOIN</p>\n<ul>\n<li>\n<p>ANSI 표준 : SELECT a.id, a.val aval, b.val bval FROM A a RIGHT OUTER JOIN B b ON a.id = b.id;</p>\n</li>\n<li>\n<p>Transact-SQL : SELECT a.id, a.val aval, b.val bval FROM A a , B b WHERE a.id =* b.id;</p>\n</li>\n</ul>\n<ul>\n<li>UNION</li>\n</ul>\n<ul>\n<li>\n<p>JOIN : 두 테이블이나 결과물을 병렬조합</p>\n<p>UNION : 쿼리의 결콰를 상하위로 합치는 직렬 조합</p>\n</li>\n<li>\n<p>UNION한 결과 전체에 대해서 GROUP BY 및 HAVING 절 사용하기 위해서는 임시테이블, 파생테이블 사용</p>\n</li>\n</ul>\n<p>SELECT stor_ID AS StoreID, Qty*2 AS Quantity\nINTO #SalesTemp FROM sales</p>\n<p>SELECT StoreID, SUM(Quantity)\nFROM\n( SELECT Stor_ID AS StoreID, Qty AS Quantity FROM sales\nUNION ALL\nSELECT * FROM #SalesTemp\n) t\nGROUP BY StoreID</p>\n<p>결과)</p>\n<p>6380 24\n7066 375</p>\n<ul>\n<li>DELETE / UPDATE</li>\n</ul>\n<ul>\n<li>\n<p>DELETE FROM authors WHERE au_lname = ‘McBadden’</p>\n</li>\n<li>\n<p>UPDATE authors SET state = ‘PC’ WHERE state = ‘CA’</p>\n</li>\n</ul>\n<ul>\n<li>INSERT</li>\n</ul>\n<ul>\n<li>\n<p>INSERT 문은 VALUE절과 함께 사용시 INTO 절을 생략가능</p>\n</li>\n<li>\n<p>삽입에서 명시되지 않아도 되는 컬럼</p>\n<ol>\n<li>\n<p>NULL 허락한 컬럼</p>\n</li>\n<li>\n<p>기본값을 가진 컬럼</p>\n</li>\n<li>\n<p>자동 증가형 속성을 가진 컬럼</p>\n</li>\n<li>\n<p>Rowversion or Timestamp 가진 컬럼</p>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>TRUNCATE TABLE / DELETE</li>\n</ul>\n<ul>\n<li>\n<p>WHERE 절이 없는 DELETE 문과 동일함</p>\n</li>\n<li>\n<p>DELETE : 자동증가형 속성이 유지 / TRUNCATE : 자동증가형 속성이 초기화됨</p>\n</li>\n<li>\n<p>DELETE 빠르고 트랜잭션 로그 리소스를 덜 사용 -DELETE 한 행 제거 후 각 행에 대해서 트랜잭션 로그 항목 기록</p>\n</li>\n<li>\n<p>TRUNCATE는 행별 삭제되는 내용이 로그되지 않아서 DELETE 트리거 작동안함</p>\n<p>트리거 : 특정 테이블에 자료가 수정될때 내부적으로 관련된 다른 테이블 또는 컬럼에 자동으로 연동하여서 무결성을 지키기 위한 것</p>\n</li>\n</ul>\n<h1 id=\"db-생성과-관리\" style=\"position:relative;\"><a href=\"#db-%EC%83%9D%EC%84%B1%EA%B3%BC-%EA%B4%80%EB%A6%AC\" aria-label=\"db 생성과 관리 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DB 생성과 관리</h1>\n<ul>\n<li>\n<p>데이터 베이스 : 관리하고 싶은 업무 단위와 관련된 오브젝트를 하나의 논리적인 저장소 단위로 일관성을 유지할 수 있는 관리의</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                  단위이며 복구의 단위</code></pre></div>\n</li>\n<li>\n<p>데이터베이스 기본적인 구성 : 파일 그룹 / 데이터 파일 / 로그파일</p>\n<ol>\n<li>\n<p>파일 그룹 : 여러 데이터 파일의 논리적인 집합</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">             디스크를 분산하여 성능을 향상을 고려할 수 있음.</code></pre></div>\n</li>\n<li>\n<p>데이터베이스 파일 : 데이터 파일과 로그 파일로 나눌 수 있으며 자료를 기록하는 물리적인 저장소 단위를 말함.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                        주파일 : 데이터베이스 시작정보와 데이터저장 / 보조파일 : 그 외 파일\n\n                        트랜잭션 로그파일 : 데이터 복구에 필요한 로그 정보가 저장</code></pre></div>\n</li>\n<li>\n<p>익스텐트 : 테이블과 인덱스에 할당되는 기본단위(하나의 익스텐트는 연속하는 8 페이지(64KB)로 구성됨)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">           기존에 할당한 저장공간이 부족할 경우 새로운 익스텐트를 할당받고 첫페이지부터 사용하게 된다.</code></pre></div>\n</li>\n<li>\n<p>데이터파일 : 익스텐트를 할당할 수 있는 물리적으로 확보된 공간</p>\n</li>\n<li>\n<p>페이지 : 페이지는 SQL 서버에서 데이터 저장소의 기본 단위</p>\n</li>\n</ol>\n</li>\n<li>\n<p>데이터베이스 생성</p>\n<ol>\n<li>\n<p>데이터베이스 : 여러 개의 데이터파일과 로그 파일로 구성</p>\n</li>\n<li>\n<p>여러 개의 물리적인 드라이브를 가지는 경우에 데이터파일은 여러개의 파일 그룹에 분산하여 하드디스크 I/O 분산하여 처리함.</p>\n<p>로그 크기는 데이터수정량과 로그의 백업일정에 따라서 다르며 기본적으로 10~25%</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>CREATE DATABASE [Testpubs] ON PRIMARY\n(NAME = N’Testpubs_Data’\n,FILENAME = N’C:\\TEMP\\Testpubs_Data.MDF’\n,SIZE = 5, MAXSIZE=100\n,FILEGROWTH=10%)\nLOG ON\n(NAME = N’Testpubs_Log’\n,FILENAME = N’C:\\TEMP\\Testpubs_Log.LDF’\n,SIZE = 2\n,FILEGROWTH=1MB)</p>\n<p>● ON : 데이터부분이 저장되는 데이터파일을 명시적으로 정의</p>\n<p>● PRIMARY : 주파일 정의</p>\n<p>● NAME : 논리적 이름</p>\n<p>● LOG ON : 데이터베이스 로그가 저장되는 디스크 파일을 명시적으로 정의함.</p>\n<p>● FOR LOAD : 데이터베이스의 백업자료로 복구하며, 초기화하기 위한 옵션</p>\n<p>● FOR ATTACH : 기존 운영체제 파일 집합에서 데이터베이스 연결 하기 위한 옵션</p>\n<ul>\n<li>파일 크기 늘이기와 새로운 파일 추가</li>\n</ul>\n<p>ALTER DATABASE [Testpubs] MODIFY FILE\n(NAME = ‘Testpubs_Data’\n,SIZE = 10)</p>\n<p>ALTER DATABASE [Testpubs] ADD FILEGROUP [Second]</p>\n<p>ALTER DATABASE [Testpubs] ADD FILE\n(NAME = N’Testpubs_Data2’\n,FILENAME = N’C:\\Temp\\Testpubs_Data2.NDF’\n,SIZE = 1, FILEGROWTH = 10%\n) TO FILEGROUP [Second]</p>\n<ul>\n<li>파일 그룹의 사용</li>\n</ul>\n<ul>\n<li>\n<p>파일 그룹은 테이블과 인덱스, BLOB형 자료, 즉 Image, text, ntext 데이터형을 저장될 공간을 명시적으로 할당함.</p>\n</li>\n<li>\n<p>BLOB(Binary Large Object)</p>\n</li>\n</ul>\n<p>ALTER DATABASE [Testpubs] ADD FILEGROUP [FG_Index]\nALTER DATABASE [Testpubs] ADD FILEGROUP [FG_BLOB]</p>\n<p>ALTER DATABASE [Testpubs] ADD FILE\n(NAME = N’Textpubs_Data3’\n,FILENAME = N’C:TEMP\\Testpubs_Data3.NDF’\n,SIZE = 1\n,FILEGROWTH = 10%) TO FILEGROUP [FG_Index]</p>\n<p>– BLOB Binary Large Object 약자로 image,text,ntext 데이터형<br>\nALTER DATABASE [Testpubs] ADD FILE\n(NAME = N’Textpubs_BLOB’\n,FILENAME = N’C:TEMP\\Testpubs_BLOB.NDF’\n,SIZE = 1\n,FILEGROWTH = 10%) TO FILEGROUP [FG_BLOB]</p>\n<p>CREATE TABLE [pub_info]\n([pub_id][char] (4) PRIMARY KEY ON [FG_Index] NOT NULL\n,[pub_name]<a href=\"10\">char</a> NOT NULL\n,[logo][image] NULL\n,[pr_info][text] NULL )\nON [PRIMARY]\nTEXTIMAGE_ON [FG_BLOB]</p>\n<ul>\n<li>데이터베이스 축소</li>\n</ul>\n<ol>\n<li>자동파일 축소 : 주기적으로 사용공간의 25% 빈 여우공간을 두고 축소하여 운영체에 반납한다.</li>\n</ol>\n<p>DBCC SHRINKFILE(Testpubs_Data, 25) - 30분간격으로 주기적으로 작업</p>\n<ol start=\"2\">\n<li>파일 수동 축소</li>\n</ol>\n<p>● EMPTYFILE : 모든 데이터를 동일한 파일 그룹의 다른 파일로 이동시키고 빈파일로 남김</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                     해당 파일을 물리적으로 다른 공간을 이동시키고 제거하는 목적</code></pre></div>\n<p>DBCC SHRINKFILE(Testpubs_Data2, EMPTYFILE)</p>\n<p>ALTER DATABASE Testpubs REMOVE FILE Testpubs_Data2</p>\n<p>● NOTRUNCATE : 해제된 파일 공간을 파일에 보유하고 해제된 공간을 운영체제에 반환하지 않는다.</p>\n<p>● TRUNCATEONLY : 파일에 사용되지 않은 공간을 운영체제에 반환, 데이터를 이동하지 않고 파일 크기를 줄인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                            TRUNCATEONLY 사용시 target_size는 무시된다.</code></pre></div>\n<p>DBCC SHRINKFILE(Testpubs_Data, 5, [EMPTYFILE | NOTRUNCATE|TRUNCATEONLY )</p>\n<ol start=\"3\">\n<li>데이터베이스 수동 축소</li>\n</ol>\n<ul>\n<li>\n<p>지정한 데이터베이스에서 모든 데이터파일과 로그 파일을 축소하기 위해서 사용함.</p>\n</li>\n<li>\n<p>ALTER DATABASE, DBCC SHRINKFILE 명시적으로 설정한 최종크기보다 작게 만들 수는 없다.</p>\n</li>\n</ul>\n<p>DBCC SHRINKDATABASE(Testpubs, 25) 25% 빈공간을 두고 축소(NOTRUNCATE , TRUNCATEONLY )</p>\n<ul>\n<li>\n<p>데이터베이스 변경 및 삭제</p>\n<ol>\n<li>파일 그룹 변경</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>\n<p>sp_help : 데이터베이스 개체, 사용자 정의 데이터 형식 또는 데이터 형식에 대한 정보를 보고</p>\n</li>\n<li>\n<p>Data_located on_filegroup -FG_Index</p>\n</li>\n</ul>\n<p>ALTER DATABASE Testpubs\nMODIFY FILEGROUP [FG_Index] DEFAULT</p>\n<p>CREATE TABLE Test( id int)</p>\n<p>EXEC sp_help Test</p>\n<ol start=\"2\">\n<li>데이터베이스명 변경</li>\n</ol>\n<ul>\n<li>\n<p>데이터베이스 이름 변경 시 단일 사용자 모드, 변경 후 다시 단일사용자 모드 해제</p>\n</li>\n<li>\n<p>ROLLBACK IMMEDIATE : 완료되지 않은 트랜잭션을 롤백하기 위해서 옵션을 넣어준다.</p>\n</li>\n</ul>\n<p>ALTER DATABASE Testpus\nSET SINGLE_USER WITH ROLLBACK IMMEDIATE</p>\n<p>EXEC sp_renamedb ‘Testpubs’, ‘TestpubsNew’</p>\n<p>EXEC sp_dboption TestpubsNew, ‘Single user’, FALSE</p>\n<ol start=\"3\">\n<li>데이터베이스 삭제</li>\n</ol>\n<p>DROP DATABASE TestpubsNew</p>\n<ul>\n<li>\n<p>데이터베이스 옵션</p>\n<ol>\n<li>자동옵션</li>\n</ol>\n<p>● AUTO_CLOSE : 데이터베이스를 마지막으로 사용한 사용자가 종료, 데이터베이스 종료되면 데이터베이스 리소스가 해제된다.</p>\n<p>● AUTO_CREATE_STATISTICS : 조건자에서 사용되는 열에 대해 자동으로 통계가 생성된다.</p>\n<p>● AUTO_UPDATE_STATISTICS : 데이터가 변경되고 기존 통계가 최신 상태가 아닐때 통계를 자동으로 업데이트 한다.</p>\n<p>● AUTO_SHRINK : 데이터베이스의 데이터파일과 로그 파일의 사용되지 않는 공간을 정기적으로 검사해서 축소한다.</p>\n<ol start=\"2\">\n<li>커서옵션</li>\n</ol>\n<p>● CURSOR_CLOSE_ON_COMMIT : 트랜잭션이 커밋될때 열려 있던 커서가 자동으로 닫힌다.</p>\n<p>● CURSOR_DEFAULT_LOCAL/GLOBAL : 설정된 커서의 범위가 로컬로 적용, 연결된 세션의 전역으로 적용</p>\n<ol start=\"3\">\n<li>복구옵션 / 상태옵션(SINGLE, READ_ONLY) / Nonlogged Operation(로그 파일에 기록을 남기지 않는 경우) / WITH<termination></li>\n</ol>\n</li>\n</ul>\n<p>ALTER DATABASE Testpus\nSET SINGLE_USER WITH ROLLBACK AFTER 300(초)</p>\n<p>EXEC sp_renamedb ‘Testpubs’, ‘TestpubsNew’</p>\n<p>EXEC sp_dboption TestpubsNew, ‘Single user’, FALSE</p>\n<ul>\n<li>\n<p>로그의 역할</p>\n<ul>\n<li>\n<p>로그는 해당 데이터베이스에 수정작업 모두를 기록해서 서버의 장애로 COMMIT을 하지 못할 경우에는 ROLLBACK을 수행해서</p>\n<p>데이터의 일관성을 유지하게 된다.</p>\n</li>\n<li>\n<p>트랜잭션 로그 기록사항</p>\n<p>트랜잭션의 시작과 끝, 모든 데이터 수정과 변경된 내용이 포함, 모든 익스텐트 할당, 취소</p>\n<p>테이블 또는 인덱스 만들기 또는 삭제</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"데이터형식-및-형변환\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EC%8B%9D-%EB%B0%8F-%ED%98%95%EB%B3%80%ED%99%98\" aria-label=\"데이터형식 및 형변환 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터형식 및 형변환</h1>\n<ul>\n<li>\n<p>가변 길이 데이터형</p>\n<p>가변 크기 데이터형 : varchar, varbinary, nvarchar</p>\n<p>크기고정X, 명시 할 수 없는 데이터형 : text, ntext, image, sql_variant</p>\n<ul>\n<li>text, image는 테이블 내의 저장소가 아닌 별도의 공간에 저장, 해당 저장소의 시작주소 16바이트를 가지고 운영함.</li>\n</ul>\n</li>\n<li>\n<p>가변길이, 고정길이 언제 사용?</p>\n<p>가변길이 : 큰 고정문자형을 정의하고 적은 크기 문자열을 사용할 때</p>\n<p>고정길이 : 입력포맷(3글자)이 고정되어 있는 곳에서는 고정길이를 쓰는 것이 더 좋은 성능을 얻을 수 있음</p>\n</li>\n<li>\n<p>유니코드</p>\n</li>\n</ul>\n<p>SELECT ASCII(‘A’) AS ASCIIA ,UNICODE(N’가’) AS UNICODE가</p>\n<p>SELECT CHAR(65) AS CHAR65 ,NCHAR(44032) AS CHAR44032</p>\n<p>=65, 44032 / A, 가</p>\n<ul>\n<li>숫자형 데이터 형식</li>\n</ul>\n<ol>\n<li>\n<p>정확한 숫자 : decimal, numeric</p>\n</li>\n<li>\n<p>근사 숫자 : float, real(float(24))</p>\n</li>\n</ol>\n<p>CREATE Table TestFloat\n(xNumeric Numeric(7,3) //DEFAULT 시 전체자리수 18, 소수점 이하 자릿수 0\n,xDecimal Decimal(7,3)\n,xFloat Float //근사값 저장되며 내부적으로 계산이 진행됨.\n,xReal Real)</p>\n<p>INSERT TestFloat VALUES(3,3,3,3)\nINSERT TestFloat VALUES(12.3,12.3,12.3,12.3)\nSELECT * FROM TestFloat</p>\n<p>3.000 3.000 3 3\n12.300 12.300 12.3000000001 12.3</p>\n<ul>\n<li>\n<p>datetime(밀리초) / smalldatetime(분)</p>\n</li>\n<li>\n<p>대형 데이터 형식</p>\n<ul>\n<li>\n<p>대형 데이터를 저장하기 위해서는 text, ntext, image 데이터형</p>\n</li>\n<li>\n<p>2G 저장 가능, 직접 해당 데이터페이지를 저장하지 않으며. 16바이트 포인터만 저장하고 실제로는 별도의 저장공간이 있음.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>기타 데이터 형식</p>\n<ol>\n<li>Timestamp 및 rowversion(8 Byte)</li>\n</ol>\n<p>● 데이터베이스 안에서 각 행의 자료에 대한 버전 관리</p>\n<p>● 데이터베이스에서 고유함이 보장된 자동 생성 이진수를 표시</p>\n<p>● 테이블 당 하나만 설정</p>\n<p>● @@DBTS 함수로 마지막으로 적용된 버전 넘버를 알 수 있다.</p>\n<p>● =,&#x3C;>,&#x3C;,>,&#x3C;=,>= 단순 비교 사용가능</p>\n<p>● 삭제에는 버전이 증가하지 않고 삽입에서만 가능함.</p>\n</li>\n</ul>\n<p>CREATE TABLE TestTimeStamp\n(ID int PRIMARY KEY\n,Name char(10)\n,xTimeStamp Timestamp)</p>\n<p>CREATE TABLE TestRowversion\n(ID int PRIMARY KEY\n,Name char(10)\n,xRowVersion rowversion)</p>\n<p>INSERT TestTimeStamp(ID, NAME) Values(1, ‘홍길동’)\nINSERT TestRowversion(ID, NAME) Values(1, ‘홍길동’)</p>\n<p>SELECT @@DBTS</p>\n<ol start=\"2\">\n<li>\n<p>Sql_variant</p>\n<p>● 하나의 컬럼에 여러 데이터형 저장을 지원하기 위한 데이터형</p>\n<p>● ntext, text, image, timestamp,sql_variant 지정 불가능</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>sql_variant 제약 및 특징</p>\n<ol>\n<li>\n<p>연산에 사용되기전에 기본 데이터 형식 값으로 변환되어야 한다.</p>\n<p>SELECT CONVERT(int, @MyVar1) + CONVERT(int, @MyVal2)</p>\n</li>\n<li>\n<p>최대 8016 바이트 이상 길이 가질 수 없다.</p>\n</li>\n<li>\n<p>IDENTITY 속성 설정 불가능</p>\n</li>\n<li>\n<p>대표키나 참조키 사용가능</p>\n</li>\n<li>\n<p>ATLTER TABLE 구문을 이용하여 text, ntext, image, timestamp, sql_variant 형 바꿀 수 없다.</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>DECLARE @MyVal1 AS sql_variant\nDECLARE @MyVal2 AS sql_variant\nSET @MyVal1 = 1\nSET @MyVal2 = ‘2’\nSELECT CONVERT(int, @MyVal1) + CONVERT(int, @MyVal2)</p>\n<ol start=\"3\">\n<li>\n<p>Uniqueidentifier</p>\n<ul>\n<li>GUID형을 나타내기 위한 데이터 형식</li>\n</ul>\n</li>\n</ol>\n<p>CREATE TABLE MyUniqueTable\n(UniqueID UNIQUEIDENTIFIER DEFAULT NEWID()\n,Characters char(10))</p>\n<ul>\n<li>\n<p>TABLE</p>\n<ul>\n<li>\n<p>테이블 구조의 변수를 선언</p>\n</li>\n<li>\n<p>table 변수는 배치 처리가 완료됨과 동시에 자동으로 제거된다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>DECLARE @TableVar TABLE\n(ID int PRIMARY KEY,\nName nchar(10))</p>\n<p>INSERT INTO @TableVar VALUES (1, N’홍’)\nINSERT INTO @TableVar VALUES (2, N’승아’)</p>\n<ul>\n<li>\n<p>사용자 정의 데이터형식</p>\n<ul>\n<li>sp_bindrule : 열 또는 별칭 데이터 형식에 규칙을 바인딩</li>\n</ul>\n</li>\n</ul>\n<p>CREATE RULE ZipCode_rule\nAS @value LIKE ‘[0-9][0-9][0-9]-[0-9][0-9][0-9]’</p>\n<p>EXEC sp_bindrule ‘ZipCode_rule’, ‘ZipCode’</p>\n<ul>\n<li>\n<p>데이터 형변환</p>\n<ol>\n<li>\n<p>묵시적 형변환</p>\n<p>SELECT 4/3, 4/3.0 -1 / 1.3333 SELECT ‘1’ + 2 , ‘1’+‘2’-3 , 12</p>\n</li>\n<li>\n<p>NULL 연산 : NULL 연산은 항상 NULL</p>\n<p>SET CONCAT_NULL_YIELDS_NULL ON일 경우 -문자열 NULL</p>\n</li>\n<li>\n<p>명시적 형변환(CAST, CONVERT)</p>\n</li>\n</ol>\n<ul>\n<li>STR(float_expression [ , length [ ,decimal ] ] )</li>\n</ul>\n</li>\n</ul>\n<p>float_expression : 소수점이 있는 근사치(float) 데이터 형식의 식입니다. 10자리가 넘을 경우 * 표현됨\nlength 총길이, 기본값은 10입니다.\ndecimal 16자리보다 클 경우 잘리게 됨</p>\n<p>예) SELECT ’&#x3C;’ + STR(11.1234) + ’>’\n&#x3C; 11></p>\n<h1 id=\"테이블과-제약-조건-생성과-사용\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC-%EC%A0%9C%EC%95%BD-%EC%A1%B0%EA%B1%B4-%EC%83%9D%EC%84%B1%EA%B3%BC-%EC%82%AC%EC%9A%A9\" aria-label=\"테이블과 제약 조건 생성과 사용 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테이블과 제약 조건 생성과 사용</h1>\n<ul>\n<li>\n<p>개체 식별자</p>\n<ul>\n<li>\n<p>서버, 데이터베이스, 테이블 뷰,열 등등 고유한 이름 즉 식별자를 가진다.</p>\n</li>\n<li>\n<p>구분 기호는 [] , \"\" 사용가능</p>\n<p>\"\" -QUOTED_IDENTIFIER ON일 경우 사용가능</p>\n</li>\n</ul>\n<ol>\n<li>식별자 규칙</li>\n</ol>\n<p>● 식별자 1-128개의 문자로 이루어짐</p>\n<p>● @(at기호) : 지역변수, 매개변수 / # : 임시테이블, 프로시저 / ## : 전역 임시 테이블</p>\n<p>● Transact-SQL @@ : @@IDENTITY</p>\n<p>● 예약어, 중간공백, 특수문자 사용불가능</p>\n<p>CREATE TABLE [$Emplayee Data] -구분기호 사용시 식별자로 사용가능</p>\n</li>\n<li>\n<p>임시테이블, 테이블 변수</p>\n<ol>\n<li>\n<p>공통점 : 임시적으로 테이블을 사용하고 폐기하기 위해서 사용</p>\n</li>\n<li>\n<p>다른점</p>\n<ul>\n<li>\n<p>임시테이블 : DROP Table 강제로 제거, 세션이 끊기면 자동 삭제</p>\n</li>\n<li>\n<p>테이블 변수 : 쿼리 분석기에서 GO 분리자를 넘어서면 자동으로 파기됨.</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p>CREATE TABLE #cnst_example</p>\n<p>(</p>\n<p>…</p>\n<p>) INTO #cnst_exam</p>\n<p>DECLARE @cnst_example TABLE</p>\n<p>(</p>\n<p>…</p>\n<p>)</p>\n<ul>\n<li>테이블 생성</li>\n</ul>\n<ol>\n<li>[ON { &#x3C;파일그룹| DEFAULT }]</li>\n</ol>\n<p>CREATE TABLE [pub_info]\n([pub_id] [char] (4) PRIMARY KEY ON [FG_Index] NOT NULL // pub_id FG_Index 파일그룹\n,[pub_name] [char] (10) NOT NULL\n,[logo] [image] NULL\n,[pr_info] [text] NULL)\nON [PRIMARY] // Default만 Primary\nTEXTIMAGE_ON [FG_BLOB] // logo, pr_info 파일 그룹</p>\n<ol start=\"2\">\n<li>NOT FOR REPLICATION</li>\n</ol>\n<ul>\n<li>복제를 통해 삽입되는 자료에 대해 새로운 증가값을 받지 않고 그대로 삽입</li>\n</ul>\n<p>CREATE TABLE Sales1\n(SaleID INT IDENTITY(1, 1) NOT FOR REPLICATION,\nCHECK NOT FOR REPLICATION (SaleID &#x3C;= 99999)\n,SalesRegion CHAR(2)\n,CONSTRAINT ID_PK PRIMARY KEY (SaleID))</p>\n<p>SET IDENTITY_INSERT Sales ON</p>\n<p>INSERT INTO sales1(SaleID, SalesRegion) SELECT s2.SaleID, s2.SalesRegion FROM sales2 S2</p>\n<p>SET IDENTITY_INSERT Sales OFF</p>\n<p>INSERT INTO Sales1 VALUES(‘H0’);</p>\n<p>1 ‘ho’</p>\n<p>2 ‘hk’</p>\n<p>1000 ‘hu’</p>\n<p>1001 ‘ha’</p>\n<p>3 ‘hi’</p>\n<ol start=\"3\">\n<li>\n<p>ROWGUIDCOL</p>\n<ul>\n<li>\n<p>uniqueidentifier 컬럼에만 ROWGUIDCOL 지정가능, 컴럼 고유 식별자 컬럼이란 것을 나타냄</p>\n</li>\n<li>\n<p>속성 설정시 컬럼의 값이 생성되지 않고 INSERT로 삽입 시 생성됨.</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>CREATE TABLE TestGUIDCOL\n(Seq int IDENTITY PRIMARY KEY\n,GUIDCOL uniqueidentifier DEFAULT(NEWID()) ROWGUIDCOL\n,Message varchar(5000))</p>\n<p>INSERT TestGUIDCOL (Message) VALUES(‘ROWGUIDCOL TEST’)\nINSERT TestGUIDCOL (Message) VALUES(‘IDENTITYCOL TEST’)</p>\n<p>SELECT ROWGUIDCOL, Message\nFROM TestGUIDCOL\nWHERE IDENTITYCOL = 1 // IDENTITY의 행을 비교하는 구문</p>\n<ol start=\"4\">\n<li>CONSTRAINT</li>\n</ol>\n<ul>\n<li>제약 조건을 정의함( 제약조건 : PRIMARY KEY, UNIQUE, CHECK 제약 등)</li>\n</ul>\n<p>CREATE TABLE Sales</p>\n<p>(</p>\n<p>…</p>\n<p>, CONSTRAINT PK_Sales PRIMARY KEY NONCLUSTERED</p>\n<p>(</p>\n<p>SaleDate, SlipNo</p>\n<p>)</p>\n<p>)</p>\n<ul>\n<li>IDENTITY</li>\n</ul>\n<p>● 컴럼에 정수값을 자동증가 및 감소되는 속성을 정의</p>\n<p>● CREATE ,ALTER TABLE 문으로 컬럼에 정의</p>\n<p>● 사용이유 : 유일한 식별자를 만들고 기본키로 사용하기 위해서사용</p>\n<ol>\n<li>IDENTITY 속성</li>\n</ol>\n<p>CREATE TABLE TestIDENTITY\n(ID int PRIMARY KEY IDENTITY(1000, 2), NAME char(10)) - 초기값, 증가치</p>\n<ol start=\"2\">\n<li>\n<p>@@IDENTITY : 마지막 ID 리턴함.</p>\n<p>SET IDENTITY_INSERT를 ON할 경우 IDENTITY값을 수정가능</p>\n<p>=유일값으로 설정하고 싶은 경우 PRIMARY KEY, UNIQUE KEY로 설정</p>\n</li>\n<li>\n<p>IDENTITYCOL 예약어</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>IDENTITY 컬럼행 리턴함. ( WHERE 사용 )</p>\n<p>WHERE IDENTITYCOL = 1</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>DBCC CEHCKIDENT</li>\n</ol>\n<ul>\n<li>\n<p>사용이유 : IDENTITY 속성 최대치에 넘어설 경우 오버플로우 오류, 초기치 설정가능</p>\n<p>DBCC CHECKIDENT(TestIDENTITY, RESEED, 500)</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li>@@IDENTITY 함수</li>\n</ol>\n<ul>\n<li>해당 세션에서 마지막으로 적용된 자동 증가값을 반환</li>\n</ul>\n<ul>\n<li>\n<p>계산된 컬럼</p>\n<ul>\n<li>물리적으로 저장되지 않은 가상컬럼(계산식으로 사용)</li>\n</ul>\n</li>\n</ul>\n<p>CREATE TABLE Sales</p>\n<p>( CustomerId int not null</p>\n<p>Amt AS ROUND(Qty*Price, -2)</p>\n<p>)</p>\n<p>INSERT INTO Sales VALUES(1115)</p>\n<ul>\n<li>테이블 수정 / 삭제</li>\n</ul>\n<p>CREATE TABEL TestAlterTable( column_a INT)</p>\n<p>ALTER TABLE TestAlterTable ADD column_b varchar(20) NULL</p>\n<p>ALTER COLUMN column_b int</p>\n<p>DROP COLUMN column_b</p>\n<p>DROP TABLE TestAlterTable</p>\n<ul>\n<li>제약조건</li>\n</ul>\n<p>● ALTER TABLE Customers ADD CONSTRAINT PK_Customers PRIMARY KEY CLUSTERED</p>\n<p>● 데이터 무결성 : 일관된 자료를 유지하기 위한 방법</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                       제약사항, 기본값, 자료삽입, 수정 삭제를 통해서 지켜야할 기준을 유지함.</code></pre></div>\n<p>● 참조무결성 : 기본키와 외래키의 관계를 유지(FOREIGN KET, CHECK)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                   CASECADE DELETE, CASECADE UPDATE</code></pre></div>\n<p>● 엔티티무결성 : 특정 테이블의 고유 엔티티 정의(PRIMARY, UNIQUE)</p>\n<p>● 도메인무결성 : 주워진 열에 데이터가 유효하도록 함(CHECK, DEFAULT, NOT NULL)</p>\n<ol>\n<li>제약조건</li>\n</ol>\n<ul>\n<li>NOCECK 옵션 : FOREIGN KEY 가지고 있지 않은 테이블에서 참조 무결성을 어기는 기존의 문제는 점검하지 않고 제약 생성</li>\n</ul>\n<p>ALTER TABLE [Order Details] WITH NOCHECK ADD CONSTRAINT [FK_Order_Details_Orders] FOREIGN KEY</p>\n<p>(</p>\n<p>[OrderID]</p>\n<p>) REFERENCES [Orders]</p>\n<p>(</p>\n<p>[OrderID]</p>\n<p>)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- DEFAULT 제약\n\n  ● INSERT 구문 사용시 입력되어야 할 값을 명시하지 않을 경우 DEFAULT 값이 대신들어감\n\n- CHECK 제약</code></pre></div>\n<p>ALTER TABLE ZipCode\nADD\nCONSTRAINT chk_ZipCode //check 제약조건 chk_ZipCode 만들고 INSERT 확인함.\nCHECK( phone LIKE ‘[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]‘)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- PRIMARY KEY / UNIQUE\n\n  ● PRIMARY : 유일한 식별자, 참조의 무결성을 위한 후보키 사용, NULL 포함X\n\n  ● UNIQUE : 유일한 식별자, 참조의 무결성을 위한 후보키 사용, NULL 포함O\n\n- FOREIGN KEY 제약조건\n\n  ● 같은 서버의 같은 데이터베이스 내에 있는 테이블만 참조가 가능\n\n  ● 외래키를 만들어서 참조 무결성을 구현\n\n      ALTER TABLE [Order Details] WITH NOCHECK ADD CONSTRAINT [FK_Order_Details_Orders] FOREIGN KEY</code></pre></div>\n<p>(</p>\n<p>[OrderID]</p>\n<p>) REFERENCES [Orders]</p>\n<p>(</p>\n<p>[OrderID]</p>\n<p>) ON DELETE CASCADE</p>\n<p>// ON UPDATE CASCADE</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> ON DELETE NO ACTION\n 다른 테이블의 기존 행에 있는 외래 키에서 참조하는 키가 포함된 행을 삭제/갱신하려고 하면 오류가 발생하고 UPDATE, DELETE\n\n 문이 롤백되도록 지정\n\n\n\n● DELETE/UPDATE CASCADE 제약 조건 정의 안할경우(트랜잭션 이용)\n\n   BEGIN TRAN</code></pre></div>\n<p>DELETE [Order Details] WHERE OrderID= 10248</p>\n<p>DELETE Orders WHERE OrderID = 10248</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   END TRAN</code></pre></div>\n<h1 id=\"시스템-지원-함수-및-연산자\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%A7%80%EC%9B%90-%ED%95%A8%EC%88%98-%EB%B0%8F-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"시스템 지원 함수 및 연산자 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시스템 지원 함수 및 연산자</h1>\n<ul>\n<li>수치연산 함수</li>\n</ul>\n<ol>\n<li>\n<p>CEILING, FLOOR</p>\n<ul>\n<li>SELECT CEILING(11.55), CEILING(11.11), FLOOR(11.11), FLOOR(11.55) -12, 12, 11, 11</li>\n</ul>\n</li>\n<li>\n<p>ROUND</p>\n<ul>\n<li>SELECT ROUND(11.22, 1) , ROUND(1111.2, -2) -11.20, 1100.0</li>\n</ul>\n</li>\n<li>\n<p>RAND</p>\n<ul>\n<li>INSERT INTO TestSales VALUE(RAND()*26) -0~25 사이에 임의의 값 생성</li>\n</ul>\n</li>\n<li>\n<p>POWER(X, Y) Y승, SQRT 제곱근</p>\n</li>\n</ol>\n<ul>\n<li>문자열 함수</li>\n</ul>\n<ol>\n<li>LTRIM, RTRIM(공백제거)</li>\n</ol>\n<p>SELECT ’&#x3C;’ + LTRIM(’ SQL서버 ’) + ’>’ - &#x3C;SQL 서버 ></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> ,'&lt;' + RTRIM('    SQL서버     ') + '>'     - &lt;      SQL 서버>\n\n , '&lt;' + LTRIM(RTRIM('    SQL서버     ')) + '>'   - &lt;SQL 서버></code></pre></div>\n<ol start=\"2\">\n<li>REPLICATE</li>\n</ol>\n<p>SELECT REPLICATE(‘OK’,4), ‘A’ + SPACE(5)+‘B’ - OKOKOKOK A B</p>\n<ol start=\"3\">\n<li>\n<p>REPLACE, STUFF</p>\n<p>SELECT REPLACE(‘대한 민국 만세’,‘민국’,‘독립 만’), - 대한 독립 만 만세</p>\n<p>STUFF(‘대한 민국 만세’,‘민국’,3,4,‘독립 만’) - 대한독립 만만세</p>\n</li>\n<li>\n<p>CHARINDEX, PATINDEX</p>\n<p>CHARINDEX(‘com’, title) -patten 시작 위치점 반환</p>\n<p>PATINDEX(‘%c[a-k]n%] -여러가지 옵션 사용가능.</p>\n</li>\n<li>\n<p>DEFFERENCE( 일치도 높으면 4, 낮으면 0, 한글 지원x)</p>\n<p>DEFFERENCE(‘can’, ‘con’) -3</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>날짜 및 시간 함수</p>\n<ol>\n<li>\n<p>DATEADD</p>\n<p>SELECT 월시작일 = DATEADD(dd, 1, date)</p>\n</li>\n<li>\n<p>DATEDIFF</p>\n<p>DATEDIFF(dd, newdate, olddate)</p>\n</li>\n<li>\n<p>DATEPART</p>\n<p>DATEPART(mm, GETDATE())</p>\n</li>\n<li>\n<p>DATANAME</p>\n<p>DATENAME(dw, GETDATE())</p>\n</li>\n</ol>\n</li>\n<li>\n<p>시스템 함수</p>\n<ol>\n<li>CAST and CONVERT</li>\n</ol>\n<p>CAST(11.11 AS char(10) , CONVERT(char(10) , 11.11)</p>\n<ol start=\"2\">\n<li>\n<p>COALESCE - 여러 컬럼 값 중 첫번째로 NULL이 아닌 값을 반환</p>\n</li>\n<li>\n<p>@@IDENTITY 세션에서 마지막에 부여된 Identity 값을 반환</p>\n</li>\n<li>\n<p>ISDATE, ISNULL(ISNULL(qty, 0)), ISNUMERIC</p>\n</li>\n<li>\n<p>@@ROWCOUNT</p>\n</li>\n</ol>\n<p>SELECT GETDATE() - 2001-10-22~~</p>\n<p>SELECT @@ROWCOUNT</p>\n<ol start=\"6\">\n<li>@@TRANCOUNT</li>\n</ol>\n<p>BEGIN TRANSACTION</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> ...</code></pre></div>\n<p>SELECT @@TRANCOUNT - 1</p>\n<p>BEGIN TRANSACTION</p>\n<p>…</p>\n<p>SELECT @@TRANCOUNT - 2</p>\n<ol start=\"7\">\n<li>\n<p>NULLIF(두값이 같으면 NULL, 아니면 첫번째 값을 반환)</p>\n<p>NULLIF(10, 10), NULLIF(10, 20)</p>\n</li>\n</ol>\n</li>\n<li>\n<p>연산자</p>\n<ol>\n<li>비트연산자</li>\n</ol>\n<ul>\n<li>\n<p>int, smallint, tinyint, image 제외한 bit, binary, varbinary 수행</p>\n</li>\n<li>\n<p>시스템 테이블의 정보값을 관리하는데 쓰인다.( 0001 autoclose, 0100 sp_dboption) OR연산으로 시스템 정보 설정</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>논리연산자</li>\n</ol>\n<ul>\n<li>\n<p>ALL : 비교하는 모든 값이 참일때 참이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">WHERE ID(1,7,9) ANY(SELECT ID FROM TestTemp - 4,6,8) -9</code></pre></div>\n</li>\n<li>\n<p>ANY, SOME : 비교하려는 값들 중 하나만 참이라도 참이 된다. SOME( ISO 표준 동의어 )</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">WHERE ID(1,7,9) ANY(SELECT ID FROM TestTemp - 4,6,8) -7,9</code></pre></div>\n</li>\n<li>\n<p>EXISTS(서브 질의에 데이터 존재하면 참), IN(나열된 값들 중 하나만 일치하면 참이된다.)</p>\n<p>IF EXISTS(SELECT * FROM SALES WHERE stor_id = ‘6380’)</p>\n<p>WHERE state IN(‘CA’, ‘IN’, ‘MD’)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"고급쿼리\" style=\"position:relative;\"><a href=\"#%EA%B3%A0%EA%B8%89%EC%BF%BC%EB%A6%AC\" aria-label=\"고급쿼리 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>고급쿼리</h1>\n<ul>\n<li>CASE 함수</li>\n</ul>\n<ul>\n<li>조건 목록을 평가하고 여러 결과 식 중 하나를 반환</li>\n</ul>\n<ol>\n<li>단순 CASE 함수( 단순 식과 비교)</li>\n</ol>\n<p>SELECT au_fname, au_lname</p>\n<p>CASE state</p>\n<p>WHEN ‘CA’ THEN ‘Califonia</p>\n<p>END AS StateName</p>\n<p>FROM authors</p>\n<ol start=\"2\">\n<li>검색된 CASE 함수</li>\n</ol>\n<p>SELECT title_id, CAST(title AS varchar(20)) AS title, price,\nPriceCategory =\nCASE\nWHEN price IS NULL THEN N’미정’\nWHEN price &#x3C; 10 THEN N’저가’\nWHEN price >= 10 AND price &#x3C; 20 THEN N’중가’\nELSE N’고가’\nEND<br>\nFROM titles\nORDER BY price</p>\n<ul>\n<li>\n<p>상관 하위 쿼리를 사용한 CASE 함수</p>\n<p>● 외부쿼리 : 서브(내부) 쿼리를 포함한 쿼리 / 내부쿼리(서브쿼리, 하위쿼리) : 쿼리 안의 쿼리</p>\n<ul>\n<li>외부 쿼리에 영향을 받아 하위 쿼리가 수행되는 것</li>\n</ul>\n</li>\n</ul>\n<p>SELECT stor_id, stor_name,</p>\n<p>CASE WHEN (SELECT COUNT(*) From Sales WHERE stor_id = s.stor_id) 3 THEN N’활성’</p>\n<p>ELSE ‘비활성’</p>\n<p>END AS 상태</p>\n<p>FROM Stores s</p>\n<ul>\n<li>\n<p>하위쿼리</p>\n<ul>\n<li>\n<p>SELECT, INSERT, UPDATE, DELETE 문이나 다른 하위 쿼리 내부에 중첩된 SELECT 쿼리(최대 32개 중첩이 가능)</p>\n</li>\n<li>\n<p>SELECT : 하나의 값으로 반환해서 표현</p>\n<p>WHERE : 하나의 열이나 행 집합(EXISTS, IN, ANY, ALL 논리연산자 이용)</p>\n<p>FROM : 여러 열이나 표현식으로 여러 행이 올수 있음(파생테이블)</p>\n</li>\n</ul>\n<ol>\n<li>하위쿼리 제한조건</li>\n</ol>\n<p>하위 쿼리는 TOP 절이 있는 경우에만 ORDER BY 절을 포함할 수 있습니다</p>\n<ol start=\"2\">\n<li>반복적으로 재계산하여 사용하는 경우는 먼저 계산값을 재사용함.</li>\n</ol>\n<p>DECLARE @SumQty int</p>\n<p>SELECT @SumQty = SUM(qty) FROM Sales</p>\n<p>SELECT stor_id, Qty, @SumQty FROM Sales</p>\n<ol start=\"3\">\n<li>IN을 사용한 하위쿼리 ( 조인으로 처리가능)</li>\n</ol>\n<p>SELECT title_id, title, pub_id, price</p>\n<p>FROM titles</p>\n<p>WHERE title_id IN( SELECT title_id FROM Sales WHERE qty>40)</p>\n<p>=</p>\n<p>SELECT titles.title_id, title, pub_id, price</p>\n<p>FROM titles INNER JOIN Sales</p>\n<p>ON titles.title_id = Sales.title_id AND qty>40</p>\n<ol start=\"4\">\n<li>하위 쿼리로 차집합 구하기(NOT IN 구문 이용)</li>\n</ol>\n<p>SELECT title_id, title FROM titles</p>\n<p>WHERE title_id NOT IN( SELECT title_id FROM Sales)</p>\n<ol start=\"5\">\n<li>EXISTS 사용</li>\n</ol>\n<p>SELECT DISTINCT pub_name\nFROM publishers\nWHERE EXISTS\n( SELECT * FROM titles\nWHERE pub_id = publishers.pub_id\nAND type=‘business’)</p>\n</li>\n</ul>\n<p>= IN사용</p>\n<p>SELECT DISTINCT pub_name\nFROM publishers\nWHERE pub_id IN\n( SELECT pub_id FROM titles WHERE type=‘business’ )</p>\n<ul>\n<li>\n<p>파생테이블</p>\n<ul>\n<li>FROM 절에 사용하는 하위 쿼리를 말함.</li>\n</ul>\n</li>\n</ul>\n<p>SELECT s.stor_id, stor_name, SumQty\nFROM stores t, (SELECT stor_id, SUM(qty) AS SumQty\nFROM sales\nGROUP BY stor_id ) AS s\nWHERE t.stor_id = s.stor_id</p>\n<p>SELECT s.stor_id, stor_name, SUM(qty) AS SumQty\nFROM stores t, sales s\nWHERE t.stor_id = s.stor_id\nGROUP BY s.stor_id, stor_name</p>\n<ul>\n<li>부분 범위 조회</li>\n</ul>\n<ul>\n<li>\n<p>TOP 명령어를 이용한 부분 범위를 설정가능함.</p>\n</li>\n<li>\n<p>저장프로시저 : 쿼리문의 집합으로 어떠한 동작을 일괄처리하기 위한 용도로 사용된다.</p>\n</li>\n</ul>\n<p>CREATE PROCEDURE up_GetOrders\n@Move nchar(1) = N’F’,\n@OrderID int = NULL\nAS\nIF @Move = N’F’\nSELECT TOP 10 * FROM Orders\nORDER BY OrderID DESC</p>\n<p>IF @Move = N’L’\nSELECT _\nFROM ( SELECT TOP 10 _ FROM Orders\nORDER BY OrderID ASC) t\nORDER BY OrderID DESC</p>\n<p>=EXEC up_GetOrders ‘L’</p>\n<ul>\n<li>상관하위쿼리</li>\n</ul>\n<p>SELECT so.* FROM Sales so</p>\n<p>WHERE so.SaleQty = ( SELECT MAX(si.SaleQty) FROM Sales si</p>\n<p>WHERE so.ProductID = si.ProductID)</p>\n<ul>\n<li>동적쿼리 : 동적으로 쿼리 문자열을 만들고 EXECUTE 문으로 실행할 수 있다.</li>\n</ul>\n<p>장점 : 쿼리의 재사용의 효율을 높여서 DB 성능을 높인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">       복잡한 쿼리, 자주사용하는 쿼리를 단순화해서 사용할 수 있다.</code></pre></div>\n<ul>\n<li>STR : 소수점 이하는 절삭하고 10자리 문자열로 만들어준다.</li>\n</ul>\n<p>CREATE PROC Sales_TopN\n@CNT AS int\nAS\nDECLARE @Str VARCHAR(100)\nSELECT @Str = ‘SELECT TOP ’ + STR(@CNT) + ‘Stor_id, Qty FROM Sales ORDER BY Qty DESC’\nEXEC(@Str)</p>\n<p>EXEC Sales_TopN 10</p>\n<ul>\n<li>COMPUTE BY</li>\n</ul>\n<ol>\n<li>COMPUTE와 GROUP BY의 차이를 요약</li>\n</ol>\n<p>GROUP BY는 단일 결과 집합을 반환합니다. 각 그룹별로 그룹화 열과 해당 그룹의 하위 집계를 보여 주는 집계 함수가 포함된 하나의 행이 있습니다. SELECT 목록에는 그룹화 열과 집계 함수만 포함될 수 있습니다. 원시데이터를 보여주지 않음.\nCOMPUTE (BY)는 원시데이터를 보여주고, 원시데이터와 함꼐 소계와 총계를 조회할 때 많이 쓰인다.\nCOMPUTE BY 절의 컬럼들은 ORDER BY 절에 명시되어 있어야함.\nSELECT stor_id, ord_num, title_id, payterms, qty\nFROM sales\nWHERE stor_id LIKE ‘706%’\nORDER BY stor_id, qty DESC\nCOMPUTE AVG(qty), SUM(qty) BY stor_id</p>\n<p>COMPUTE AVG(qty), SUM(qty)</p>\n<p>SELECT qty, AVG(qty), SUM(qty)\nFROM sales\nWHERE stor_id LIKE ‘706%’\nGROUP BY qty\nORDER BY qty</p>\n<h1 id=\"인덱스-디자인과-사용\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%94%94%EC%9E%90%EC%9D%B8%EA%B3%BC-%EC%82%AC%EC%9A%A9\" aria-label=\"인덱스 디자인과 사용 permalink\" class=\"custom-class before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 디자인과 사용</h1>\n<ul>\n<li>용어정리</li>\n</ul>\n<ul>\n<li>\n<p>인덱스페이지 : 실제 인덱스가 저장되어 있는 페이지</p>\n</li>\n<li>\n<p>데이터페이지 : 실제 데이터가 저장된 페이지</p>\n</li>\n<li>\n<p>쿼버드 쿼리(Covered Query) : 조회 컬럼과 조건 컬럼을 복합키로 클러스터되지 않은 인덱스로 만든 것</p>\n</li>\n</ul>\n<ul>\n<li>인덱스</li>\n</ul>\n<ul>\n<li>쿼리의 응답속도 향상시키기 위해서 사용됨</li>\n</ul>\n<ul>\n<li>인덱스 사용하는 이유</li>\n</ul>\n<ul>\n<li>\n<p>주로 자료의 조회뿐만 아니라, 검색 조건을 가진 갱신에 대해서도 수행속도를 높임</p>\n</li>\n<li>\n<p>유일성을 강화하여 중복자료 발생을 막기 위해서 사용됨.</p>\n</li>\n</ul>\n<ul>\n<li>인덱스의 단점</li>\n</ul>\n<ul>\n<li>\n<p>인덱스는 별도의 저장 공간이 더 필요하며, 인덱스가 많은 경우 데이터를 삽입, 업데이트, 삭제 명령어를 수행할 때 시간이 더 걸린다.</p>\n</li>\n<li>\n<p>또한 유지, 관리하기 위한 처리시간이 더 필요하다.</p>\n</li>\n</ul>\n<ul>\n<li>클러스터된 인덱스</li>\n</ul>\n<ul>\n<li>\n<p>키 값을 기준으로 테이블에 데이터 행을 정렬하고 저장하는 인덱스, 한 페이지 내의 데이터는 인덱스 키를 기준으로 정렬됨</p>\n</li>\n<li>\n<p>많은 자료 중 하나의 자료를 얻는 것, 데이터 자체가 정렬되어 있기 때문에 범위 검색이 더 효율적으로 사용된다.</p>\n</li>\n<li>\n<p>데이터의 저장소와 인덱스의 저장소가 같이 존재하는 경우이며 데이터는 인덱스의 순서대로 저장하게 된다.</p>\n</li>\n</ul>\n<ul>\n<li>클러스터 되지 않은 인덱스</li>\n</ul>\n<ul>\n<li>\n<p>데이터의 저장소와 인덱스의 저장소가 별도의 공간으로 분리되어 있으면서 데이터 저장소에 있는 행을 찾아 갈 수 있는 포인터를 갖는</p>\n<p>인덱스</p>\n</li>\n<li>\n<p>클러스터 인덱스가 존재하지 않은 경우 RID(행식별자) 포인터로 가지며, 클러스터된 인덱스가 존재하는 경우 클러스터된 인덱스 키 값을</p>\n<p>포인터로 갖음.</p>\n</li>\n</ul>\n<ul>\n<li>인덱스 디자인</li>\n</ul>\n<p>● 인덱스가 유용한 경우</p>\n<ul>\n<li>\n<p>특정 검색 키 값과 정확히 일치하는 행을 검색하는 경우(WHERE emp_id = 357)</p>\n</li>\n<li>\n<p>특정 범위에 있는 검색 키 값을 가진 행을 검색하는 경우(WHERE job_lvl BETWEEN 9 and 12)</p>\n</li>\n<li>\n<p>조인 조건자를 기준으로 테이블 T2행과 일치하는 테이블 T1의 행을 검색하는 경우</p>\n</li>\n<li>\n<p>특정 컬럼을 기준으로 정렬된 쿼리 출력을 만드는 경우(ORDER BY Qty DESC)</p>\n</li>\n<li>\n<p>유일성 강화하기 위해 PRIMARY KEY 및 UNIQUE 제약 조건을 보장하는 경우</p>\n</li>\n<li>\n<p>FOREIGN KEY 제약 조건이 정의되는 두 테이블 사이의 참조 무결성을 보장하는 경우</p>\n</li>\n</ul>\n<p>● 인덱스가 유용하지 않은 경우</p>\n<ul>\n<li>\n<p>서로 다른 값이 적은 컬럼 : 성별과 같이 유일자가 작은 경우</p>\n</li>\n<li>\n<p>긴 문자열 데이터형 컬럼( 한페이지에 넣을 수 있는 인덱스의 한계가 있으므로)</p>\n</li>\n<li>\n<p>검색 대상이 자주 사용되지 않은 컬럼</p>\n</li>\n<li>\n<p>bit, text, ntext, image 데이터 형에는 인덱스를 생성할 수 없음</p>\n</li>\n<li>\n<p>작은 테이블에서 인덱스 사용X(테이블 스캔보다 인덱스 통화 시간이 더 길어질 수 있으므로)</p>\n</li>\n</ul>\n<p>● 인덱스 디자인을 위한 추가지침</p>\n<ul>\n<li>\n<p>테이블의 데이터가 변경되면 인덱스도 모두 조정되야 하므로 테이블에 인덱스를 많이 만들면 INSERT, UPDATE, DELETE 성능이</p>\n<p>나빠진다</p>\n</li>\n<li>\n<p>SELECT 문과 같이 데이터를 수정하지 않은 쿼리에 대해서는 성능이 좋아진다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>데이터 및 인덱스 저장 구조</p>\n<p>● 클러스터된 인덱스를 갖고 있는 클러스터된 테이블</p>\n<ul>\n<li>데이터 행은 클러스터된 인덱스 키에 기반한 순서대로 저장된다.</li>\n</ul>\n<p>● 클러스터된 인덱스가 없는 테이블(힙)</p>\n<ul>\n<li>특정 순서로 저장되지 않으며 데이터 페이지 시퀀스에 대한 특별한 순서는 없다.</li>\n</ul>\n<p>● 인덱스 ID(sysindexes에서 확인가능)</p>\n<ul>\n<li>\n<p>클러스터된 인덱스가 존재하지 않은 테이블에 대해서는 indid 값 : 0</p>\n</li>\n<li>\n<p>클러스터된 인덱스 indid값 : 1</p>\n</li>\n<li>\n<p>클러스터되지 않은 인덱스 indid값 : 2~250</p>\n</li>\n<li>\n<p>text, ntext, image 열이 있는 테이블 : 255</p>\n</li>\n</ul>\n<p>● Root와 FirstIAM</p>\n<ul>\n<li>\n<p>sysindexes의 root 컬럼은 인덱스 B-트리의 맨위를 가리킨다.</p>\n<p>FirstIAM -IAM(테이블의 데이터 페이지 컬렉션) -데이터행 헤더</p>\n</li>\n</ul>\n</li>\n<li>\n<p>데이터를 검색하는 여러가지 방법</p>\n<p>● 테이블 스캔 : 클러스터된 인덱스가 존재하지 않은 테이블에서 IAM 페이지 체인을 이용하여 테이블의 모든 페이지를 I/O 작업</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                    FirstIAM -IAM 페이지 체인의 시작포인터를 통해서 자료가 있는 모든 페이지를 가져옴</code></pre></div>\n</li>\n</ul>\n<p>SELECT _ FROM OrderX\nSELECT _ FROM Orders</p>\n<p>● IAM을 사용하는 클러스터된 인덱스 스캔</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> - 클러스터된 인덱스 전체를 스캔할 때 클러스터된 인덱스의 중간수준 인덱스를 사용하지 않고 IAM을 통해 클러스터된 인덱스 잎\n\n   노드, 즉 모든 데이터 페이지를 I/O하여 작업한다.</code></pre></div>\n<p>● 이전 이후 페이지 포인터로 클러스터된 인덱스</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> - 클러스터된 인덱스에서는 데이터 페이지 내에 이전 이후 페이지 포인터를 통해 첫페이지나 마지막 페이지에서부터 순차적으로\n\n   전체페이지를 IO한다.( 이전과 다음 페이지 포인터를 통해서 조회)\n\n - 클러스터 인덱스 : 클러스터 인덱스 키 값을 사용(데이터페이지 공존), 클러스터 되지 않은 인덱스 : 인덱스 페이지를 이용해서\n\n                              데이터페이지를 찾음</code></pre></div>\n<p>SELECT * FROM Orders ORDER BY OrderID\nSELECT OrderID FROM Orders ORDER BY OrderID DESC</p>\n<p>● 클러스터되지 않은 인덱스 스캔</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> - 인덱스 검색을 사용하지 않고 인덱스 페이지만을 스캔하여 처리할 수 있는 경우</code></pre></div>\n<p>SELECT COUNT(*) FROM Orders</p>\n<p>● 클러스터 된 인덱스 검색</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> -  인덱스 루트 노드로부터 B-Tree 검색을 수행하여 결과를 얻음</code></pre></div>\n<p>SELECT _ FROM OrderX\nSELECT _ FROM Orders</p>\n<p>● 클러스터되지 않은 인덱스 검색</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> - B-Tree 검색을 수행하면서 인덱스의 키나 행 식별자를 가지고 책갈피 연산을 수행함.</code></pre></div>\n<p>SE Northwind</p>\n<p>SELECT * INTO OrderX FROM Orders</p>\n<p>CREATE INDEX OrderX_OrderDate\nON OrderX(OrderDate)</p>\n<p>CREATE INDEX Orders_OD_C\nON Orders(OrderDate, CustomerID)\nGO</p>\n<p>EXEC sp_helpindex OrderX\nEXEC sp_helpindex Orders\nGO</p>\n<ul>\n<li>인덱스 디자인</li>\n</ul>\n<p>● 인덱스가 유용한 경우</p>\n<ul>\n<li>\n<p>특정 검색 키 값과 정확히 일치하는 행을 검색하는 경우(WHERE emp_id = 357)</p>\n</li>\n<li>\n<p>특정 범위에 있는 검색 키 값을 가진 행을 검색하는 경우(WHERE job_lvl BETWEEN 9 and 12)</p>\n</li>\n<li>\n<p>조인 조건자를 기준으로 테이블 T2행과 일치하는 테이블 T1의 행을 검색하는 경우</p>\n</li>\n<li>\n<p>특정 컬럼을 기준으로 정렬된 쿼리 출력을 만드는 경우(ORDER BY Qty DESC)</p>\n</li>\n<li>\n<p>유일성 강화하기 위해 PRIMARY KEY 및 UNIQUE 제약 조건을 보장하는 경우</p>\n</li>\n<li>\n<p>FOREIGN KEY 제약 조건이 정의되는 두 테이블 사이의 참조 무결성을 보장하는 경우</p>\n</li>\n</ul>\n<p>● 인덱스가 유용하지 않은 경우</p>\n<ul>\n<li>\n<p>서로 다른 값이 적은 컬럼 : 성별과 같이 유일자가 작은 경우</p>\n</li>\n<li>\n<p>긴 문자열 데이터형 컬럼( 한페이지에 넣을 수 있는 인덱스의 한계가 있으므로)</p>\n</li>\n<li>\n<p>검색 대상이 자주 사용되지 않은 컬럼</p>\n</li>\n<li>\n<p>bit, text, ntext, image 데이터 형에는 인덱스를 생성할 수 없음</p>\n</li>\n<li>\n<p>작은 테이블에서 인덱스 사용X(테이블 스캔보다 인덱스 통화 시간이 더 길어질 수 있으므로)</p>\n</li>\n</ul>\n<p>● 인덱스 디자인을 위한 추가지침</p>\n<ul>\n<li>\n<p>테이블의 데이터가 변경되면 인덱스도 모두 조정되야 하므로 테이블에 인덱스를 많이 만들면 INSERT, UPDATE, DELETE 성능이</p>\n<p>나빠진다</p>\n</li>\n<li>\n<p>SELECT 문과 같이 데이터를 수정하지 않은 쿼리에 대해서는 성능이 좋아진다.</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>데이터 및 인덱스 저장 구조</p>\n<p>● 클러스터된 인덱스를 갖고 있는 클러스터된 테이블</p>\n<ul>\n<li>데이터 행은 클러스터된 인덱스 키에 기반한 순서대로 저장된다.</li>\n</ul>\n<p>● 클러스터된 인덱스가 없는 테이블(힙)</p>\n<ul>\n<li>특정 순서로 저장되지 않으며 데이터 페이지 시퀀스에 대한 특별한 순서는 없다.</li>\n</ul>\n<p>● 인덱스 ID(sysindexes에서 확인가능)</p>\n<ul>\n<li>\n<p>클러스터된 인덱스가 존재하지 않은 테이블에 대해서는 indid 값 : 0</p>\n</li>\n<li>\n<p>클러스터된 인덱스 indid값 : 1</p>\n</li>\n<li>\n<p>클러스터되지 않은 인덱스 indid값 : 2~250</p>\n</li>\n<li>\n<p>text, ntext, image 열이 있는 테이블 : 255</p>\n</li>\n</ul>\n<p>● Root와 FirstIAM</p>\n<ul>\n<li>\n<p>sysindexes의 root 컬럼은 인덱스 B-트리의 맨위를 가리킨다.</p>\n<p>FirstIAM -IAM(테이블의 데이터 페이지 컬렉션) -데이터행 헤더</p>\n</li>\n</ul>\n</li>\n<li>\n<p>데이터를 검색하는 여러가지 방법</p>\n<p>● 테이블 스캔 : 클러스터된 인덱스가 존재하지 않은 테이블에서 IAM 페이지 체인을 이용하여 테이블의 모든 페이지를 I/O 작업</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                    FirstIAM -IAM 페이지 체인의 시작포인터를 통해서 자료가 있는 모든 페이지를 가져옴</code></pre></div>\n</li>\n</ul>\n<p>SELECT _ FROM OrderX\nSELECT _ FROM Orders</p>\n<p>● IAM을 사용하는 클러스터된 인덱스 스캔</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> - 클러스터된 인덱스 전체를 스캔할 때 클러스터된 인덱스의 중간수준 인덱스를 사용하지 않고 IAM을 통해 클러스터된 인덱스 잎\n\n   노드, 즉 모든 데이터 페이지를 I/O하여 작업한다.</code></pre></div>\n<p>● 이전 이후 페이지 포인터로 클러스터된 인덱스</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> - 클러스터된 인덱스에서는 데이터 페이지 내에 이전 이후 페이지 포인터를 통해 첫페이지나 마지막 페이지에서부터 순차적으로\n\n   전체페이지를 IO한다.( 이전과 다음 페이지 포인터를 통해서 조회)\n\n - 클러스터 인덱스 : 클러스터 인덱스 키 값을 사용(데이터페이지 공존), 클러스터 되지 않은 인덱스 : 인덱스 페이지를 이용해서\n\n                              데이터페이지를 찾음</code></pre></div>\n<p>SELECT * FROM Orders ORDER BY OrderID\nSELECT OrderID FROM Orders ORDER BY OrderID DESC</p>\n<p>● 클러스터되지 않은 인덱스 스캔</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> - 인덱스 검색을 사용하지 않고 인덱스 페이지만을 스캔하여 처리할 수 있는 경우</code></pre></div>\n<p>SELECT COUNT(*) FROM Orders</p>\n<p>● 클러스터 된 인덱스 검색</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> -  인덱스 루트 노드로부터 B-Tree 검색을 수행하여 결과를 얻음</code></pre></div>\n<p>SELECT _ FROM OrderX\nSELECT _ FROM Orders</p>\n<p>● 클러스터되지 않은 인덱스 검색</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> - B-Tree 검색을 수행하면서 인덱스의 키나 행 식별자를 가지고 책갈피 연산을 수행함.</code></pre></div>\n<p>SE Northwind</p>\n<p>SELECT * INTO OrderX FROM Orders</p>\n<p>CREATE INDEX OrderX_OrderDate\nON OrderX(OrderDate)</p>\n<p>CREATE INDEX Orders_OD_C\nON Orders(OrderDate, CustomerID)\nGO</p>\n<p>EXEC sp_helpindex OrderX\nEXEC sp_helpindex Orders\nGO</p>\n<ul>\n<li>인덱스를 사용하지 않은 가능성이 높은 쿼리문</li>\n</ul>\n<ol>\n<li>부정 검색 조건에서의 인덱스 사용</li>\n</ol>\n<p>SELECT * FROM orders WHERE OrderDate &#x3C;‘19960704’</p>\n<ol start=\"2\">\n<li>인덱스 컬럼 변형에 대한 검색</li>\n</ol>\n<p>SELECT * FROM orders WHERE CONVERT(char(5), OrderID) LIKE ‘1024%’</p>\n<ol start=\"3\">\n<li>데이터형이 맞지 않는 검색조건</li>\n</ol>\n<p>CREATE TABLE TestOrders\n(OrderID char(5) NOT NULL,\n…</p>\n<p>SELECT * FROM TestOrders WHERE OrderID = 10500</p>\n<ol start=\"4\">\n<li>패턴 조건 검색에서 인덱스 사용</li>\n</ol>\n<p>SELECT * FROM TestOrder WHERE OrderID LIKE ‘%500’</p>\n<ul>\n<li>인덱스 생성 옵션</li>\n</ul>\n<p>CREATE NONCLUSTERED INDEX zip_ind</p>\n<p>ON authors(zip)</p>\n<p>WITH FILLFACTOR = 70 -70 FILLFACTOR 채워서 30% 빈공간을 만듦</p>\n<p>● FILLFACTOR - 인덱스 페이지를 어느정도 압축하거나 비워 놓을 것인가를 설정할 수 있는 옵션,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                       잎 노드의 인덱스 페이지를 명시한 % 만큼 사용하고 나머지는 비우게 된다.\n\n                  -인덱스 페이지 공간이 부족하다면 새로운 페이지를 할당받아야 하므로 이런 페이지 분할 작업을 줄이기 위해서 사용됨</code></pre></div>\n<p>● PAD_INDEX : 인덱스 잎 페이지 외에 나머지 인덱스 페이지들의 수준을 FILLFACTOR 명시한 수준으로 바꿈</p>\n<p>● IGNORE_DUP_KEY :</p>\n<p>-INSERT 작업으로 중복 자료가 입력되는 것에 대해 오류 대신 경고로 처리, UPDATE 작업으로 중복이 발생되는 것은 오류로 처리한다.\nUSE tempdb\nGO</p>\n<p>CREATE TABLE emp_pay\n(employeeID int NOT NULL\n,base_pay money NOT NULL\n,commision decimal(2,2) NOT NULL)\nGO</p>\n<p>CREATE UNIQUE CLUSTERED INDEX employeeID_ind\nON emp_pay(employeeID)\nWITH IGNORE_DUP_KEY\nGO</p>\n<p>INSERT emp_pay VALUES(1, 500, .10) -가능(중복된 키값이라도 가능)\nINSERT emp_pay VALUES(1, 1000, .05)\nGO</p>\n<p>SET NOCOUNT ON</p>\n<p>INSERT emp_pay VALUES(5,0,.03)\nSELECT @@ERROR\nGO</p>\n<p>UPDATE emp_pay SET employeeID = 1 WHERE base_pay = 500\nSELECT @@ERROR\nGO</p>\n<p>SELECT * FROM emp_pay</p>\n<p>=결과</p>\n<p>메시지 2601, 수준 14, 상태 1, 줄 2\n고유 인덱스가 ‘employeeID_ind’인 개체 ‘dbo.emp_pay’에 중복 키 행을 삽입할 수 없습니다. 중복 키 값은 (1)입니다.</p>\n<p>● DROP_EXISTING / STATISTICS_NORECOMPUTE / SORT_IN_TEMPDB</p>\n<ul>\n<li>\n<p>DBCC SHOWCONTIG</p>\n<ul>\n<li>\n<p>테이블의 조각화 여부를 파악하는데 사용한다. 테이블의 조각화는 테이블에서 INSERT, UPDATE,DELETE 문 등의 데이터 수정 문을</p>\n<p>처리할 때 발생한다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>DBCC INDEXDEFRAG</p>\n<ul>\n<li>인덱스의 잎 수준 페이지를 논리적순서로 다시 정렬한다.</li>\n</ul>\n</li>\n<li>\n<p>DBCC DBREINDEX</p>\n<ul>\n<li>테이블의 특정 인덱스나 테이블에 정의도니 모든 인덱스를 다시 작성한다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"MSSQL","date":"2020.02.14","category":"개발","tags":["database"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC\">용어정리</a></p>\n</li>\n<li>\n<p><a href=\"#sql-server-%EA%B0%9C%EC%9A%94\">SQL Server 개요</a></p>\n</li>\n<li>\n<p><a href=\"#transact-sql-%EA%B8%B0%EC%B4%88\">Transact-SQL 기초</a></p>\n<ul>\n<li><a href=\"#deptno\">DEPTNO</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#db-%EC%83%9D%EC%84%B1%EA%B3%BC-%EA%B4%80%EB%A6%AC\">DB 생성과 관리</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95%EC%8B%9D-%EB%B0%8F-%ED%98%95%EB%B3%80%ED%99%98\">데이터형식 및 형변환</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC-%EC%A0%9C%EC%95%BD-%EC%A1%B0%EA%B1%B4-%EC%83%9D%EC%84%B1%EA%B3%BC-%EC%82%AC%EC%9A%A9\">테이블과 제약 조건 생성과 사용</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%A7%80%EC%9B%90-%ED%95%A8%EC%88%98-%EB%B0%8F-%EC%97%B0%EC%82%B0%EC%9E%90\">시스템 지원 함수 및 연산자</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B3%A0%EA%B8%89%EC%BF%BC%EB%A6%AC\">고급쿼리</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%94%94%EC%9E%90%EC%9D%B8%EA%B3%BC-%EC%82%AC%EC%9A%A9\">인덱스 디자인과 사용</a></p>\n</li>\n</ul>"}}]}},"pageContext":{"slug":"/blog/2020/02/2020-02-14-mssql/","previous":{"fields":{"slug":"/blog/2020/02/2020-02-16-winapi/"},"frontmatter":{"title":"Windows API"}},"next":{"fields":{"slug":"/blog/2020/01/2020-01-01-pdf/"},"frontmatter":{"title":"pdf"}}}},"staticQueryHashes":["3940312266","4157816502"]}